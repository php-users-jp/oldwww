<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
  "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML lang="ja">
<HEAD>
<META name="description" content="__COMMENT__">
<META http-equiv="Content-Style-Type" content="text/css">
<META http-equiv="Content-Script-Type" content="text/javascript">
<TITLE>PHP Base Library ドキュメント リリース phplib_7: HTML ウィジェットクラス</TITLE>
<LINK rel="stylesheet" href="../../style.css">
<LINK HREF="documentation-6.html" REL=next>
<LINK HREF="documentation-4.html" REL=previous>
<LINK HREF="documentation.html#toc5" REL=contents>
<!--<SCRIPT language="JavaScript" src="rollover.js"> -->
</HEAD>

<BODY>
<A HREF="documentation-6.html">次</A>
<A HREF="documentation-4.html">前</A>
<A HREF="documentation.html#toc5">目次</A>
<HR>
<H2><A NAME="s5">5. HTML ウィジェットクラス</A></H2>

<H2><A NAME="ss5.1">5.1 Sql_Query</A>
</H2>

<P>Sql_Query は簡単なテーブルへのクエリーに関するクエリーフォームを次のように
生成します。
フィールド名のリスト、比較演算子、入力フィールドが表示されます。
ユーザーは、SQL 標準の演算子を用いて表示された任意の列について任意の値を
検索できます。
複数の検索条件も指定可能で、検索条件はANDやOR演算子を用いて結合することが
できます。
<P>クエリー条件の個数は可変にできます。この場合、ユーザーは適当なボタンを
用いてクエリーウィジェットを絞ったり拡大したりできます。
<P>全てのボタンラベルやインターフェース上の他のメッセージは変更可能であり、
言語辞書に格納されています。現時点では <em>de</em>(独語)と <em>en</em>
(英語)に関する辞書が提供されています。
<P>
<H3>インスタンス変数</H3>

<P>
<P>
<CENTER><TABLE BORDER><TR><TD>
<BR>
classname</TD><TD>シリアル化ヘルパ: このクラスの名前。</TD></TR><TR><TD>
persistent_slots</TD><TD>シリアル化ヘルパ: 全ての持続的スロットの名前</TD></TR><TR><TD>
conditions</TD>	<TD>クエリ条件の個数</TD></TR><TR><TD>
input_size</TD>	<TD>入力フィールドで見える最大文字数</TD></TR><TR><TD>
input_max</TD><TD>入力フィールドの最大入力文字数</TD></TR><TR><TD>
method</TD><TD>フォーム送信手順(GETまたはPOST)</TD></TR><TR><TD>
lang</TD><TD>使用する言語辞書</TD></TR><TR><TD>
translate</TD><TD>カラム名を変換するかどうかのフラグ</TD></TR><TR><TD>
container</TD><TD>マスターコンテナを作成するかどうかのフラグ</TD></TR><TR><TD>
variable</TD><TD>リサイズボタンを作成するかどうかのフラグ</TD></TR><TR><TD>

<CAPTION>アクセス可能なインスタンス変数</CAPTION>
</TD></TR></TABLE></CENTER>
<P>
<CENTER><TABLE BORDER><TR><TD>
dict</TD><TD>GUI言語辞書</TD></TR><TR><TD>
compare</TD><TD>SQL比較関数辞書

<CAPTION>内部インスタンス変数</CAPTION>
</TD></TR></TABLE></CENTER>
<P>
<H3>インスタンスメソッド</H3>

<P>
<P>
<H3>公開インスタンスメソッド</H3>

<P>
<P>
<DL>
<P>
<DT><B>start()</B><DD><P> 
初期化関数。現時点では内容がありません。
<P>
<DT><B>form($base, $option, $class, $target)</B><DD><P>
<P>この関数は、SQLクエリー選択フォーム用にHTMLを生成して返します。
フォーム内の全ての変数は、<code>$base</code>というプレフィックスで始まり、
下線文字の後に数字のインデックス番号が付加されます。異なる base 文字を
使用することにより一つのページに複数の Sql_Query インスタンスを持つことができます。
<P>この関数は、クエリーを行うSQLテーブルのフィールド名を知る必要があります。
<code>$option</code>にこれらのフィールド名の配列
(<code>$translate</code>は空となります)もしくはフィールド名から
長い名前へのハッシュ(<code>$translate</code>は<code>on</code>に設定されます)
のいずれかを指定することが可能です。
<P><code>$class</code>にCSSクラス名が指定されている場合、
生成されるフォームの全てのタグはCSSスタイルシートクラスによってタグ付けされます。
<code>$class</code> はオプションであり、空の場合にはクラス属性は生成されません。
<code>$target</code>はSQLクエリーフォームのターゲットのURLです。
これはオプションであり、空の場合は自分自身を参照するフォームが生成されます（推奨）。
<P>この関数は、SQLクエリ選択フォームを描画するHTMLを有する文字列を返します。
<P>
<DT><B>where($base, $incr)</B><DD><P>
<P><code>form()</code> によって生成されたページが送信された際には、
多くのパラメータを評価し、ユーザーの選択に応じたSQLの<em>where</em>句の
検索条件に変換する必要があります。
<code>where()</code>関数はこれらの全ての面倒を見ます。
この関数は、<code>form()</code>をコールする際に使用したプレフィックス<code>$base</code>
を必要とします。
<P><code>$incr</code>パラメータはオプションであり、"More"もしくは"Fewer"ボタンが
使用された際に追加あるいは削除するクエリ条件の行数を定義します。デフォルト値は1です。
<P>この関数は、SQLクエリにおいて "where"句としてエラーなく使用された文字列を返します。
<P>
</DL>
<P>
<H3>内部インスタンスメソッド</H3>

<P>
<DL>
<DT><B>plain_where($base)</B><DD><P>
この関数は、<code>where()</code>の全ての動作を行いますが、クエリ条件ウィンドウの
サイズを変えません。
</DL>
<P>
<H3>例</H3>

<P>
<P><code>Sql_Query</code>クラスは直接使用することが可能です。
持続化するとより便利となりますので、<code>prepend.php</code>ファイル
の適当な場所に<code>require("sqlquery.inc")</code>を追加することを
お勧めします。
<P>検索結果を表示し整形する優れた方法についてはこの章のTableクラスを
参照下さい。データベースに接続する優れた方法については、DB_Sql クラス
(コアクラスの一つです)を参照下さい。
<P>以下のコードサンプルはかなり長いですが、
Sql_Query, DB_Sql,Tableクラスを用いてデータベースのテーブルにクエリを行う
完全に動作する例となっています。
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
&lt;?php
  // この例を動作させるためには、preprend.incでsqlquery.incと
  // table.incをrequire()することが必要!
  page_open(array("sess" => "Example_Session"));

  $db = new DB_Example;   // これはDB_Sqlのサブクラス
  $t  = new Table;        // 結果整形用
  $t->heading = "on";     // 見出しが必要だ
?>
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Testseite&lt;/title&gt;
&lt;style type="text/css"&gt;&lt;!--
h1          { font-family: arial, helvetica, sans-serif; color: #d33e30 }
table.test  { background-color: #eeeeee }
th.test     { font-family: arial, helvetica, sans-serif  }
td.test     { font-family: arial, helvetica, sans-serif }
table.query { background-color: #cccccc }
td.query    { font-face: arial, helvetica, sans-serif }
--&gt;&lt;/style&gt;
&lt;/head&gt;
&lt;body bgcolor="#ffffff"&gt;
&lt;h1&gt;Testpage&lt;/h1&gt;
&lt;?php
  // 以下のフィールドは選択可能
  $field = array(
    "username"   => "Login Name",
    "password"   => "Password",
    "perms"      => "Permissions"
  );

  // 最初にこのページを開いたときには、$q は存在しません
  if (!isset($q)) {
    $q = new Sql_Query;     // 以下のような問い合わせフォームを作る
    $q->conditions = 1;     // ... まず最初に単一の問い合わせ条件を持ち、
    $q->translate  = "on";  // ... 列名は変換され、
    $q->container  = "on";  // ... 見易いコンテナテーブルを持ち、
    $q->variable   = "on";  // ... 検索条件の個数は可変であり、
    $q->lang       = "en";  // ... 英語で、よろしく

    $sess->register("q");   // これを忘れちゃいけない！
  }

  // このページを二度目に開いたときは、$baseで指定した名前の配列が
  // 設定されており、$queryを作成する必要があります。 
  // $q が作成したSql_Query オブジェクトの場合、$baseを"q"に
  // 設定してはいけません... :-)
  if (isset($x)) {
    $query = $q->where("x", 1);
  }

  // どんな場合でもフォームを今表示しなければいけません。
  // ここでの"x"と$q->whereが一致していなければならないということに
  // 注意してください。CSS"query"クラスとして全要素にタグを付けます。
  printf($q->form("x", $field, "query"));
  printf("&lt;hr>");

  // 適正なクエリ文字列を有しているか？
  if ($query) {
    // 検索条件を表示する
    printf("Query Condition = %s&lt;br>\n", $query);

    // クエリ実行
    $db->query("select * from auth_user where ". $query);

    // 結果の出力 (CSS class test としてタグづけ)
    printf("Query Results = %s&lt;br>\n", $db->num_rows());
    $t->show_result($db, "test");
  }

  page_close();
?>
&lt;/body&gt;
&lt;/html&gt;
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<P>
<H2><A NAME="ss5.2">5.2 Table およびCSV_Table</A>
</H2>

<P>Tableクラスは2次元の連想配列データやデータベースクエリの結果を
テーブルとして整形する優れた方法です。
Tableとそのサブクラスに配列またはクエリ結果のいずれかを指定することにより、
全ての値を含むテーブルの正しいHTMLを出力することが可能となります。
Table はそれ自体に簡単なフィルタリング能力を持っており、サブクラス化しなくても
単独で使用可能です。Tableの全ての機能を利用するには、専用のサブクラスを作成する必要があります。
<P>checkオプションと同時に使用した際、テーブルはHTML要素<code>FORM</code>
の一部であると仮定されます。
それぞれの表の行の前に<code>input type=&quot;checkbox&quot;</code>を作成する
コードが生成されます。
このチェックボックスは行番号に対応する連番を持つ配列として構成されます。
その配列名は<code>check</code>インスタンス変数にセットされた内容が常に使われます。
<P>
表の各行を生成する際に、2種類のカラムフィルタのどちらか1つが使用されます。
<code>fields</code>インスタンス変数に値が指定されている場合、その配列中で
フィールド名がキーになっているカラムだけがその配列内の順番で出力されます。
つまり、<code>fields</code>インスタンス変数に<code>array("a", "c", "e")</code>を
指定した場合、<code>a</code>, <code>c</code>, <code>e</code>というカラムだけが
生成される表の要素になるということです。
<P>
<code>fields</code>に値を指定しない場合、全てのデータ列が<code>each()</code>で
走査され、<code>filter</code>中の正規表現に一致する名前の全てのカラムが表に表示されます。
デフォルトでは、この正規表現はアルファベットで始まり、残りが英数字または "_" (下線)
になっている全てのカラム名を通過させます。
これがデフォルトとして選ばれたのは、DB_Sqlデータベースクラスがデータベースからデータを
取得するために<code>mysql_fetch_array()</code>を内部的に用いており、この関数が
数値インデックスと本当のカラム名の両方の形式で2重に全てのカラムを返すからです。
デフォルトのフィルターは正しいカラム名で全てのデータを一度だけ表示させます。
<P>加えて、インスタンス変数<code>map_cols</code>によりカラム名の再マッピング
が可能です。<code>map_cols</code> に値が定義されている場合、見つかったカラム名を
新しい名前で置き換えます。
<P>すなわち、<code>fname</code>、<code>lname</code>、<code>mydate</code>というカラムを
持つテーブルを以下のコードを用いることにより<code>名前</code>, <code>姓</code>,
<code>日付</code>に対応させることができます。
(なお、ここで$tは初期化したTableクラスのオブジェクトです）
<P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
$t->map_cols = array("fname"  => "名前",
                     "lname"  => "姓",
                     "mydate" => "日付");
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
インスタンス変数<code>map_cols</code>は、これと同じテクニックを用いて異なる言語の名前に
カラムを対応づけることができます。
<P>
派生クラス用にインスタンス変数<code>add_extra</code>が追加されています。
この変数に値が指定されている場合、関数<code>table_heading_row_add_extra()</code>および
<code>table_row_add_extra()</code>がコールされます。Table クラスにおいてはこれらの関数
は何もしませんが、派生クラスでこれらの関数に必要とされるさらなる機能性を提供するよう
オーバーライドすることができます。すなわち、その行の<code>編集</code>、<code>削除</code>、
<code>詳細表示</code>機能を提供するハイパーリンクをこれらの関数に容易に追加することができ、
大幅なカスタマイズを行えます。
<P>
Tableのサブクラスの一つであるCSV_Tableは最小の努力であなたのデータをCSV形式で
生成することができるように提供されています。CSV(コンマ区切りのデータ)は、MySQLの
<code>LOAD DATA INFILE</code> 文でインポートしたり、多くの表計算ソフトのインポート機能に
よるインポートが可能です。
<P>Tableクラスは、現在モジュール化により高レベル、中レベル、低レベルの関数を提供しています。
プログラマーは、シンプルな高レベル関数を使うことや、複雑さの度合いに応じて中または
低レベルの関数のパワーを用いることができます。過去の互換性を維持するためのあらゆる努力を
していますが、Tableクラスを広範囲に使用するならば新しい関数に慣れ親しんでおくのもよい
考えです。通常、高レベルと中レベルのサポート関数は <code>show_</code>で始まりますが、
低レベル関数ではそうではありません。
<P>
<H3>インスタンス変数</H3>

<P>
<CENTER><TABLE BORDER><TR><TD>
classname<br>(クラス名)</TD>
	<TD>シリアル化ヘルパ: このクラスの名前</TD></TR><TR><TD>
check</TD>
	<TD>設定されている場合、チェックオプションが有効になります。</TD></TR><TR><TD>
filter</TD>
	<TD>表示するカラムを選択する正規表現。</TD></TR><TR><TD>
fields</TD>
	<TD>表示するカラム名のリスト。</TD></TR><TR><TD>
heading</TD>
	<TD>フラグ: 値が指定されている場合、見出しが生成されます。</TD></TR><TR><TD>
map_cols</TD>
	<TD>静的なカラム名を置換されるカラム名のリスト。</TD></TR><TR><TD>
add_extra</TD>
	<TD>フラグ: 値が指定されている場合、見出しと行用の拡張関数が呼ばれます。</TD></TR>
<CAPTION>アクセス可能なインスタンス変数</CAPTION>
</TABLE></CENTER>
<P>
<H3>インスタンス操作</H3>

<P>
<P>
<H3>高レベルインスタンスメソッド</H3>

<P>
<P>
<DL>
<P>
<DT><B>show($ary, $class = "")</B><DD><p> 
上で説明したフィルタリング則に基づき、2次元配列(またはハッシュ)<code>$ary</code>を
テーブルとして整形し表示します。<code>$class</code>に値が指定されていたら、
それぞれのHTML要素はそこで名前が指定されたクラスに属するものとしてタグが生成されます。
これはカスケーディング・スタイルシートを使用する場合に有用です。
<P>
<DT><B>show_page($ary, $start, $num, $class = "")</B><DD><P>
<code>show()</code>と同じですが、<code>start</code>を始点として<code>num</code>個の
要素だけが表示されます。
<DT><B>show_result($db, $class = "")</B><DD><P>
<code>$db</code> の結果セットを整形し表示します。<code>$db</code> は、クエリー
を発行した<code>DB_Sql</code>のサブクラスであることが想定されています。
<code>Table</code>は、<CODE>$db-&gt;next_record()</CODE>を繰り返しコールして
クエリーの結果セットから全ての結果を取得し、テーブル形式で出力します。
<P>
<DT><B>show_result_page($db, $start, $num, $class = "")</B><DD><P>
<code>show_result()</code>と同じですが、<code>start</code> を始点として<code>num</code>
個の要素だけを表示します。
<P>
</DL>
<P>
<H3>中レベルインスタンスメソッド</H3>

<P>
<P>
<DL>
<DT><B>show_table_rows($ary, $class="")</B><DD>
<P>指定した配列を走査し、データの各行をHTMLテーブルの行として表示します。
<P>
<DT><B>show_table_rows_result($db, $class="")</B><DD>
<P>指定したデータベースオブジェクトを走査し、各レコードをHTML テーブルの行として表示します。
<P>
<DT><B>show_table_page_rows($ary, $start, $num, $class="")</B><DD>
<P>指定した配列を走査し、データの各行をHTMLテーブル行として表示します。ただし、
<code>$start</code>要素まで表示を開始せず、<code>$num</code>行表示した後も表示しません。
<P>
<DT><B>show_table_page_rows_result($db, $start, $num, $class="")</B><DD>
<P>指定したデータベースオブジェクトを指定し、各レコードをHTMLテーブル行として表示します。
ただし、<code>$start</code>レコードまで表示を開始せず、<code>$num</code>個のレコードを
表示した後も表示しません。
<P>
<DT><B>show_table_heading_row($ary, $class="")</B><DD>
<P>HTMLヘッダー行を生成するために指定した配列を使います。
<P>
<DT><B>show_table_heading_row_result($db, $class="")</B><DD>
<P>HTMLヘッダー行を生成するために指定したデータベースオブジェクトを使います。
<P>
<DT><B>show_table_heading_cells($data, $class="")</B><DD>
<P>指定した配列を走査し、それぞれのアイテムをHTMLテーブルヘッダーセルの中で表示します。
<P>
<DT><B>show_table_cells($row, $row_key, $data, $class="")</B><DD>
<P>指定した配列を走査し、それぞれのアイテムをHTMLテーブルセルの中で表示します。
<P>
</DL>
<P>
<H3>低レベルインスタンスメソッド</H3>

<P>
<P>
<DL>
<DT><B>table_open($class = "")</B><DD>
<P>この関数は、<code>Table</code>のサブクラスでオーバーライドすることができます。
テーブル作成の一番最初で呼び出され、テーブルを開くためのHTMLを出力します。
(例えば<code>printf("&lt;table%s&gt;\n", $class?" class=$class":"");</code>)
<P>
<DT><B>table_close()</B><DD>
<P>この関数は、<code>Table</code> のサブクラスでオーバーライドすることができます。
テーブル作成の一番最後で呼び出され、テーブルを閉じるためのHTMLを出力します。
(例えば<code>printf("&lt;table&gt;\n");/</code>)
<P>
<DT><B>select_colnames($data)</B><DD>
<P>テーブルの列名のリストを生成するための内部ドライバ関数。
<P>
<DT><B>table_heading_row($data, $class = "")</B><DD>
<P>テーブルの先頭行を生成するための内部ドライバ関数。
<P>
<DT><B>table_heading_cell($col, $val, $class)</B><DD>
<P>この関数は、<code>Table</code>のサブクラスでオーバーライドすることができます。
テーブルの先頭セルが生成される度にコールされます。
<P><code>$col</code> は現在のカラム番号、<code>$val</code> はカラム名、<code>$class</code>
は生成される要素のためのHTML CSSクラスです。
<P>
<DT><B>table_heading_cell_open($class="")</B><DD>
<P>ヘッダーセルを開始します。
<P>
<DT><B>table_heading_cell_close($class="")</B><DD>
<P>ヘッダーセルを終了します。
<P>
<DT><B>table_heading_row_add_extra($data, $class="")</B><DD>
<P>派生クラスのための仮想関数です。この関数は全てのヘッダーセルが生成された後にコールされます。
この関数によりプログラマーはヘッダー行を閉じる前にHTMLコードを追加することができます。
<P>
<DT><B>table_row($data, $class = "")</B><DD>
<P>テーブルの行を生成するための内部的なドライバ関数です。
<P>
<DT><B>table_row_open($row, $data, $class = "")</B><DD>
<P>この関数は、<code>Table</code> のサブクラスでオーバーライドすることができます。
一番最初の行が生成されるときにコールされ、テーブルの行を開始するHTMLを出力します。
<P>
<code>$row</code>は現在の行番号です。<code>$data</code>はこの行のために列名/値の
ペアのハッシュであり、<code>$class</code> は生成する全ての要素のためのHTML CSSクラスです。
<P>
<DT><B>table_row_close()</B><DD>
<P>この関数は、<code>Table</code>のサブクラスでオーバーライドすることができます。
一番最後の行が生成されるときにコールされ、テーブルの行を閉じるHTMLを出力します。
<P>
<DT><B>table_cell($row, $cell, $key, $val, $class)</B><DD>
<P>この関数は、<code>Table</code>のサブクラスでオーバーライドすることができます。
テーブルのセルが生成されるたびにコールされます。
<P><code>$row</code>は現在の行番号、<code>$cell</code>は現在のセル番号、
<code>$key</code>は現在のカラム名、<code>$val</code>はセルの値、<code>$class</code>
は生成されているその要素のHTML CSSクラスです。
<P>
<DT><B>table_cell_open($class="")</B><DD>
<P>セルを開始します。
<P>
<DT><B>table_cell_close($class="")</B><DD>
<P>セルを終了します。
<P>
<DT><B>set_checkbox_heading($class="")</B><DD>
<P>この関数は、そのカラムのチェックボックスオプションと一致する空のヘッダーセルを生成します。
<P>
<DT><B>table_checkbox_cell($row, $row_key, $data, $class="")</B><DD>
<P>チェックボックスを表示するためのHTMLコードを出力します。この関数は、メンバー変数
<code>$check</code>に値が設定されているときに実行されます。<code>$check</code>には、
<code>$data</code>配列の中のあるキーがセットされている必要があります。
(例えば、<code>$data[&quot;myKey&quot;]</code>ならば<code>$check=&quot;myKey&quot;</code>
をセットします)
<P>
<DT><B>set_checkbox($row, $row_key, $data, $class="")</B><DD>
<P>インスタンス変数<code>$check</code>に値がセットされているときに限り、指定したデータを
基づきHTMLチェックボックスを生成します。
<P>
</DL>
<P>
<H3>例</H3>

<P>Tableはそれぞれのページで自動的にインクルードされたり事前に読み込まれたりされません。
Tableクラスを使うページでTableクラスをインクルードし、Tableのインスタンスを作成してください。
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
&lt;?php
  // Table のインクルード
  require("table.inc");
  
  // Table インスタンスの生成
  $t = new Table;
  
  // 表の見出しを出力する
  $t-&gt;heading = "on";
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>次に2次元配列を生成するかデータベースクエリーの準備をし、
それを表示する表を作成、出力します。
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
  // データベースオブジェクトを生成
  $db = new DB_Session;
  
  // $tab という2次元配列を生成
  $tab = $db->metadata("active_sessions");
  
  // その配列を表示
  $t-&gt;show($tab, "metadata");
  
  // データベース問い合わせを準備
  $db-&gt;query("select * from active_sessions");
  
  // 結果を表示
  $t-&gt;show_result($db, "data");
</PRE>
<HR>
</CODE></BLOCKQUOTE>

<P>
<H2><A NAME="ss5.3">5.3 Form</A>
</H2>

<P>Formクラス(しばしばOOH Formsと呼ばれます)はHTMLフォームを扱うための便利な
ライブラリです。内容の検証のためにJavascriptとサーバー側スクリプトを用いることができ、
カスタマイズおよび拡張が可能になっています。
<P>
<H3>OOH Formsの使用法</H3>

<P>OOH Formsライブラリは次の5つのファイルから成っています。<code>oohforms.inc, 
of_checkbox.inc, of_radio.inc, of_select.inc, of_text.inc, of_textarea.inc</code>
<code>oohforms.inc</code>は自動的に他のファイルをインクルードします。
使用するフォーム要素用にファイルを手動でインクルードするようにこれを修正することが
可能です。もしくは、複数のインクルードを行う余計な負荷を避けるために
<code>oohforms.inc</code>に要素ファイルの内容をカット＆ペーストしてもかまいません。
サイトにおける適切なファイル構成を決めることは、読者の課題として残されています。
しかし、ほとんどの目的において、<code>require("oohforms.inc")</code> で十分でしょう。
<P>
<P>一般的に oohforms を用いるページの構造は以下のようになっています。
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
require("oohforms.inc");         // ライブラリをインクルード

$f = new form;                   // フォームオブジェクトを生成

$f->add_element(...);     // フォーム要素を準備
$f->add_element(...);    
$f->add_element(...);    

if ($submitname)                 // 処理するデータはあるか？
  if ($err = $f->validate()) {   // データは適正か？
    echo $err;                   // 適正ではない; エラーを表示
    $f->load_defaults();  // 送信されたデータとともにフォームを読み出し
  else {
    /* Process data */           // データに問題なし; それについての仕事をする
  }

$f->start(...);                  // フォームの表示を開始
$f->show_element(...);    // 要素を表示
$f->show_element(...);
$f->show_element(...);
$->finish();                     // フォームの最後
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<P>明らかにこのテーマについては多くのバリエーションがありますが、これで基本的な部分を
カバーしています。各メソッドについては以下に文書化されています。
<P>
<DL>
<P>
<DT><B>start($jvsname,$method,$action, $target)</B><DD>
<P>開始タグ<code>&lt;form&gt;</code>を出力し、クラスで必要とされる初期状態を
セットアップします。全ての宣言はオプションですが、JavaScriptによる検査を可能に
するために少なくとも一つは使いたいと思います。<code>$jvsname</code>はフォーム
へのJavaScriptへのリンクを持つために使われる適当な文字列です。空(デフォルト)の場合、
JavaScript検査は提供されません。<code>$method</code>はフォームを送信するHTTPメソッドです。
デフォルトは<code>&quot;POST&quot;</code>です。<code>$action</code>はフォームを
送信するURLです。デフォルトは<code>$PHP_SELF</code>です。<code>$target</code>は
フォームの結果を表示するフレームのターゲットです。デフォルトは<code>_self</code>です。
<P>
<DT><B>finish($after,$before)</B><DD>
<P>フォームに追加されたhiddenフィールド、終了タグ<code>&lt;/form&gt;</code>、
そしてJavascript検査コードを出力します。<code>$after</code>及び<code>$before</code>
はともにオプションです。いずれかが空でない文字列であれば、フォーム送信前または後に、
フォーム送信時に走る追加のJavaScriptを出力します。宣言の順番は全く洗練されて
いないように見えるかもしれませんが、通常は打ちやすいと思います。
通常、あなたはJavascriptで何か高級なことをするために行われる検査が終わるまで待つでしょうから。
検査とは異なり、OOH Formsはここであなたが使っているJavascriptと同等の機能を
サーバー側で与える術を持ちません。
<P>
<DT><B>add_element($element)</B><DD>
<P><code>add_element</code>はある特定のフォーム要素の属性を定義し、それによって
他のクラスメソッドがそれを適切に用い操作することができるようにするために用いられます。
<code>add_element</code>は引数を1つだけ取ります。それは連想配列であり、
そのキーになる値のペアはフォーム要素の種類とその種々の属性を定義するために用いられます。
これらの属性のうちあるものはHTML属性に対応していますが、それ以外はoohforms
への機能付加を必要とします。それが受け取る属性と値の文法並びに構文は以下で文書化されています。
全ての型の要素が全ての属性を使うわけではないことに注意してください。
<P>
<DL>
<P>
<DT><B>type</B><DD>
<P>この要素の種類。<code>"submit"</code>, <code>"hidden"</code>, 
<code>"text"</code>, <code>"textarea"</code>, <code>"select"</code>, 
<code>"radio"</code>, <code>"checkbox"</code>, <code>"file"</code> のいずれかです。
<P>
<DT><B>name</B><DD>
<P>この要素の名前を示す文字列。この名前は他の操作への引数として用いられ、生成された
HTMLの中で<code>name=&quot;&quot;</code> として使われます。
(従ってPHPにおける変数名にもなります)配列値を持つ要素にしたい場合でも、名前に
<code>[]</code>を追加<b>しないでください</b>。<code>multiple</code>属性を
代わりに設定してください。
<P>
<DT><B>value</B><DD>
<P>このフォーム要素のデフォルト値です。フォーム要素の<code>multiple</code>属性に
値が設定されていたら、<code>value</code>は配列にすることができます。これが
<code>select</code>要素の場合、<code>value</code> は、文字表記
(<code>options</code>配列中の<code>label</code>)か、送信される値
(<code>options</code>配列中の<code>value</code>)のいずれかを参照することもできます。
<P>
<DT><B>multiple</B><DD>
<P>oohformsにこの要素が配列値であるとみなすよう通知するフラグです。このフラグは
<code>select</code>要素でよく利用されますが、<code>text</code>や<code>checkbox</code>
要素でも同様に用いることができます。このような要素をoohformsがどう扱うかについては、
<code>show_element</code>に関する記述を参照してください。
<P>
<DT><B>extrahtml</B><DD>
<P>開始タグに挿入される追加HTMLコードです。<code>select</code>
要素では、<code>option</code>タグではなく<code>select</code>タグに挿入されます。
<P>
<DT><B>size</B><DD>
<P><code>text</code>要素において、テキスト入力ボックスの文字数幅を指定するHTML size
属性に値をセットします。<code>select</code>要素においては、選択ボックスのサイズ
(一度に見ることができるオプション数)です。<code>select</code> 要素では
<code>size</code> が1にセットされている場合にのみ検査が実施されます。
これは、複数のオプションを一度に見ることができた場合には、<code>select</code>検査は
あまり意味がないからです。<code>file</code> 要素においては、アップロード可能な
ファイルサイズの最大値です。
<P>
<DT><B>pass</B><DD>
<P><code>text</code>要素のために値がセットされていたら、パスワード要素として、
すなわち入力内容がアスタリスク(*)として表示されるようHTML出力します。
<P>
<DT><B>src</B><DD>
<P><code>submit</code>要素のために値がセットされていたら、イメージ要素に変換され、
そのイメージのソースURLとして<code>src</code>の値が用いられます。
<P>
<DT><B>maxlength</B><DD>
<P><code>text</code>要素でmaxlength HTML属性としてそのまま使われます。
<P>
<DT><B>minlength</B><DD>
<P><code>length_e</code>に値がセットされていたら、これは<code>text</code>要素が
検査機構により許容される入力の最低限の長さを示します。
<P>
<DT><B>length_e</B><DD>
<P>値がセットされていたら、<code>text</code>要素が少なくとも<code>minlength</code>
個の文字をもっているかどうかが検査されます。<code>length_e</code>は検査に失敗した
ときにエラー文字列として用いられます。
<P>
<DT><B>valid_e</B><DD>
<P>値がセットされていたら、<code>text</code>, <code>radio</code>または
<code>select</code>要素で検査が実施されます。<code>text</code>要素においては、
検査は<code>valid_</code>正規表現に合致するかどうか検査されます。
<code>radio</code>要素は、グループ中の一つが選択されたかどうかを検査します。
<code>select</code> 検査は<code>multiple</code>に値がなく<code>size</code>が1
であるときにしか機能しません。検査はメニューのオプションの一番目を一種の案内
(例えば「アイテムを選択してください」)とみなして受け入れません。どの場合にも、
<code>valid_e</code> は検査に失敗したときに用いられるエラー文字列です。
<P>
<DT><B>valid_regex</B><DD>
<P><code>valid_e</code> に値がセットされていたら、テキストフィールドへの入力を
検査するために正規表現が用いられます。もし入力内容全体に一致する正規表現が
ほしいならば ^...$ を使わないといけない点に注意してください。
<P>
<DT><B>icase</B><DD>
<P>もし値がセットされていたら、正規表現で大文字小文字を無視します。
<P>
<DT><B>checked</B><DD>
<P><code>multiple</code>が使用されていない<code>checkbox</code>でのみ使用されます。
<code>checked</code>が設定されている場合、その要素はチェックされた状態で表示されます。
<P>
<DT><B>rows</B><DD>
<P><code>textarea</code>要素で<code>rows=</code>としてそのまま使われます。
<P>
<DT><B>cols</B><DD>
<P><code>textarea</code>要素で<code>cols=</code>としてそのまま使われます。
<P>
<DT><B>wrap</B><DD>
<P><code>textarea</code>要素で<code>wrap=</code>としてそのまま使われます。
<P>
<DT><B>options</B><DD>
<P><code>select</code>要素で表示されるオプションの配列です。配列の要素が単純な値
(文字列または数値)なら単純にそのとおりに表示され、その特定のオプションの値として
用いられます。
この要素は、それ自体<code>&quot;label&quot;</code>と<code>&quot;value&quot;</code>
をキーとする連想配列とすることも可能です。この場合、<code>&quot;label&quot;</code>
が表示され、<code>&quot;value&quot;</code>の値が送信に用いられます。
<P>
</DL>
<P>
<P>例:
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
$f->add_element(array("type"=>"text",
                             "name"=>"foo",
                             "valid_regex"=>"^[a-z]*$",
                             "valid_e"=>"文字のみ",
                             "icase"=>1,
                             "value"=>"bar"));
$f->add_element(array("type"=>"checkbox",
                             "name"=>"compress",
                             "multiple"=>1));
$f->add_element(array("type"=>"textarea",
                             "name"=>"comment",
                             "rows"=>6,
                             "cols"=>40,
                             "value"=>""));
$o = array(array("label"=>"以下から選択してください","value"=>0),
           array("label"=>"林檎","value"=>1),
           array("label"=>"オレンジ","value"=>2),
           array("label"=>"梨","value"=>3),
           array("label"=>"葡萄","value"=>4));
$f->add_element(array("type"=>"select",
                             "name"=>"menu",
                             "options"=>$o,
                             "size"=>1,
                             "valid_e"=>"果物を選択してください",
                             "value"=>"林檎"));
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<DT><B>show_element($name,$value)</B><DD>
<P><code>$name</code>で名前の指定されたフォーム要素を出力します。通常は2番目の引数は
使いません。<code>multiple</code>属性がセットされた<code>radio</code>と
<code>chekbox</code>要素では必須です。というのも、これらの多くは同じ名前をもつからです。
<code>submit</code>要素で送信ボタンにラベルを定義するためにも用いられます。
<code>value</code>属性は<code>submit</code>要素では使われません。配列値を取りうる
他の要素(とりわけ<code>text</code>要素)については、<code>show_element</code>を
複数回呼ぶことで逐次値が表示されます。
<P>
<DT><B>load_defaults($element_list)</B><DD>
<P>同じ名前をもつPHP変数の値をフォーム要素のデフォルト値としてセットします。
これは送信されたのと同じ値をフォームで再表示したいときに一般的に用いられます。
引数はオプションです。要素名の配列が指定された場合、これらの要素だけが影響を受けます。
<P>
<DT><B>validate($result,$element_list)</B><DD>
<P>フォーム送信内容を検査します。もし全ての要素が適正であれば<code>$result</code>を返し、
そうでなければ関係するエラーメッセージ(フォーム要素の <code>valid_e</code>か
<code>length_e</code>属性)を返します。<code>$result</code>は、<code>false</code>が
デフォルトです。2番目の引数もオプションです。これは検査する要素の名前をもつ配列です。
<P>
<DT><B>freeze($element_list)</B><DD>
<P>引数で指定した配列に含まれる名前を持つフォーム要素を凍結します。引数がなければ、
全ての要素を凍結します。凍結された要素は、フォームウィジェットではなく静的な
通常のHTMLとして表示されます。この静的表示には、凍結されていないバージョンの要素を
用いたのと同じ効果をシミュレートするための適切なhidden要素が伴っています。
<P>
</DL>
<P>
<H3>OOH Formsのカスタマイズ</H3>

<P>OOH Formsはオブジェクト指向に基づいているので、要素の型を定義するクラスを拡張する
ことで容易にカスタマイズできます。一般的に、派生クラスはコンストラクタを
持たねばならず、また<code>of_element</code>のself_*関数の好きなものをオーバーライド
してもよいです。既に存在する要素のソースは、上記作業を適切に行うための最良の文書ですが、
若干の注意すべき点を以下に示します。
<P>
<DL>
<P>
<DT><B>self_show($val,$which)</B><DD>
<P>凍結されていないこの要素のインスタンスを表示します。
<code>$val</code>は値が1つであれば、<code>show_element</code>の引数<code>$value</code>
です。<code>$which</code>は、値が配列となる要素においてインデックスとして用いられます。
この数は、この要素に関して<code>show_element</code>が以前にコールされた回数と
等しいです。この関数はhiddenタグ出力の個数を返さなければなりません。
<P>
<DT><B>self_show_frozen($val,$which)</B><DD>
<P>凍結されたこの要素のインスタンスを表示します。凍結した要素を表示するためのHTML
出力に加えて、この種類の凍結されていない要素を送信することの効果を
2重化するためにhiddenフィールド用のタグを出力する必要があります。この関数は
出力するhiddenタグの個数を返します。
<P>
<DT><B>self_validate($val)</B><DD>
<P>この要素の<code>$val</code>を検証します。適正であれば、<code>false</code>を返し、
そうでなければ関連するエラー文字列を返します。
<P>
<DT><B>self_print_js($ndx_array)</B><DD>
<P>この要素を検証するためのJavascriptコードを表示します。<code>$ndx_array</code>は、
Javascriptのform.element[]配列で用いられる検証の対象になる要素のインデックスをもった
配列です。これはその要素名を名前として持つ配列中の別の<code>[]</code>がJavascriptを
混乱させないために必要です。
<P>
<DT><B>self_load_defaults($val)</B><DD>
<P>この要素のデフォルト値を<code>$val</code>としてセットします。<code>$val</code>
を<code>$this-&gt;value</code>にコピーするだけという、この関数のデフォルトの定義で
必要な全てを満たしていますが、それ以外の何かをすることが必要な特別なケースがあるかも
しれません。例としてチェックボックス要素の実装を参照してください。
<P>
</DL>

<H2><A NAME="ss5.4">5.4 tpl_form</A>
</H2>

<P>
<code>tpl_form</code>クラスは、HTMLフォーム展開のための一般的な枠組みとして提供される
ことが意図されています。このクラスは<code>OOH Forms</code>ライブラリにかなり
依存しているために、関係する文書を読み、理解することが必要です。
<P>
中心になるアイデアは、実際にフォームをHTMLとして出力するために<code>OOH Forms</code>
に何らかのHTMLコードを混ぜたものをコールすることを可能にするような、
<code>tpl_form</code>のサブクラスによるブラックボックスを生成する点にあります。
アプリケーションはユーザーから何らかの入力を得るためにこのブラックボックスを
使うことが可能です。アプリケーションはユーザーの入力がどう扱われるかだけでなく、
入力データの適正さをどうやって検証するかについて知っている必要はなくなります。
というのも、内部メソッドがその面倒を見てくれるからです。
<P>
このアプローチは<code>OOH Forms</code>にとても似ています(私はそう思います)が、
それがより高いレベルで実現されているのです。<code>OOH Forms</code>要素は相互に
通信する手段がありませんし、データの一貫性について&quot;簡単な&quot;
確認しかできませんが、<code>tpl_form</code>では、複雑なデータ評価や処理のための
一連のインターフェースが追加されています。
<P>さらに、<code>get_default_values</code>と<code>set_default_values</code>メソッドは、
フィールド名と値を持つハッシュ配列を用いることで、フォーム変数(a BAD THING (tm))
のシリアル化について心配せずに、セッション間でユーザーの入力を維持する
ために用いることができます。
<P>
配列がアプリケーションでデータを共有するために用いられていることに注意してください。
これは一種の無駄ではないかと異議を申し立てるかもしれません。というのも、全ての
ユーザー入力データはグローバル変数か<code>HTTP_POST</code>または<code>HTTP_GET</code>
グローバルハッシュで見つけられるからです。これは正しいですし、一般的なケースでは
空の配列を保存したり取り出したりするだけでしょう。<code>values</code>変数は、
フォームの振る舞いがその前にユーザーの入力したデータに依存するような、非常に複雑な
データエントリの設定に使うことが意図されています。この場合、すべてのフォームが
共同して<code>values</code>ハッシュ配列に読み書きすれば、複数のHTMLページを渡り歩いて
ステップバイステップで最終的な結果を構築することができるようになります。
<P>
<H3>インスタンス変数</H3>

<P>
<P>
<CENTER><TABLE BORDER><TR>
<TD>classname</TD>
<TD>クラス名です。シリアル化、及びフォームを実際にHTML化することが必要なHTML/PHP
コードを含むテンプレートのファイル名を定義するために<code>display</code>中で用いられます。
</TD>
</TR>
<TR>
<TD>error</TD>
<TD><code>validate</code>及び<code>validate_input</code>操作で生成されたエラー
メッセージを保持します。
</TD>
</tr>
<tr>
<td>values<br>(値)</TD>
<TD>これは&quot;共有メモリエリア&quot;の1種です; フォームとアプリケーションの間で
用いられます。<code>init</code>メソッドの中で読み出され、<code>get_values</code>
メソッドの中で戻されます。
</TD></TR>
<TR>
<TD>form&thinsp;data<br>(フォームデータ)</TD>
<TD>(<code>Form</code>オブジェクトの)フォーム情報を保持します。</TD>
</TR>
<TR>
<TD>has&thinsp;defaults<br>(デフォルトあり)</TD>
<TD>フラグです。フォームのデフォルト値は<code>set_default_values</code>操作を
経由して渡されます。ユーザーはこれを置き換えるべきではありません。</TD>
</TR>
<CAPTION>内部インスタンス変数</CAPTION>
</TABLE></CENTER>
<P>
<H3>インスタンスメソッド</H3>

<P>
<P>
<H3>アクセス可能なインスタンスメソッド</H3>

<P>
<P>
<DL>
<DT><B>init($values)</B><DD>
<P>これはクラスのコンストラクタの1種です。$values は<code>get_values</code>メソッドにより
アプリケーションへ戻されるフォーム変数を格納する連想配列です。
<P>
<DT><B>get_default_values()</B><DD>
<P>フォームからユーザーが送信した全てのデータが入っている配列を返します。
この配列はあとで<code>set_defaults_values</code>へ渡されます。
<P>
<DT><B>set_default_values($fv)</B><DD>
<P><code>get_default_values</code>により返されるのと同じ配列からデフォルト値を復元します。
<P>
<DT><B>display()</B><DD>
<P>実際にフォームフィールドを表示します。この操作は派生クラスにより上書きしては
いけません。代わりにユーザーはこの派生クラスの名前が付いており、自動的にインクルードされる
&quot;.ihtml&quot; 拡張子を持つファイルを提供するべきです。
<P>
<DT><B>get_values()</B><DD>
<P>このメソッドはオーバーライドするべきではありません。アプリケーションとフォームの間の
中心的なインターフェースとして想定されています。
デザイナーのニーズを満たすフォームが適切に派生された後、アプリケーションは
<code>get_values</code>をコールし、配列を返します。
この配列は<CODE>init</CODE>に渡され、結局<CODE>process_input</CODE>メソッドにより
修正されます。ユーザの入力が不正の場合は<CODE>false</CODE>が返されます。
後者の場合は、アプリケーションは適切なデフォルト値を代入してユーザーにフォームを
(再)表示するために<code>display()</code>をコールする必要があります。
<P>
<DT><B>clear()</B><DD>
<P>&quot;デストラクタ&quot;の1種です。メモリーを多少解放する以外に
このメソッドをコールする必要性はありません。アプリケーションからコールされる
可能性がありますが、それ以外では実行されません。<code>true</code>を返します。
<P>
</DL>
<P>
<H3>内部インスタンスメソッド</H3>

<P>
<DL>
<DT><B>setup()</B><DD>
<P>全てのフィールド情報をもった<code>Form</code>オブジェクトを初期化します。
hiddenフィールド<code>form_name</code>が自動的にこのルーチンによって追加され、
ユーザーにより既に送信されているかどうかを確かめるために他のメソッドにより使われます。
派生クラスによりこれを上書きするべきでなく、代わりに<code>setup_fields</code>
を用いるべきです。<code>true</code> を返します。
<P>
<DT><B>setup_fields()</B><DD>
<P>要求を満たすフォームフィールド定義を提供するためにこのメソッドをオーバーライドして
ください。
<P>
<DT><B>validate()</B><DD>
<P>ユーザーの入力を検査します。この操作は派生クラスでオーバーライドするべきでは
ありません。<code>validate_input</code> をその代わりに参照してください。エラー発生時
には<code>false</code>を返し、関係する<code>error</code>変数に値をセットします。
<P>
<DT><B>validate_input()</B><DD>
<P>このメソッドは複雑な確認方法(例えば、フィールド1 == &quot;other;&quot; ならば
フィールド2は空ではいけないとか)を提供したい場合には、派生クラスでオーバーライトする
必要があります。エラーが発生した場合には<code>false</code>を返し、状況に応じた
エラーメッセージを<code>error</code>変数にセットする必要があります。
<P>
<DT><B>process()</B><DD>
<P>ユーザーデータを処理します。このメソッドは派生クラスでオーバーライドするべきでは
ありません。<code>process_input</code>及び<code>process_default</code>を代わりに
参照してください。成功したら<code>true</code>を返し、そうでなければ<code>false</code>
を返します。
<P>
<DT><B>process_input()</B><DD>
<P>このメソッドは派生クラスでオーバーライドするべきです。検査が終わったら実行されます。
フォームへ渡されるデータは<code>values</code>配列へ代入するために用いられることがあります。
<P>
<DT><B>process_default()</B><DD>
<P>このメソッドは派生クラスでオーバーライドすべきです。フォームの検査が失敗したか、
最初にフォームが表示される前に実行されます。もしデータが以前のアクション、占い、
ペンギンの飛行観察や他の物から抽出されたのであれば、フォーム表示を避けるべきです。
<P>
</DL>
<P>
<H3>例</H3>

<P>あなたは、彼女(アハ)の名前とe-mailアドレスを入力するフォームを持っているとしましょう。
あなたは、このe-mailアドレスが適正かどうかをチェックしたいと思っています。
そうでなければあなたの盲目的データセットアップは失われます。あ・・・ええと・・・
構文的にe-mailアドレスを検証する単純な正規表現は以下の例のコードで表現されています。
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
 $this-&gt;form_data-&gt;add_element(array(
  &quot;type&quot;=&gt;&quot;text&quot;,
  &quot;name&quot;=&gt;&quot;email&quot;,
  &quot;valid_e&quot;=&gt;&quot;Syntax error in E-Mail address.&quot;,
  &quot;valid_regex&quot;=&gt;&quot;^([-a-zA-Z0-9.]+@[-a-zA-Z0-9]+(\.[-a-zA-Z0-9]+)+)*$&quot;
 ));
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<P>
さて、この短いコードは役目を果たしますが、あなたの今日の気分はとってもイカレているので、
アドレスのホスト名の部分をDNSを使って検証したいと思いました。そこで、あなたは入力内容
の中のホスト名を取得し、適正なホスト名なら<code>true</code>、そうでないなら
<code>false</code>を返すコードをいっしょにおきます。
(ヒント: <a href=&quot;http://px.sklar.com/>PHP Code Exchange</a>で、
&quot;現在有効な&quot;電子メールの検証のプロシージャを見つけるべきです)
<P>
素晴らしいコードが書かれたため、アドレスをチェックできます。ユーザーがフォームに入力
した後、ユーザーの入力内容を解析し、構文エラーがないのでアプリケーションから
<code>mycheckhost</code>をコールする時になりました。
この関数がOKならばデータベースを更新し、そうでなければフォームにデフォルト値をロードし、
再び表示し、ページを閉じ、終了します。
<P>
<P>私は同じようなことを多くのフォームで行い、その中のいくつかは大変複雑な検証手順を
持っており、そして私は駄目で読みにくいコードを生産するのは非常に簡単なことに
気づきました。(そうです、私は、データ検証手順の中のロジックを変更しなければいけないとき
に実際に悟りました...)
<P>
<P><code>tpl_form</code>は、フォームを構築する強固なフレームワークを提供するもの
であり、全てのコードは自己包含的でメインのアプリケーションロジックから分離される
ようになります。あなたが気に入ればいいのですが。
<P>
<P>さて、コードをいくつか見てみましょう。まず最初に<code>tpl_form</code>のサブクラス
のクラス宣言です。
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
class myform extends tpl_form {
  var $classname = &quot;myform&quot;;
  
  function setup_fields() {
    $this-&gt;form_data-&gt;add_element(array(
     &quot;name&quot;=&gt;&quot;email&quot;,
     ..., // 省略された分は以前のコードを参照
    ));
    $this-&gt;form_data-&gt;add_element(array(
     &quot;name&quot;=&gt;&quot;submit&quot;,
     &quot;type&quot;=&gt;&quot;submit&quot;,
     &quot;value&quot;=&gt;&quot;submit&quot;
    ));
  }
  
  function validate_input() {
    global $email;
    list($uname, $hostname) = split(&quot;@&quot;, $email);
    if (! mycheckhost($hostname)) {
      $this-&gt;error = sprintf(&quot;ごめんなさい、%s は不明なホストです。やり直してください&quot;, $hostname);
      return false;
    }
    // 追加のチェックはここに...
    return true;
  }
}
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<P>フォームをHTML化するためにHTMLとPHPコードを含んだ<code>myform.ihtml</code>を
提供する必要があります。最小限の例を以下に示します。
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
&lt;html&gt;
&lt;body&gt;
&lt;?php
 $this-&gt;form_data-&gt;start_form($this-&gt;classname, &quot;POST&quot;, $sess-&gt;self_url(), &quot;&quot;);
 printf(&quot;%s&lt;br&gt;\n&quot;, $this-&gt;error);
 $this-&gt;form_data-&gt;show_element(&quot;email&quot;);
 printf(&quot;&lt;br&gt;\n&quot;);
 $this-&gt;form_data-&gt;show_element(&quot;submit&quot;);
 $this-&gt;form_data-&gt;finish();
?&gt;
&lt;/body&gt;
&lt;/html&gt;
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<P><code>tpl_form</code>クラスは完成し、あとは芸術家としてのちょっとした仕事を残すだけ
になりました... 8-)。真新しいクラスを用いるためにクラス定義コードをアプリケーションに
組み込み、それから...
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
$mf = new myform;
$mf-&gt;init(array()); // 現時点では、厳密に要求されていない
                    // が、推奨されている
if ($rv = $mf-&gt;getdata()) {
  $mf-&gt;clear(); // これは厳密に要求されているわけではないが、とにかくメモリーを
                // 少しでもフリーにすべきである...
  global $email;
  // あなたのデータを望むように処理
} else {
  $mf-&gt;display();
}
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<P>この大変小さな例が、少なくともすばやい設計とコード分割の観点から<code>tpl_form</code>
クラスの本当の力を理解する助けになることを願っています。
<P>
<H2><A NAME="ss5.5">5.5 Tree (ツリー表示)</A>
</H2>

<P>Treeクラスはディレクトリの階層構造やHTMLにおけるメニューの構造といった
ツリー構造を表現します。この構造は適切な深さをもったネストした配列の配列として
Treeに与えられなければなりません。
<P>
<P>Treeの理念は、ツリー構造はいくつもの数学的モデルで表現することができるという
点にあります。
あるモデルは、ネストした配列かポインタ構造のようなデータ構造で、それから多次元グラフ図を
出力するとか、ツリーのある枝を刈ったり完全な枝を挿入したりといったそれ以外の巧妙な処理が
できます。しかし、ツリーを、一次元の文字列か、一連の関数のコール
(数学的センスにかなり近いです)としてイメージすることも可能です。
<P>
<P>ツリー構造からHTMLコードを生成するためには、このようにします。
ブラウザに何をするかを教える、1次元の文字列を最終的に必要とします。Treeクラスは
以下の方法でこの文字列を生成する手助けをします。すなわち、ツリー全体を一巡し、
通った各ステージにおいて複数の関数をコールするという方法です。
この関数を変更するのは作成者の仕事なので、素晴らしいレイアウトを作成されることでしょう。
<P>
<P>
<H3>インスタンス変数</H3>

<P>
<P>
<CENTER><TABLE BORDER><TR><TD>
classname<br>(クラス名)</TD>
	<TD>シリアル化ヘルパ: クラスの名前</TD></TR><TR><TD>
delimiter<br>(区切り)</TD>
	<TD>&quot;path&quot; を短縮した文字</TD></TR><TR><TD>
tree<br>(木)</TD>
	<TD>配列の配列の配列</TD></TR><TR><TD>
outp</TD>
	<TD>「出力内容」そのもの</TD></TR><TR><TD>
prfx, sufx, flag</TD>
	<TD>内部用 - outp を生成するいくつかの補助

<CAPTION>アクセス可能なインスタンス変数</CAPTION>
</TD></TR></TABLE></CENTER>
<P>
<H3>インスタンスメソッド</H3>

<P>
<P>
<H3>アクセス可能なインスタンスメソッド</H3>

<P>
<P>
<DL>
<DT><B>build_tree()</B><DD><P>
この関数は完全にユーザー主導です！以下に記述した構造をもった配列を生成しなければ
なりません。詳細は例を見てください。
<P><code>build_tree()</code> によってコールされる独自の関数を生成することに臆病に
ならないでください。例えば、再帰的コール。
<P>
<DT><B>go_trough_tree($key="",$path="",$depth=0,$lcount=0,$pcount=0)</B><DD><P>
<P>これはこのクラスの中でも最も重要な関数です。適正なパラメータが与えられたら、
正しい順序で出力関数を呼び出します。
<P>全ての変数はオプションです。現在サポートされていませんが、もし部分木を表示したい
のであれば、これらパラメータは有益かもしれません。
<P>
<DT><B>path_to_index (&amp;$path,$key="")</B><DD>
<P>この関数はほとんどの場合内部的に用いられますが、<code>$this-&gt;tree</code>
を生成するときに有益かもしれません。この関数は、パスからPHP3の連想配列の
インデックス文字列を生成します。そのパスは文字列ですが、
<code>$this-&gt;delimiter</code>によって区切られた文字列です。<code>$key</code>が
指定された場合には<code>$path</code>に追加されます。
(空のパスかそういったものを考えてください)
<P>
<P>例:
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
  $t->delimiter="/";
  $path= "usr/local/lib";
  ## $pathは変数として与えられなければならない、なぜなら参照によってコールされるから！
  $bla = $t->path_to_index($path,"etc");

  ## ここで、$pathは"usr/local/lib/etc"です
  ## ここで、$blaは["usr"]["local"]["lib"]["etc"]です
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<DT><B>path_to_parent (&amp;$path)</B><DD>
<P>この関数は内部では使われませんが、ツリー表示を出力するときに有益かもしれません。
これはパスのある深さから1段取り除きます。
<P>例:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
  $t->delimiter="/";
  $path= "usr/local/lib";
  $bla = $t->path_to_parent($path);

  ## $path は、"usr/local"です
  ## $bla は、["usr"]["local"]です
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<P>
<DT><B>path_add ($path,$key)</B><DD>
<P>この関数は、<code>path_to_index</code>の「参照でコールされないバージョン」です。
この関数は、$keyをパスに追加して返します。
<P>
<DT><B>path_sub ($path)</B><DD>
<P>この関数は、<code>path_to_parent</code>の「参照でコールされないバージョン」です。
この関数は、パスの親を見つけ、それを返します。
<P>
<DT><B>path_index ($path)</B><DD>
<P>この関数は <code>path_to_index()</code> の「参照でコールされないバージョン」です。
これはパスにより記述されたツリーへの連想キーを返します。
<P>
<DT><B>starttree ()</B><DD>
<P>この関数はツリー表示の出力の開始時に<code>go_through_tree()</code>によりコールされます。
<P>全ての<code>*tree</code>-関数は<code>go_trough_tree()</code>によりコールされますが、
素晴らしいレイアウトを提供するためにあなたに順番が回ってきます。
私はこれを用いてほぼあらゆる種類のツリーのレイアウトを生成することが可能であると
考えています。変数を見てください。例えば、<code>$depth</code>は他の方式であらゆる
&quot;level&quot;を扱うことが可能になります。
<P>
<DT><B>growtree ($key,$value,$path,$depth,$count,$pcount)</B><DD>
<P>この関数はツリー表示の出力の開始時に<code>go_trough_tree()</code>によりコールされます。
<P><code>go_trough_tree()</code>がそれ自身を再帰的に呼び出すたびに毎回コールされます。
これは、現在の要素がそれ以下の要素を持つ時、とも言えます。
<P>
<DT><B>leaftree ($key,$value,$path,$depth,$count,$pcount)</B><DD>
<P>この関数は、現在の要素がそれ以下の要素を<em>持たない</em>ときにコールされます。
<P>
<DT><B>shrinktree ($key,$depth)</B><DD>
<P>この関数は、<code>growtree()</code>の&quot;反対&quot;です。現在の要素がこの
サブリストでの最後の要素であるときに、いつもコールされます。
<P>
<DT><B>endtree()</B><DD>
<P>ツリーを離れるときに呼ばれます。
<P>
<P>
</DL>
<P>
<H3>Treeの配列</H3>

<P>上述のように<code>go_trough_tree()</code>をコールする前にまず<code>$tree</code>
を生成しておかないといけません。
<P><code>$tree</code> は適当な深さを持ったネストした一連の配列です。以下がその例です。
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
$t= new Tree;
$t->tree = array(
                "usr" => array(
                  0       => "許可",
                  "lib"   => "禁止",
                  "local" => "許可",
                  "bin"   => "禁止",
                  "etc"   => array(
                     0       => "許可",
                    "hosts"  => "禁止",
                    "mailcap"=> "許可"
                  ),
                  "var"   => "許可",
                  "tmp"   => "許可"
                ),
                "root" =>"禁止"
              );
$t->go_through_tree();
print $t->outp;
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>これは完全に再帰的な構造です。関数の再帰的コールによりこれを作成する
方法は明らかだと思います。明らかでないならば、以下の例を参照下さい。
<P>
<P>ある小さな奇妙な点について説明が必要です。というのも、これは少々混乱を招くからです。
0(ゼロ)という名前の配列は親の要素の値として用いられます。例で示したように、子供
(例えば"etc")を持つ要素は属性("許可"など)を持つことができません。その代わり、
この要素の値は0という名前をもつ擬似的な子供の中に格納されます。この要素が存在しない場合、
値"Array"(おそらく変更が必要なもの)を持つでしょう。
<P>
<P>この例の出力結果は、出力関数を変更していない場合は、以下のようになります。
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
/
^---- usr->'許可' : 'usr' (1) [1/2]
|    ^---- lib->'禁止' : 'usr^lib' (2) [2/7]
|    O---- local->'許可' : 'usr^local' (2) [3/7]
|    O---- bin->'禁止' : 'usr^bin' (2) [4/7]
|    O---- etc->'許可' : 'usr^etc' (2) [5/7]
|    |    ^---- hosts->'禁止' : 'usr^etc^hosts' (3) [2/3]
|    |     \--- mailcap->'許可' : 'usr^etc^mailcap' (3) [3/3]
|    O---- var->'許可' : 'usr^var' (2) [6/7]
|     \--- tmp->'許可' : 'usr^tmp' (2) [7/7]
 \--- root->'禁止' : 'root' (1) [2/2]
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>少し分かりにくいですね。左から右にかけてのフィールドは、それぞれ以下のように
なっています。
<UL>
<LI>現在のフィールドの<EM>インデックス名</EM></LI>
<LI>このフィールドの<EM>値</EM></LI>
<LI>このフィールドへの<EM>完全なパス</EM> (<CODE>path_to_*</CODE>-関数を参照)</LI>
<LI>現在の<EM>深さ</EM>または<EM>レベル</EM></LI>
<LI>現在の<EM>要素番号</EM>。なぜこれがこの例で "2" から始まっているのかを理解したかったら、以下をご覧ください。</LI>
<LI>この深さの部分木の<EM>要素の個数</EM></LI>
</UL>
<P>
<P>
<H3>例</H3>

<P>
<P>この例はハードディスクのディレクトリ構造を一巡します。
<P>
<P>以下のコードでそれを読むことができます。
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
class dir_Tree extends Tree {
     var $classname = "dir_Tree";
     var $delimiter="/";

     var $tdat;

     function build_tree ($path=".") {
         $this->tree=$this->recurs_dir($path,0);
     }

     ## この例のコードは、私のシステム (P200, 64MB) ではおよそ 20 秒で
     ## 多くのサブディレクトリを持つ 1000 のディレクトリエントリを読んで
     ## 出力できます。最大で 4 の深さを持つ 220 のエントリを 2 秒で読みます。
     ## OK ですね。

     function recurs_dir ($path,$depth) {
     GLOBAL $flap_out;
         $d=opendir($path);

         while ( $name=readdir($d) ) {
             $pathname=$path . $this->delimiter . $name;
             if (is_dir($pathname) &amp;&amp; !ereg("\.\.?",$pathname)) {
                 if (isset($flap_out[$pathname])) {
                     $array[$name]=$this->recurs_dir($pathname,$depth+1);
                 }
                 # 注意: 配列[0]を埋めるのは、配列の残りの部分の後
		 #       にすることが重要です! 
                 $array[$name][0]=$pathname;
             } else {
                 $array[$name]=$pathname;
             }
         }
         closedir($d);
         return($array);

     }

     #################################################
     ## INとOUTを切り替えます
     ## これは見せるべき全てのサブパスを含む配列を
     ## 生成するために使います
     ## 

     function flapping ($path) {
     GLOBAL $flap_out;
         if ($path) {
             if (is_dir($path)) {
                 if (isset($flap_out[$path])) {
                     unset($flap_out[$path]);
                 } else {
                     $flap_out[$path]=$name;
                 }
             }
         }
     }
}

$t= new dir_Tree;
## $valはGETメソッドにより指定されます。*tree-関数を参照。
$t->flapping($val); 
$t->build_tree();
$t->go_through_tree();
print $t->outp;
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
このコードでは、ツリーの要素全体でinとoutを切り替えやすくしています。
GET メソッド経由でパスを送信し、このパスを<code>flapping()</code>に渡しています。
<code>$flap_out</code>-配列全体は(例えば<em>session</em>により)永続化する必要があります。
おそらく、あなたは、$flap_outを見てパスが既に存在するかどうかを調べるガーベージ
コレクションをプログラムするでしょうか？

<P>
<H3>既知のバグとヒント</H3>

<P>既知のバグが一つあります。サブパスの名前が<code>$delimiter</code>文字列を
含んでいる場合です。これを適切に解決するのは無理であり、ツリーを生成するときに
注意しなければなりません。
<P>同じことがサブ配列の値[0]にもあてはまります。この要素は常に親要素として扱われます。
<P役に立つヒント: ツリーを再帰的に構築するときに、再帰的呼び出しによってサブツリーが
返された<em>後で</em>[0]-索引に値を代入する必要があります。
私が何を言っているかは上の例を参照してください。これはPHP3に特有だと思います。
<P>また全ての名前を連想インデックスフィールドに挿入しない(制御コードなど)ことも
可能ですが、これはテストしていません。
<P>
<H2><A NAME="ss5.6">5.6 STRINGS2 関数集</A>
</H2>

<P>これは私が頻繁に用いた一連の関数です。
<P>これらは単純なので、私は説明することを止め、単純にコードを挿入することにしました。
おそらくこれの次のリビジョンでは私はもっとまともな説明で置き換えるつもりです。
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
&lt;?php
##
## Strings2-関数集
##
## Copyright (c) 1998,1999 Alex 'SSilk' Aulbach
##
## これらの関数はとても実用的であり、もし私がもっと C で
## プログラムを書けたら PHP3 に直接組み込んだでしょう。
## でもできませんでした... :-}
##


##
## あなたはこんな文に恐れおののいたことはありませんか？
##    echo ($faxnumber) ? sprintf("Fax: %s",$faxnumber) : "";
##
## これは上記のような文を次の文で置き換え、あなたの手助けをします
##    p_iftrue($faxnumber,"Fax: %s");
## これで入力すべき文字は半分になり、より明晰に見え、もし $faxnumber が
## 未定義の場合に起きるエラーを解決します。
##
function o_iftrue ($val,$str) {
        if (isset($val) &amp;&amp; $val) {
                return(sprintf($str,$val));
        }
}
function p_iftrue ($val,$str) {
        print o_iftrue($val,$str);
}

##
## 「一つまたはそれ以上」を出力
##
## この関数は、もし個数によって出力を変えたいときに便利です。
##  例)   o_1or2($q->num_rows(),
##               "一致するレコードは一つでした",
##               "%s 個のレコードが見つかりました");
## は、もし num_rows() が 1 ならば「一致するレコードは一つでした」
##                        200 ならば「200 個のレコードが見つかりました」
## を出力します。
##
## もし $val が空か "" であれば空白文字列が返されます!
##
function o_1or2 ($val,$str1,$str2) {
        if (isset($val) &amp;&amp; $val) {
                if (1==$val) {
                        return(sprintf($str1,$val));
                } else {
                        return(sprintf($str2,$val));
                }
        } else {
                return(false);
        }
}
function p_1or2 ($val,$str1,$str2) {
        print o_1or2 ($val,$str1,$str2);
}


##
## これは、$valがfalseの場合に何かを出力したい場合です。例えば、
##
## p_0or1($faxnumber,"FAX 番号がありません", "Fax 番号: %s");
## 
function o_0or1 ($val,$str1,$str2) {
        if (empty($val) || !$val) {
                if (isset($val)) {
                        return(sprintf($str1,$val));
                } else {
                        return($str1);
                }
        } else {
                return(sprintf($str2,$val));
        }
}
function p_0or1 ($val,$str1,$str2) {
        print o_0or1 ($val,$str1,$str2);
}

##
## %nbsp; による全ての空白文字列を置き換えます
## この関数はブラウザがあなたの行を破壊することを好まず、非常に互換性のある
## 代替品として<NOBR>タグを代わりに用いるときに用います。
##
## &nbsp; はISO-Latin-1でのコード番号160を持つ本当の空白で
## 置き換えることができます
##
function o_nonbsp ($val) {
        return(ereg_replace("[[:blank:]\n\r]","&nbsp;",$val));
}
function p_nonbsp ($val) {
        print o_nonbsp($val);
}
?>
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<P>
<P>
<HR>
<A HREF="documentation-6.html">次へ</A>
<A HREF="documentation-4.html">前へ</A>
<A HREF="documentation.html#toc5">目次</A>
</BODY>
</HTML>
