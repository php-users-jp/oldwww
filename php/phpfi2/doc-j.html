<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<!--
Documentation is like sex: when it is good, it is very, very good; and
when it is bad, it is better than nothing.
                ++ Dick Brandon 
-->

<HEAD>
<TITLE>PHP/FI Version 2.0</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<H1 ALIGN="CENTER">PHP/FI 2.0 版</H1>
<H1>目次</H1>
<OL>
	<LI><A HREF="#history">はじめに</A>
	<LI><A HREF="#install">インストールの手順</A>
	<LI><A HREF="#starting">PHP/FIで何ができるか?</A>
	<LI><A HREF="#redirect">CGIリダイレクション</A>
	<LI><A HREF="#security">セキュリティについて</A>
 	<LI><A HREF="#safemode">セーフモード</A>
 	<LI><A HREF="#commandline">コマンドラインからの PHP/FI 実行</A>
	<LI><A HREF="#http_auth">HTTP 認証</A>
	<LI><A HREF="#requestvars">Apache リクエスト変数</A>
	<LI><A HREF="#module">Apache モジュール</A>
	<LI><A HREF="#directives">Apache モジュールの設定</A>
	<LI><A HREF="#fastcgi">FastCGI サポート</A>
	<LI><A HREF="#access">アクセス制御</A>
	<LI><A HREF="#logging">アクセス情報の記録</A>
	<LI><A HREF="#relative">相対URLと絶対URL、なぜイメージファイルが表示されないのか</A>
	<LI><A HREF="#getpost">PHP/FI における GET と POST データの処理法</A>
<UL>
	<LI><A HREF="#selmul"><TT>複数選択</TT> と PHP</A>
	<LI><A HREF="#imagecoord"><TT>イメージボタンによる投稿</TT> と PHP</A>
</UL>
	<LI><A HREF="#gd_support">PHP における GD (GIF画像作成用ライブラリ) サポート</A>
	<LI><A HREF="#virtual_hosts">PHP/FI と仮想ホスト</A>
	<LI><A HREF="#upload">ファイルアップロード</A>
	<LI><A HREF="#cookies">クッキー(Cookie)のサポート</A>
	<LI><A HREF="#msql_support">mSQL サポート</A>
	<LI><A HREF="#pg95_support">Postgres95/PostgreSQL サポート</A>
 	<LI><A HREF="#mysql_support">mysql サポート</A>
 	<LI><A HREF="#solid_support">Solid サポート</A>
 	<LI><A HREF="#sybase_support">Sybase サポート</A>
 	<LI><A HREF="#oracle_support">Oracle サポート</A>
 	<LI><A HREF="#illustra_support">Illustra サポート</A>
 	<LI><A HREF="#adabas_support">Adabas サポート</A>	    
	<LI><A HREF="#regexp">正規表現</A>
	<LI><A HREF="#escapes">エスケープキャラクター</A>
	<LI><A HREF="#octal">UNIX ファイル許可属性の8進数表記</A>	    
	<LI><A HREF="#script">PHP/FI スクリプト言語</A>
<UL>
	<LI><A HREF="#syntax">構文</A>
	<LI><A HREF="#vars">変数</A>
	<LI><A HREF="#assoc">連想配列</A>
	<LI><A HREF="#varvars">可変変数</A>
	<LI><A HREF="#lang">言語構造</A>
	<LI><A HREF="#user_funcs">ユーザー定義関数</A>
	<LI><A HREF="#scope">変数の範囲</A>
	<LI><A HREF="#math">数学的表現</A>
	<LI><A HREF="#while">While ループ</A>
	<LI><A HREF="#switch">Switch 構造</A>
	<LI><A HREF="#secure">安全な変数 - GET メソッドにおけるハッキング防止</A>
	<LI><A HREF="#overload">演算子のオーバーロードと変数の型の扱い</A>
	<LI><A HREF="#quiet">関数呼び出しのエラー抑制</A>
	<LI><A HREF="#funcs">内部関数</A>
</UL>
	<LI><A HREF="#addfunc">自作の内部関数を PHP/FI に加える方法</A>
	<LI><A HREF="#hacknotes">ソースコード改造について</A>
</OL>

<HR>
<H2><A NAME="history">はじめに</A></H2>
<P>
PHP は Perl で書かれた小さな CGI ラッパーであった。
私は自分のレジュメを読んだ人からアイデアを得るための簡便なツール
が必要だったので、ある日の午後、このプログラムを作った。
この頃、私個人の使用以外は考えていなかった。
私がレジュメを置いていたWebサーバーは極端に過負荷で、
常にプロセスをフォークするという問題を抱えていた。
私は、Perl ラッパーを C で書き直し、自分のレジュメがアクセスされる度に
Perl プロセスがフォークされることによる著しい無駄を
取り除こうとした。
<P>
しだいに私のラッパーを知った同じ Web サーバのユーザーから、
これを使わせてくれないか、と尋ねられるようになった。
それから、当然のように彼らはより多くの機能を望みはじめた。
私は多くの機能を付加し、その後ドキュメントとメーリングリストとFAQ
付でベータ版配布をはじめた。
このパッケージの最初の名前は
「Personal Home Page Tools」で、後に
「Personal Home Page Construction Kit」
となった。
<P>
同じ頃、私はデータベースで遊ぶようになり、
 SQL クエリーを容易に web ページ中に埋め込める
ツールを書いた。
これは、根本的に別のCGIラッパーで、
SQLクエリーを処理し、それらのクエリーに基づいて容易にフォームと
テーブルを作ることができた。
このツールは、FI (Form Interpreter) と名付けられた。
<P>

PHP/FI バージョン 2.0 は、これら２つのパッケージを組み合わせて
１つのプログラムにすることにより、完全に書き直されたものである。
今や、HTML ファイル埋め込み型の簡単なプログラム言語を持つまでに
進化した。
元の頭字語である PHP は過去のものとなった。
この単語は、もはや適当ではない。
PHP/FI は、個人のホームページ(Personal Home Page) 
での使用に留まらず、多くの web サーバーで使われるようになった。
なんといっても、HTML ファイルに直接簡単なスクリプトを置くこのが
可能になったおかげで、数多くの小さな Perl CGI プログラムを書く必要が
なくなったのである。
これにより、
Perl プロセスを何回もフォークすることによる負荷がなくなるため、
あなたの web ページを見る際の総合的な速度が向上する。
また、一つの html ファイルの中にすべての web ページの構成要素を
置くことにより管理が簡単になる。
いくつかのデータベースのサポートの付加により、
データベース機能を有する web ページの開発がとても簡単に
なった。
埋め込み型の方が、CGI と HTML 分割して作ろうとするよりもはるかに
処理が容易であることに多くの人が気づいたのである。<P>

<P>
PHP 3.0版は、更に別途書き直されたものである。
PHP を今から始めようとする場合には、2.0版よりも 3,0版で始める
ことを推奨する。
PHP3 は PHP/FI 2.0 に短期間で更新されるであろうし、開発の労力は
現在 PHP3 に集中しているからである。 
PHP/FI 2.0 に残るすべてのバグも単純なもの以外は修正される予定は
ない。
PHP3 に関する詳細な情報は、
<a href="http://www.lerdorf.on.ca/php3/">http://www.lerdorf.on.ca/php3</a>
で得ることができる。

<P>
このドキュメントにおいて、PHP,FI あるいは PHP/FI  といった
表現を用いているが、これらが指しているのは同じものである。
PHP と FI の違いは、コンセプトの違いによるものだけである。
両者は、同じ配布ソースからつくられる。
アクセスログ機能あるいはアクセス制限機能のサポートを外して
実行ファイルを作った場合には、FI バイナリと呼ぶ。
また、これらのオプション付で作成した場合には、PHPと呼ぶ。
<P>

<HR>
<H2><A NAME="install">インストールの手順</A></H2>

<DL>
<DT><FONT SIZE="+1">はじめる前に</FONT>

<DD><P>
    もし、あなたにUNIXの経験が全くない場合には、このインストール際に
    UNIXに関するちょっとした知識を周りの誰かに聞きたいと
    思うかもしれない。
    すべての手順は可能な限りシンプルに構成されているが、
    このソフトウエアは多くの要素により構成されているので、
    全てのシステムにおいてスムーズに進行すると考えるのは
    現実的ではない。
    あなたは、インストールするシステムの特徴を知る周りの誰かを
    必要とするかもしれない。
<P></DD>

<DT><FONT SIZE="+1">インストール前に知るべきこと</FONT>

<DD><P> インストールするサーバーは、post と get を用いた CGI プログラム
動かすことができるか?<BR>
<EM>これは、Apache モジュール版をインストールする場合には関係ない。</EM>

  そうでない場合には、このパッケージを使用することはできない。
  多くのプロバイダでは、CGI プログラムは許可されないか、極端に制限
  されている。自分のシステムがそうである場合には、
  システム管理者と話して、このパッケージを見せ、
  自分のためにインストールしてくれるかどうかを調べること。
<P></DD>

<DD><P> mSQL がシステムにインストールされている場合には、
    インストールされている場所を知っている必要がある。
<P></DD>

<DD><P>Postgres95 または PostgreSQL がシステムにインストールされている
場合には、インストールされている場所を知っている必要がある。
<P></DD>

<DD><P>
    もし、ログの保存やアクセス設定ファイルをNFSマウントされたディレクトリに
    置こうとする際に、システムがNFSファイルロック機能を有しない
    場合には、src/Makefile 中の NFS_HACK 変数を定義し、
    少し修正した gdbm ライブラリを用いなければならないであろう。
    詳しくは、doc ディレクトリの中の <STRONG>nfs_hack.txt</STRONG>
    を参照のこと。
<P></DD>

<DD><P>
もし、あなたがPHPを使って自分のページのアクセス状況をモニタすることに
    関心がない場合には、このオプションを実行ファイルに組み込まないこと。
    また、アクセス制限機能も外した方が良いかもしれない。
    これらのオプションを組み込むことは、著しいシステム負荷の増大を招く。
<P></DD>

<DD><P>もし、Apache モジュール版をインストールする場合には、
    Apache のソースコードのディレクトリを知っている必要がある。
    <P></DD>

<DT><FONT SIZE="+1">インストール手順</FONT>

<DD>
<P><EM><STRONG>手順 1.</STRONG></EM>
<P>
<P>
  まず、インストールプログラムを走らせる。: <TT>./install</TT>
<P>
<P>
  いくつかの質問をされる。もし、どんなこと聞かれているかが
    わからない場合には、単にリターンキーを押すこと。
    デフォルトの選択支はほとんどのシステムで安全である。
    しかし、設定ファイルとログファイルを置くディレクトリ
    についての質問に関して、このことはあてはまらない。
    httpd (通常は nobody)が書き込み許可を有するディレクトリ
    を選ぶこと。
    このディレクトリを以下のコマンドで簡単に作成することができる。<P>
<STRONG><TT>chown nobody directory</TT></STRONG>.<P>
    
<P>
<EM><STRONG>手順 2.</STRONG></EM><P>
<P>
   src ディレクトリに移る。: <TT>cd src</TT><P>
   php.h ファイルを見ることを推奨する。多くのコンパイル時オプション
   をここでセットすることができる。
<P>
<EM><STRONG>手順 3.</STRONG></EM><P>
<P>
  以下を入力する。: <TT>make</TT>
<P>
<P>
  このコマンドにより、実行ファイル <EM>php.cgi</EM> がデフォルトで
    作成される。もし、Apache モジュール版をインストールする場合には、
    <EM> libphp.a </EM> が作成される。
<P>

<P>
<EM><STRONG>手順 4. (Apache モジュール版で <STRONG>ない</STRONG>
    場合)</STRONG></EM><P>

<P>
   実行ファイル <STRONG>php.cgi</STRONG> を自分のシステムの
    cgi-bin ディレクトリにコピーする。
    もし、このディレクトリに書き込む権利がなく、自分のディレクトリに
    インストールしたい場合には、そうすることができる。
    しかし、次のコマンドにより、実行ファイルの setuid ビットを
    オンにしなければならない。:<p>
    <TT>chmod u+s /path/php.cgi</TT><P>
<P>
  もし、実行ファイルの setuid ビットをオンにしない場合には、
    この実行ファイルにより作成されたファイルは全てそのユーザーの
    ID により所有される。もし、このことが受け入れられるならば、
    setuid ビットを安心してオフにすることができる。
<P>

<P>
<EM><STRONG>手順 4. (Apache モジュール版をインストールする場合)
</STRONG></EM><BR>

Apache ソースディレクトリに移動する。
ここには、<EM>mod_php.c</EM> と <EM>mod_php.h</EM>
がコピーされていなければならない。
書き込み許可の問題でこれらのファイルが書き込まれなった場合には、
2つのファイルを手動でそこにコピーする必要がある。
Configuration ファイルを編集し、EXTRA_LIBS の行に
<STRONG>手順 3</STRONG>の最後に出力された行を加える。
そして、次の行をファイルの最後に加える。
:<P>
<P>
<TT><STRONG>Module php_module         mod_php.o</STRONG></TT><P>
<P>
続いて、次のように入力する。
: <STRONG>./Configure</STRONG>
そして、Apache httpd サーバーを再構築する。
<STRONG>make</STRONG>
この実行ファイルをインストールする。<P>

<P>
  次に、Apache の conf/srm.conf ファイルを編集し、次のような
  行を加える必要がある。
  :<P>
<P>
<TT><STRONG>AddType application/x-httpd-php .phtml</STRONG></TT><P>
<P>
  これにより、<EM>.phtml </EM>という拡張子を持つ全てのファイルに対して、
PHP モジュール起動のトリガーとなる新しい MIME の型、
application/x-httpd-php が定義される。
他の拡張子を同様にして定義することも可能である。
<P>
<P>
もし、全てのユーザーが PHP で解釈されるファイルを実行可能であること
を望まない場合には、
<EM>access.conf</EM> において、
AddType の行を &lt;Location /path&gt;....&lt;/Location&gt;
構文の中に置くことにより、PHPで解釈されるドキュメントを
サーバー中の特定のディレクトリにのみ許可することができる。
<P>
<P>
以上で、httpd サーバーを再起動する準備ができた。
PHP モジュールの設定に関するより詳細な情報は、
<A HREF="#module">Apache モジュールに関して</A> を
参照のこと。<P>

<DT><FONT SIZE="+1">実行テスト</FONT>

<DD>
<P>
    インストール終了後、
    自分のブラウザに次のような URL を入力することにより、
    実行ファイルが動作するかどうかをテストすることができる。
    :<P>
<P>
  <TT>http://your.site.domain/cgi-bin/php.cgi</TT><P>
<P>
これにより、バージョン番号や他の有益な情報等を含むページが表示される。
    <P>

    <P>
  Apache モジュール版をテストするためには、.phtml という拡張子を
    持つ任意のファイルを作成し、
    次のようなタグを入力する。:<p>
     &lt;?phpinfo()&gt;
    <p>
    これが PHP に解釈されれば、同様の情報を見ることができる。<P>

<DT><FONT SIZE="+1">使用法</FONT>

<DD>
<P>
    既にある HTML ファイルに対して PHP/FI を使用する場合には、
    上記のURLに自分のファイル名をパス付きで加えるだけでよい。
    すなわち、<P>
<P>
  <TT>http://your.site.domain/cgi-bin/php.cgi/path/file.html</TT><P>
<P>
Apache
    このドキュメント中の
<A HREF="#redirect">CGI リダイレクション</A>の項を
    参照されたい。
PHP/FI をリダイレクトで実行することにより、
    PHP/FI に解釈される次のようなURLを自動的に使用することができる。
    <p>
<EM>http:/your.site.domain/file.phtml</EM>
<P>
<P>
以上のことは、Apace モジュール版のユーザーには適用されない。<P>
</DL>

<HR>
<H2><A NAME="starting">PHP/FI で何ができるのか?</A></H2>
<P>
PHP/FI を介して自分のページを見た時に最初に気づくのは、
フッターにそのページのアクセス数についての情報が加えられて
いることであろう。
(アクセス記録機能を有効にして実行ファイルを作成した場合)
これは、PHP/FI があなたのために行なえることのほんの一部に
過ぎない。
PHP/FI はフォーム解釈用 CGI 、つまり PHP/FI という名前の FI という部分、
として別の非常に重要な役割を果たす。
例えば、自分のWWWページにフォームを加えようとする際には、
フォームに入力された情報を処理する手段が必要になる。
単にその情報を他のページに受け渡そうとするだけであっても、
そのような処理を行なうCGI プログラムを用意する必要がある。
PHP/FI は、フォームに入力されたデータの処理や、そのデータを用いて
このようなことをすることを著しく簡単化する。
<P>
<P>
<EM><STRONG>簡単な例</STRONG></EM><P>
<P>
次のようなフォームがあるとする。:<P>
<P>
<TT>&lt;FORM ACTION="/cgi-bin/php.cgi/~userid/display.html" METHOD=POST&gt;<BR>
&lt;INPUT TYPE="text" name="name"&gt;<BR>
&lt;INPUT TYPE="text" name="age"&gt;<BR>
&lt;INPUT TYPE="submit"&gt;<BR>
&lt;/FORM&gt;</TT><P>
<P>
続いて、次のような文を含む
display.html というファイルを用意する。:<P>
<P>
<TT>&lt;?echo "Hi $name, you are $age years old!&lt;p&gt;"&gt;</TT><P>
<P>
簡単だ! PHP/FI は自動的にフォームのそれぞれについて一つの
変数を作る。
これらの変数を ACTION タグで URL により指定されたファイルにおいて
用いることができる。
<P>
<P>
次のステップでは、変数の使い方を理解したとして、
ホームページに論理的な流れを作り出すことを始める。
例えば、ユーザーの入力により異なったメッセージを表示したい
場合には、if/else 構文を使うだろう。
上記の例においてユーザーが入力した年齢に基づいて displat.html
を変えることにより、異なった表示を行なうことができる。
:<P>
<P>
<PRE>&lt;?
    if($age>50);
        echo "Hi $name, you are ancient!&lt;p&gt;";
    elseif($age&gt;30);
        echo "Hi $name, you are very old!&lt;p&gt;";
    else;
        echo "Hi $name.";
    endif;
&gt;</PRE><P>
<P>
PHP/FI は上に示した簡単な例よりもはるかに多くのことを行なえる
強力なスクリプト言語を提供する。
詳細な情報は
<A HREF="#script">PHP/FI スクリプト言語</A> を参照のこと。
<P>
<P>
PHP/FI を自分のページにアクセスする許可を与える人を設定するために
も使うことができる。
これは、PHP/FI に組み込まれた設定用画面により行なうことができる。
これにより、例えば特定のドメインからのアクセスする人のみ自分の
ページを見ることを許可するということを決めることができる。
また、特定のページをパスワードにより保護するというような
規則を設けることもできる。
詳細な情報は <A HREF="#access">アクセス制御</A> の項を参照のこと。
<P>
<P>
PHP/FI は、RFC-1867 の要件を満たす全ての WWW ブラウザからの
ファイルアップロードを受け取ることができる。
この機能においては、テキストとバイナリの両方をアップロードする
ことができる。
PHP/FI のアクセス制御機能と論理関数により、
ファイルをアップロードできる人と、いったんアップロードされた
ファイルによりすることができることを
完全に制御することができる。
詳細は、<A HREF="#upload">ファイルのアップロード</A>
の項を参照のこと。<P>
<P>
PHP/FI は、mSQL と呼ばれるデータベースをサポートしている。
これにより、情報をデータベースに渡したり、.HTML ファイルに
記述された簡単な SQL クエリーを通じてこの情報にアクセスしたりすることが
可能になる。
データベースのバックエンドをWWWページに加えることは、
従来簡単なことでなかった。
詳細は、<A HREF="#msql_support">mSQL のサポート</A>
の項を参照のこと。<P>
<P>
PHP/FI は、Postgres95/PostgreSQL データベースをサポートする。
この機能は、.HTML ファイル中における埋め込み型の SQL クエリー
をサポートする。
詳細は、<A HREF="#pg95_support">Postgres95/PostgreSQL のサポート</A>
を参照のこと。<P>
<P>
  <P>
PHP/FI は、mysql データベースエンジンもサポートする。
.HTML ファイルにおける埋め込み SQL クエリーがサポートされる。
詳細な情報については、<A HREF="#mysql_support">mysql サポート</A>
を参照のこと。<P>

<HR>
<H2><A NAME="redirect">CGI リダイレクション</A></H2>

<DL>
<DT><STRONG>Apache 1.0.x について</STRONG>
<DD>
<P>
PHP/FI を実行するうまいやり方は、Apache サーバーと共に
CGI リダイレクションモジュールを用いることである。
もし、Apache モジュール版の PHP/FI を用いる場合には、
リダイレクトモジュールに関する事項を気にする必要はない。
このリダイレクトモジュールは2種類のものが手に入る。
一つは、Dave Andersen &lt;angio@aros.net&gt; により作られたものであり、
<A HREF="ftp://ftp.aros.net/pub/util/apache/mod_cgi_redirect.c">ftp://ftp.aros.net/pub/util/apache/mod_cgi_redirect.c</A>
から手に入る。
もう一つは、Apache にバンドルされているものであり、mod_actions.c という
名前である。これらのモジュールはほとんど同じものである。
わずかな違いは、使用法に関してである。
両方のモジュールは共にテストされおり、
PHP/FI と組み合わせて動作する。
<P>
<P>
これを書いている時点(96/4/20)において次のような問題がある。

現在の Apache の公式リリース(1.0.5 版)には、
POST により渡されたデータを処理する際に、
CGI リダイレクションによる関連する要求を実行不可能であるという、
厳しい制限がある。
私は、この原因を突き止め、自分の版の Apache で修正した。
これに関する公式のパッチが
<A HREF="http://php.iquest.net">PHP ホームページ</A>
の <A HREF="http://php.iquest.net/files">File Archives</A>
にある。
<P>
<P>
Apache 1.0.x に関する 2 番目の更に大きな問題は、
倍精度実数型のデータをほとんどのアーキテクチャーにおいて
正しく配置しないということである。
あなたが、mod_php を用いた時に奇妙なバスエラーが起こることを
発見したときには、
Apache 1.1 にアップグレードするか、Apache のソースファイル中の
<i>alloc.c</i> を編集するかのどちらかを行なう必要がある。
このファイル中に、次のようなコードがある。
:<P>
<PRE>  union align
  {
    /* Types which are likely to have the longest RELEVANT alignment
     * restrictions... we don't do much with doubles.
     */

    char *cp;
    void (*f)();
    long l;
    FILE *fp;
  };</PRE>
<P>
この部分に倍精度の実数を一つ加えて Apache サーバーを再構築する
必要がある。
正しいコードを示す:<P>
<PRE>  union align
  {
    /* Types which are likely to have the longest RELEVANT alignment
     * restrictions... we don't do much with doubles.
     */

    char *cp;
    void (*f)();
    long l;
    FILE *fp;
    double d;
  };</PRE>
<P>これらの問題は、後のバージョンの Apache では全て修正されている。
<P>
Apache のドキュメントでモジュールの加え方を確認すること。
通常、<EM>Configuration</EM> という名前のファイルに
モジュール名を加える。
mod_actions モジュールを使いたい場合には、次のような1行を
加える。:<P>
<P>
<TT>Module action_module       mod_actions.o</TT><P>
<P>
mod_cgi_redirect.c モジュールを使っている場合には
次のような1行を加える。:<P>
<P>
<TT>Module cgi_redirect_module mod_cgi_redirect.o</TT><P>
<P>
次に httpd をコンパイルし、インストールする。
CGI リダイレクションを設定するために、
<EM>mime.types</EM> というファイルに新しい MIME タイプを
作るか、
<EM>srm.conf</EM> というファイルに <STRONG>AddType</STRONG> コマンドを
使って新しいMIMEタイプを加えることができる。
加えるべき MIME の型は次のようなものである。:<P>
<P>
<TT>application/x-httpd-php     phtml</TT><P>
<P>
もし、mod_actions.c モジュールを使っているならば、
<EM>srm.conf</EM> ファイルに次のような行を加える必要が
ある。:<P>
<P>
<TT>Action application/x-httpd-php /cgi-bin/php.cgi</TT><P>
<P>
もし、mod_cgi_redirect.c 使っているならば、
<EM>srm.conf</EM> に次のような行を加える。:<P>
<P>
<TT>CgiRedirect     application/x-httpd-php     /cgi-bin/php.cgi</TT><P>
<P>
mod_actions.c と mod_cgi_redirect.c を同時に用いてはならない。<P>
<P>
CGI リダイレクションモジュールのどちらかをインストールし、
正しく設定した場合には、
単に拡張子 <STRONG>.phtml</STRONG> を有するファイルを作ることに
より、PHP/FI により解釈されるファイルを決めることができる。
さらに、<STRONG>index.phtml</STRONG>を
<EM>srm.conf</EM> 中の
<STRONG>DirectoryIndex</STRONG>
に関する設定の行に加え、
index.phtml という名前でインデックスファイルを作ることにより、
(index.phtml を置いた)
あるディレクトリの最上位のページは自動的に php で解釈されるようになる。
<P>

<DT><STRONG>Netscape HTTPD</STRONG>
<DD>
<P>
Netscape サーバー CGI リダイレクションモジュールを用いることにより、
自動的に PHP/FI により処理される拡張子を有するファイルに関する要求を
リダイレクトできる。
このモジュールは以下の場所で手に入る。
<A HREF="http://php.iquest.net">PHP/FI Home Page</A> の
<A HREF="http://php.iquest.net/files">File Archives</A>。
このパッケージに含まれる README の中で、
これをPHP/FI と組み合わせて使う際の
設定法が明解に説明されている。
<P>

<DT><STRONG>NCSA HTTPD</STRONG>
<DD>
<P>
NCSA は、現在モジュールをサポートしていない。
そこで、CGI リダイレクションを使うためにはソースコードを
修正する必要がある。
NCSA 1.5 に対するパッチが
<A HREF="http://php.iquest.net/files">PHP/FI file archives</A>
より手に入る。
</DL>

<HR><P>
<H2><A NAME="security">セキュリティについて</A></H2>
<P>
CGI 版の PHP/FI は、
<EM>.htaccess</EM> ファイルがディレクトリにある場合でも、
PHP/FI はこのファイルを<STRONG>読まない。</STRONG>
.htaccess による標準的なサーバーによるアクセス制御機能
を用いて保護しているファイルがある場合には、PHP/FI を通してそのページを
ロードすることにより、このセキュリティ機構を回避される可能性がある。
このことは、Apache モジュール版の PHP/FI にはあてはまらない
ことに注意されたい。<P>
<P>
CGI 版に関する2番目の問題点は、システムのcgi-bin ディレクトリに php.cgi
が置かれた場合に、php.cgi を実行するユーザーのID でアクセスできる限り
システムの中の全てのファイルを見ることが可能であるということである。
<P>
この問題に対する対策はいくつかある。最も簡単な解決策は、<EM>php.h</EM>
中にある
<STRONG>パターン制限(PATTERN_RESTRICT)</STRONG> 機能を使うやり方である。
この機能により、PHP/FI により解釈させることが可能な
ある拡張子(もしくは拡張子のパターン)を定義することができる。
この拡張子を持たないあるファイルを誰かがPHP/FIを通じて
ロードしようとした時には、<EM>アクセス拒否</EM> のメッセージが現れる。<P>
<P>
別の対策は、PHP/FI のアクセス制限機構により
.htaccess に記述したアクセス制限の設定を模擬することである。
しかし、この情報を2つの場所に置くのは冗長であるし、
2つのシステムは全く同じ機能を有しているわけではない。<P>
<P>
この問題は、ファイルの許可属性によっても解決することができる。
PHP/FI は、任意のユーザのID で動作するように設定できる。
つまり、
PHP/FI により読み込まれてもよいファイルに適当なアクセス許可属性を
与え、PHP/FI により読み込まれたくないファイルは、
他ユーザーに所有させて適当に変更した許可属性を与えるべきである。<P>
<P>
PHP に関するアクセス権が共有されているサイトに関連する追加のセキュリティ
オプションについては、
<a href="#safemode">セーフモード</a> 節を参照のこと。<P>
<HR>
<H2><A NAME="safemode">セーフモード</A></H2>
<P>
PHP のセーフモードは、全てのユーザーが CGI プログラムを実行する
ことを許可しようとする多くの ISP が直面する共通の問題を解決しよう
とするものである。
共有される CGI アクセスをより安全にするための
一般的な機構は、Apache に付属するユーティリティ
su_exec のような CGI ラッパーを使用することである。
この機構は、PHP がモジュールとして実行されている場合には動作しない。
これは、この場合、setuid されて実行可能な別プロセスではないから
である。
<P>
この機構は、ファイルのアクセス許可の手法に基づいている。
あるファイルがそのファイルをアクセスしようとしているスクリプトと
同じユーザーIDにより所有されるか、または、
そのファイルがそのファイルにアクセスしようとするスクリプトと同じ
ユーザーにより所有されるディレクトリにある場合にアクセスが許可される。
ここで注意を要するのは、自分の OS が、
自分所有のファイルを自分以外の所有に変更することをルートでない
ユーザーに許可しないことを確認する必要があることである。
多くの古い SysV システムはこれを許可している。
Irix が、その典型的なものである。
Irix の OS レベルでこの動作を変更することは不可能である。
<P>
セーフモードは、セキュリティ上の危険性がある
各関数に適用される。
以下は、関連する各関数に適用される現在のチェックの一覧表である。
次のリストで、PHP UID は、PHP により解釈される現在のファイルの所有者の
ユーザーID を指す。
そして、HTTP UID は、httpd プロセスが実行されているユーザーID
(通常は、nobody) を指す。
<dl>
<dt>Include, ReadFile, Fopen, File, Link, Unlink, Symlink, Rename, RmDir, ChMod, ChOwn, ChGrp
<dd>インクルードされるファイルの所有者が PHP UID であるか、または
    ファイルが存在するディレクトリが PHP UID により所有されている必要が
    ある。
<dt>Exec, System, PassThru ,Popen
<dd> 子プロセスとして実行される実行ファイルは、PHP がコンパイルされる
    際に php.h で #define PHP_SAFE_MODE_EXEC_DIR で定義された
    ディレクトリにある必要がある。
<dt>Mysql_Connect
<dd>この関数は、MySQL データベースと接続する際に使用するために
    オプションとしてユーザー名をとる。セーフモードの時は、
    このユーザー名は、現在解釈中のファイルの所有者のユーザ名または
    httpd ユーザー(通常は、nobody)のどちらかである必要がある。
<dt>HTTP 認証
<dd>HTTP認証コードを含むスクリプトの所有者のユーザーID番号は、
認証領域に事前送付される。
これにより、誰かが同じサーバー上の別の認証付きページをだまして
パスワードを横取りするスクリプトを書くことを防止する。
</dl><P>
  <HR>
  <H2><A NAME="commandline">コマンドラインからの PHP/FI 実行</A></H2>
  <P>
PHP/FI の CGI 版を構築する場合、次のようにタイプするだけで
コマンドラインからこれを使用することができる。<br>
<tt> php.cgi ファイル名</tt><br>
ただし、ファイル名は、処理しようとするファイルである。
また、スクリプトの最初に次のような行を作成することにより、
スタンドアロン PHP/FI スクリプトを作成することも可能である。<br>
 <PRE>    #!/usr/local/bin/php.cgi -q</PRE><br>
 &quot;-q&quot; は、HTTP ヘッダの出力を抑制する。もし、望むならば
このオプションは抜くことが可能である。
 <P>
<HR>
<H2><A NAME="http_auth">HTTP 認証</A></H2>
<P>
PHP/FI における HTTP 認証のフックは Apache モジュールとして
PHP/FI を実行している時にのみ使用可能である。
Apache モジュール PHP/FI スクリプトにおいては、
Header() コマンドにより &quot;認証要求&quot; メッセージを
クライアントのブラウザに送ることができる。
これにより、ユーザ名/パスワード入力用ダイアログがポップアップする。
ユーザーがユーザー名とパスワードを入力すると、
PHP/FI スクリプトを含む URL が $PHP_AUTH_USER,$PHP_AUTH_PW and $PHP_AUTH_TYPE
にそれぞれユーザー名、パスワード、認証方法をセットした状態で
再び呼ばれる。
基本的な認証のみがここではサポートされている。<P>
<P>クライアント認証をページで行なうスクリプトの例の一部
を以下に示す。<P>
<PRE>    &lt;?
        if(!$PHP_AUTH_USER) {
            Header(&quot;WWW-authenticate: basic realm=\&quot;My Realm\&quot;&quot;;)
            Header(&quot;HTTP/1.0 401 Unauthorized&quot;);
            echo &quot;Text to send if user hits Cancel button\n&quot;
            exit;
        } else {
            echo &quot;Hello $PHP_AUTH_USER.&lt;P&gt;&quot;;
           Header(&quot;WWW-authenticate: basic realm=\&quot;My Realm\&quot;&quot;);
            echo &quot;You entered $PHP_AUTH_PW as your password.&lt;P&gt;&quot;;
        }
    &gt;</PRE>
<P>

単に $PHP_AUTH_USER と $PHP_AUTH_PW を出力するかわりに、
認証のためにユーザー名とパスワードをチェックしたいこともあるだろう。
クエリーをデータベースに送るか、dbm ファイル中のユーザー情報を
見ることにより、認証が可能であろう。<P>
<P>
相手がバグのあるインターネット・エクスプローラであるときには
注意を要する。
このブラウザはヘッダーの順序にとてもうるさい。
現状では、<b>WWW-authenticate</b> ヘッダーを
<b>HTTP/1.0 401</b> ヘッダーの前に送ることにより
認証を行なうことができる。<P>
<P>
従来の外部プログラムにより認証されるページについてパスワードを
暴くようなスクリプトが書かれることを防ぐために、
外部認証が特定のページについて可能であるならば
PHP_AUTH 変数はセットされない。<P>    
<P>
しかし、この機能により
未認証のURLを制御する誰かが同じサーバー上の認証済みURLから
パスワードを盗むことを防ぐことはできない。

<em>php.h</em> 中に定義された PHP_AUTH_VARS を未定義とすることにより、
上記の変数がセットされないことを保証し、
mod_php を使用する誰かがパスワードを盗むことを
確実に不可能にすることができる。<P>
<HR>
<H2><A NAME="requestvars">Apache リクエスト変数</A></H2>
<P>
PHP を Apache モジュールとして実行している場合、
使いたいヘッダ変数の前に <B>$req_</B> を付加することにより、
リモートブラウザから送られたリクエストヘッダ変数にアクセスすることが
可能である。
リクエスト名が、User-Agent のように文字 <b>-</b> を含む場合は、
- を _ (アンダースコア)に置き換え、$req_User_Agent のように
参照する必要がある。
<a href="#phpinfo">phpinfo()</a> 関数は、
リクエストヘッダを全て表示するために使用することができる。

<P>
例
<PRE>    &lt;
        echo "$req_connection&lt;br&gt;";
        echo "$req_host&lt;br&gt;";
    &gt;</PRE>
上の簡単なスクリプトは、次のように出力する。
<PRE>    Keep-Alive
    www.host.com</PRE>

<HR>
<H2><A NAME="module">Apache モジュールに関して</A></H2>
<P>
PHP/FI を Apache モジュールとして実行することは、
このパッケージを最も効率的に運用する手段である。
PHP/FI をモジュールとして実行することは、
PHP/FI の機能が Apache サーバーの機能と組み合わされ
一つのプログラムとなることを意味する。
PHP/FI をモジュールとして実行することには、数多くの
利点がある。:<P>
<DL>
<DT><STRONG>性能</STRONG>
<DD>
<P>性能面からは、従来のCGIプログラムよりもかなり速い。
事実、PHP/FI をモジュールとして動作させる時、CGIは必要とされない。
HTML中のスクリプトコードは Apache web サーバープロセスにより直接実行される。
<P>

<DT><STRONG>セキュリティ</STRONG>
<DD>
<P>モジュールとして実行される際には、
Apache の設定ファイルか個人の.htaccess ファイル中において
定義される通常の httpd で用いられるアクセス制限ルールは、
モジュールがファイルを処理することを許可された後で適用される。
もしくは、
通常のhttpd ベースの認証を制御するPHP/FIスクリプトを
作ることもできる。
<A HREF="#http_auth">HTTP 認証</A> を参照のこと。<P>

<DT><STRONG>設定の簡便性</STRONG>
<DD>
<P>パーサが httpd プロセスの内部でいつでもアクティブであるので、
httpd プロセスの設定に用いるのと同じ設定ファイルを用いて
プロセス開始時に設定を行なうことができる。
モジュールにおいては、<EM>.htaccess</EM> ファイル中に
<A HREF="#directives">PHP 設定ディレクティブ</A>を置くことにより、
ディレクトリ毎に設定を行なうこともできる。
<P>

<DT><STRONG>カスタムサーバー型アプリケーションの基礎</STRONG>
<DD>
<P>
Apache の内部から自分の関数にアクセスすることに関心がある C プログラマ
    にとって、PHP/FI フレームワークは、Apache と PHP 自体への非常に簡単な
    インターフェースを提供します。
    PHPに関数を加えて処理されるページから呼び出すのは、
    スクラッチから Apache モジュール全体を書くより非常に簡単である。
    このドキュメントの終りの方にある
<a href="#addfunc">自分の関数をPHP/FI に加えるには</a>
節を参照のこと。
</DL>

<H2><A NAME="directives">Apache モジュール設定ディレクティブ</A></H2>
<P>
次の宣言文は、<EM>srm.conf</EM> ファイルか、
<EM>access.conf</EM> 中の &lt;Directory&gt;...&lt;/Directory&gt; タグの
内部か、<EM>access.conf</EM> 中の &lt;Location /path&gt;...&lt/Location&gt;
タグの内部か個々の <EM>.htaccess</EM> ファイル中に置くことができる。:<P>
.htaccess ファイルにおいて命令が動作するために、Options override を
AllowOverride Apache 命令によりセットする必要がある。
ただし、
*.conf ファイルにおいてのみ使用可能な phpEngine 命令は例外である。
<P>
<DL>
<DT><STRONG>phpShowInfo <EM>on</EM>|<EM>off</EM></STRONG>
<DD>PHP 情報フッターをオン／オフにする。デフォルトはオン。<P>
<DT><STRONG>phpLogging <EM>on</EM>|<EM>off</EM></STRONG>
<DD>ログ機能をオン／オフにする。デフォルトはオン。<P>
<DT><STRONG>phpDebug <EM>on</EM>|<EM>off</EM></STRONG>
<DD>自動 ?info デバッグ画面を on または off にする。デフォルトはオフ。<P>
<DT><STRONG>phpUploadTmpDir <EM>directory</EM></STRONG>
<DD>フォームによりアップロードされるファイルを置くディレクトリを指定する。<P>
<DT><STRONG>phpDbmLogDir <EM>directory</EM></STRONG>
<DD>dbm に基づくログファイルが書き込まれるディレクトリを指定する。<P>
<DT><STRONG>phpSQLLogDB <EM>database</EM></STRONG>
<DD>ログ記録用の SQL データベースの名前をセットする。
デフォルトは、&quot;phpfi&quot;。<P>
<DT><STRONG>phpSQLLogHost <EM>hostname</EM></STRONG>
<DD>ログ記録用の SQL  データベースがあるホスト名をセットする。
デフォルトは、&quot;localhost&quot;。<P>
<DT><STRONG>phpAccessDir <EM>directory</EM></STRONG>
<DD>PHP アクセス制御用の内部ファイルが保存されるディレクトリを指定する。<P>
<DT><STRONG>phpMaxDataSpace <EM>KiloBytes</EM></STRONG>
<DD>PHPモジュールにおける内部記憶領域の最大値。
    この値を小さな数にすることにより、mod_php がシステムに与える負荷を
    最小化することができるが、複雑なスクリプトを書くことも制限を受ける
    可能性がある。デフォルトは、8K。<P>
<DT><STRONG>phpIncludePath <EM>colon-separated path</EM></STRONG>
<DD><A HREF="#include">include()</A> を実行する際に php がファイルを
    探すコロンで分割されたディレクトリのリスト。
    デフォルトは、カレントディレクトリのみを探す。
<P>
<DT><STRONG>phpAutoPrependFile <EM>ファイル名</EM></STRONG> <DD>
PHPの Include()関数を用いて
(よって、phpIncludePath がこのファイル名に適用される)
実際の PHP/FI ファイルである"主ファイル" が実行される前に
実行されるファイルの名前をここで指定することができる。
自動的に付加されるファイル(auto-prepended file)から HTML を書く場合には、
Header()関数を主ファイル中で使用することが困難になることに注意されたい。
<P>
<DT><STRONG>phpAutoAppendFile <EM>ファイル名</EM></STRONG>
<DD>
PHP/FIファイル本体が実行された後に(PHPのInclude()関数により)
実行されるファイルの名前。
phpAutoPrependFileと同様。
<P>
<DT><STRONG>phpAdaDefDB <EM>データベース</EM></STRONG>
<DD>デフォルトで使用するの Adabas データベース。
デフォルト値はなし。
<P>
<DT><STRONG>phpAdaUser <EM>ユーザ名</EM></STRONG>
<DD>デフォルトの Adabas データベースユーザ名。
デフォルト値はなし。
<P>
<DT><STRONG>phpAdaPW <EM>パスワード</EM></STRONG>
<DD>
<DD>デフォルトの Adabas データベースのパスワード。
デフォルト値はなし。
<P>
<DT><STRONG>phpEngine <EM>on</EM>|<EM>off</EM></STRONG>
<DD> PHP  の文法解釈エンジンを on または off にする。
デフォルトは<em>on</em>である。
この命令は、AllowOverride Options により
.htaccess ファイルにおいて、命令リストにより命令を使用できる
ようにする一方で、同時に mod_php へのアクセスを制限するような
サイトにおいてのみ有益である。
仮想ホスト毎に PHP のインストール管理を行う一般的な方法は、
仮想ホスト毎に AddType 命令により PHP の mime 型を使用可能にし、
PHP を使用しない仮想ホストの組では、&quote;phpEngine off&quot;
を用いることである。
PHP を使用しない顧客が、PHP mime 型を自分の .htaccess に置くことにより
回避しようとしても、phpEngine off の設定によりPHP パーサに機能上の拘束が
課される。
<DT><STRONG>phpLastModified <EM>on</EM>|<EM>off</EM></STRONG>
<DD>PHPページは動的に作成されるため、アクセスする度に各ページ
は処理され、ブラウザに送られる。
しかし、単純な挿入のために PHP を使用する場合には、
ソースが変わらない限り実行されるページは不変である。
このような場合、ページの再作成や再ロードを回避したいと
考えるであろう。
phpLastModified をオンにすると Apache は、Last-Modified タグを
ブラウザに送る。
この場合、そのページは変更があった場合にのみ再ロードされる。
ページ記録機能を使用している場合、多重アクセスは記録されないことに注意
されたい。
</DL>
<P>
これらの宣言文は全てオプションである。
宣言がどこでもなされない場合には、コンパイル時のデフォルト値が用いられる。
<P>

<HR>
<H2><A NAME="fastcgi">FastCGI サポート</A></H2>
<P>
PHP/FI は FastCGI サポートを有効にしてコンパイルすることができる。
その際には、PHP/FI をコンパイルする前に
自分のプラットフォーム用の
<A HREF="http://www.fastcgi.com">FCGI 開発キット</A>
をダウンロードし、コンパイルする必要がある。
また、<A HREF="#redirect">CGI リダイレクション</A> を動作させる
必要がある。
それから、自分のプラットフォーム用 FastCGI のドキュメント中の指示に従うこと。
mod_fastcgi モジュールを Apache サーバーと共に使用する場合には、
次のような順序で作業を行なう。:<P>
<P><UL>
<LI> Apache 設定ファイルを編集し、mod_fastcgi モジュールを付け加える。
    それから、Apache を再コンパイルする。
<LI><EM>srm.conf</EM> ファイルを編集し、次のような行を加える。:<br>
<TT>
AddType application/x-httpd-fcgi .fcgi<br>
AppClass /usr/local/etc/httpd/fcgi-bin/php.fcgi -processes 4<br>
AddType application/x-httpd-fphp .fhtml<br>
Action application/x-httpd-fphp /fcgi-bin/php.fcgi<br>
</TT>
<LI><EM>php.cgi</EM> 実行ファイルを<EM>/usr/local/etc/httpd/fcgi-bin/php.fcgi</EM>にコピーする。
</UL><P>
<P>
これにより、
.fhtml 拡張子を有する全てのファイルは、
既に実行されている FastCGI php.fcgi プロセスへと
渡される。

php.fcgi 実行ファイルは、まだ通常のCGI実行ファイルとしても
動作するので、
php.cgi から php.fcgi へのシンボリックリンクを作成する
ことも可能である。<P>
<P> Apache を使用しない場合には、上記手順に似ているが異なった
手段となる。
NCSA や Netscape サーバにおいて使用可能な CGI リダイレクション機構用
ファイルは、
<A HREF="http://php.iquest.net/files">PHP/FI ファイルアーカイブ</A>
にある。<P>

<HR>
<H2><A NAME="access">アクセス制御</A></H2>
<P>
PHP/FI 組み込みのアクセス制御のサポートは、恐らく将来のバージョンにおいて
打ち切られるだろう。
代わりに web サーバーに付属する
セキュリティ機構の使用を真剣に考慮するべきである。
<P>
このパッケージをコンパイルする時にアクセス制御機能を含めた場合には、
<EM>?config</EM>という記述をURLに加えることによりアクセス制御ファイルを
編集することができる。以下に例を示す。<P>
<P>
<TT>http://your.machine.domain/cgi-bin/php.cgi/path/file.html?config</TT><P>
<P>
あなたの設定用パスワードの初期値はあなたのユーザーIDにセットされる。
もし自分のユーザーIDがパスワードとして使用できないときは、
おそらく PHP があなたのユーザーIDが存在するマシンの /etc/passwd ファイルを
読むことができないと考えられる。
このような場合には、初期パスワードは、"<STRONG>php</STRONG>"にセットされる。
このパスワードは変更するのが賢明である。
単一の PHP/FI バイナリを用いて 
複数のユーザーが自分自身の個人設定用ファイルを保持することができる。
<P>
<P>
アクセス制御に関して最初はかなり混乱するかもしれない。
?config の画面は複数の節(画面)に分割されている。
最初の節はパスワードを変更するためのものである。
このパスワードはこれを知る者だけがアクセス制御の
設定を変更可能であるようにするためのものである。

システム全体にインストールを行なった場合には、
各ユーザーはパスワードで保護された自分用の設定画面を持つことができる。
<P>
<P>
?config 画面の第2節は、複数の表から構成される。
各表はあるルールセットを規定する。
最初のルールセットはいつもデフォルトのルールセットとなる。
このデフォルトのルールセットはもしあるページが固有のルールセットを
規定していない場合に用いられる。
デフォルトのルールセットの後に
複数の特定のルールセットを記した表を続けることができる。
<P>
<P>
特定のファイル用のルールセットを加えるためには、
ブラウザ上でそのファイルのURLを入力し、
<EM><STRONG>?config</STRONG></EM> をURLの終わりに付け加える。
もし、まだあるルールセットが存在しない場合には、
表示された ?config 画面においてそのページにそのルールセットが付け加えられた
ことを確認できる。
新しいルールセットが付け加えられた時には、
デフォルトのルールセットと同様にセットされる。
次の図は、2つの簡単なルールセットを示している。
最初は、全てのドメインからのアクセスをログに記録することだけを指示する
デフォルトのルールセットであり、
2番目は /~rasmus/test.html というファイルのみについて
&quot;<EM>.edu</EM>&quot; ドメインから来たユーザーのアクセスを
許可しないことを指示するものである。
<P>
<P>
<IMG SRC="gifs/config.gif" alt="[Image of ?config screen]"><P>
<P>

ルールセットを編集する際には、所望の設定がルールセットの中に
現れるように(ドロップダウンボックス等の)フィールドを修正し、
&quot;<EM>Submit Changes</EM>&quot; ボタンを押す。
もし、もっと多くのルールが必要ならば、
&quot;<EM>Add Rule</EM>&quot; を押し、付け加えられたルールを
編集する。
<P>
ルールを削除するためには、そのルールの右にあるチェックボックスを
選択し、&quot;<EM>Submit Changes</EM>&quot; を押す。
画面が再描画され、そのルールは消える。<P>
<P>
正規表現をパターンフィールドに入力することが必要となることもある。
詳細はこのドキュメント中の正規表現の節を参照のこと。
<P>

<HR>
<H2><A NAME="logging">アクセス情報の記録</A></H2>
<P>
アクセス情報の記録は、コンパイル時にインストール用スクリプトの
質問に対して <EM>Yes</EM> を答えることにより使用可能となる
別のオペレーション機能である。
アクセス記録データを dbm ファイル、mSQL データベース、
mysql データベースのどれかに保存することが可能である。
後ろの 2つはより強力であるが、セットアップがやや難しい。
<P>
<P>
dbm ファイルをログ記録の保存に使う際には、
ログファイルを書き込むことのできるディレクトリを指定する必要がある。
PHP はこのディレクトリがない場合には作成を試みる。
しかし、適当な許可属性を確実に設定するために、
始めて PHP を動作させる前にこのディレクトリを自分で作成することもできる。
PHP cgi プログラムを実行するユーザーIDがこのディレクトリに対して
書き込み可能であるように許可属性を設定する必要がある。
<P>
<P>
アクセス記録データを保存するために mSQL データベース、
または mysql データベースを使う時は、
自分のシステムにmSQLまたは mysql がインストールされ、実行されているかを
最初に確認する必要がある。
次にデータベースを作成する必要がある。
デフォルトの名前は &quot;phpfi&quot; であるが、
この名前は <EM>src/php.h</EM> において変更可能である。
mSQL でデータベースを作成するには、次のように入力する。:<P>
<P>
<PRE>    msqladmin create phpfi</PRE><P>
mysql については、次のように入力する。:
<PRE>    mysqladmin create phpfi</PRE><P>
<P>
次に mSQL の場合は、<EM>msql.acl</EM> ファイルを編集し、
データベースの許可属性が正しいことを確認する。
次のような記述で充分である。:<P>
<P>
<PRE>    database=phpfi
    read=*
    write=nobody,&lt;your user id&gt;
    access=local</PRE><P>
<P>
mysql の場合は、httpd ユーザー(通常は &quot;nobody&quot;) が
データベースにアクセスできるかどうかを確認する必要がある。
mSQL とは異なり、mysql はアクセス制御データをあるデータベースの
中に保持する。
デフォルトの許可属性を仮定すると、
次のようなコマンドを実行することができるに違いない。:<P>
<PRE>    echo "INSERT INTO user VALUES ('localhost','nobody','','Y','Y','Y','Y','Y','Y','Y','Y','Y');" | mysql mysql</PRE><P>
忘れずに次のように新しい設定をロードする。:<P>
<PRE>    mysqladmin reload</PRE><P>
ログデータを保存させたいユーザーID毎に、
2つのテーブルを作成する必要がある。
scripts ディレクトリにあるシェルスクリプト <EM>msqllog</EM>
はこれを行なう。
単に以下を入力する。:<P>
<P>
<PRE>    msqllog &lt;user id&gt; </PRE><P>
mysql の場合は、以下を入力する。:
<PRE>    mysqllog &lt;user id&gt; </PRE><P>
<P>

これによりスクリプトは適当なテーブルを作成する。

各システム上においてログが保存される場所を反映するためにスクリプト
を編集する必要があるかもしれない。
<P>
<P>
あなたはこのスクリプトを覗いてみたいと思うかもしれない。
ここでは、記録用テーブルのフィールドの大きさを定義している。
例えば、ファイルパスが64文字を越えることがわかっているならば、
<EM>msqllog</EM> または、<EM>mysqllog</EM> ファイル中の
<EM>logN</EM> と <EM>lastN</EM> の両方のテーブルにおけるファイル名の大きさを
大きくする必要がある。
<P>
アクセス記録時にはページ毎の &quot;ヒット &quot; 数についての情報
が保存される。
このヒット数情報はこれらのログファイルを
評価することにより集計することができる。

ログファイルを集計するスクリプトの例がこのパッケージに含まれている。
<TT>examples</TT> ディレクトリ中の <TT>log.html</TT> ファイルがそれである。
これは、 dbm によるログファイルの解析を行なう。
mSQL によるログファイルの解析を行なうのは、<TT>mlog.html</TT> である。
そして、
mysql によるログファイルの解析を行なうのは、<TT>mylog.html</TT> である。
これを実行するには、このファイルと、他のmlog.* ファイルを
自分の web サーバーからアクセス可能なディレクトリに
コピーし、次のように入力する。:<P>
<PRE>    http://your.machine.domain/cgi-bin/php.cgi/path/mlog.html</PRE><P>
もしくは、Apache モジュール版を使用している場合には、
このスクリプトに拡張子 &quot;.phtml&quot; を付け、次のようにコールする。:<P>
<PRE>    http://your.machine.domain/path/mlog.phtml</PRE>
<P>
PHP をアクセス記録機能付きでコンパイルした場合、
デフォルトでは、各ページはいくつかのアクセス情報を含む
フッター付きで表示される。
このフッターを表示させずにヒット数の記録を行ないたいと思う時、
Apache を実行している場合には、Apache の httpd.conf または
.htaccess ファイルに&quot;phpShowInfo off&quot; を記述しこのフッタを
オフにすることができる。
Apache を使用していない場合には、<A HREF="#access">?config</A> に関する

これらのログフッタを
によりオフにできるであろう。

<A HREF="#access">?config</A> を行なう際に
そのページについてのルールを作るか、
このページの中に次のようなタグを加えることにより
ログフッターを非表示とすることができる。
<P><P><TT>&lt;?setshowinfo(0)&gt;</TT><P>

<HR><H2>
<A NAME="relative">
相対URLと絶対URL もしくは、なぜイメージファイルが表示されないのか?</A></H2>
<P>全てのCGIラッパーに共通な問題の一つは、HTTPDプログラムが現在のディレクトリを
ロードしているものが保存されているディレクトリに変えてしまうことである。
CGIプログラムの場合は、現在のディレクトリはCGIプログラムが置かれたディレクトリに
セットされる。
このことは相対URL指定を受けた場合を除き通常問題とならない。<P>
<P>
相対URLは、
現在のディレクトリが現在処理中のHTMLファイルが置かれているディレクトリと
同じであることを前提としたURLである。
つまり、例えば以下のようなURLがあったとする。:<P>
<P>
<PRE>    http://my.machine/~rasmus/file.html</PRE><P>
<P>
実際のHTMLファイルは以下の場所にある。:<P>
<P>
<PRE>    ~rasmus/public_html/file.html</PRE><P>
<P>
仮にファイル <TT>file.html</TT>中に次のようなタグがあったとする。:<P>
<P>
<PRE>    &lt;IMG SRC=&quot;pic.gif&quot;&gt;</PRE><P>
<P>
正常に読み込まれた場合、この gif ファイルは
<TT>~rasmus/public_html/pic.gif</TT> にあると想定される。
しかし、次のようなURLのファイルがCGIラッパー経由で読み込まれたとすると、
<P>
<PRE>    http://my.machine/cgi-bin/php.cgi/~rasmus/file.html</PRE><P>
<P>
HTTPD は現在のディレクトリを <TT>/cgi-bin</TT> に
(あるいは、ScriptAlias で指定した場所に)セットする。:<P>
続いてこのページが読み込まれる際に、<TT>pic.gif</TT> ファイルは
<TT>/cgi-bin/pic.gif</TT> にあるものと想定されるが、
これは通常望んだ結果ではない。<P>
<P>
この問題の手っ取り早い解決手段は絶対URLを使うことである。
上記の例においてimageタグが次のようなものであった場合には、
何の問題も生じなかったであろう。:<P>
<PRE>    &lt;IMG SRC=&quot;/~rasmus/pic.gif&quot;&gt;</PRE>
<P>
絶対URLを使用することはポータビリティを悪化させるため、
いつも望ましいわけではない。

この問題に関して次のような明白な疑問を生じるかもしれない。
「なぜ、PHP は正しい場所にカレントディレクトリを変えないのか?」

実際にはPHPはカレントディレクトリを表示中の HTML ファイルが
ある場所に変えている、というのが答えである。

PHP スクリプトタグ中で用いられるあらゆるファイルパスは
相対表現とすることができる。

問題は、PHP による制御の範囲外にある
&lt;img &gt; や &lt;a href &gt; のようなタグは、
PHP により処理されないということである。

これらが解釈される時、PHP はもはやアクティブではなく、
カレント作業ディレクトリはHTTP デーモンにより指定された
ディレクトリに戻されている。<P>
<P>
<STRONG>解決手段</STRONG> は妥協策である。PHP は
<STRONG>PATH_DIR</STRONG>という変数を提供する。
これは、現在処理中の HTML ファイルのディレクトリ部を常に保持している。
この PATH_DIR 変数を  &lt;img &gt; や &lt;a href &gt; タグ
に用いた場合、
サーバーが解釈する際には絶対URLのように見えるにもかかわらず、
相対URL を用いた場合と同様の効果が得られる。

上記の例において必要な変更点は img タグを次のように
変えることだけである。:
<PRE>    &lt;IMG SRC=&quot;&lt;?echo $PATH_DIR&gt;/pic.gif&quot;&gt;</PRE>

上記タグの使用により、このタグを含むファイルを移動することが
可能になる。
このタグは常に同じディレクトリにある<TT>pic.gif</TT> ファイルを
HTML ソースファイルとして参照する。<P>
<P>
この問題に対する伝統的な別の解決策は、
&lt;BASE HREF=...&gt; タグをHTMLファイル中に
用いることである。
<P>

<HR>
<H2><A NAME="getpost">PHP における GET と POST メソッドの処理</A></H2>
<P>
PHP は、HTML フォームから送られる GET と POST メソッドの両方を
検出する。
理解しておかなければならない重要な点は、
両方が共に与えられた場合にはPOST メソッドによるデータが常に最初に処理される、
ということである。
ある PHP 変数が POST メソッドによるデータで定義されるか、
UNIX環境におけるHTTPデーモンによって定義される場合には、
GETメソッドによるデータはこれを上書きすることはできない。
これは、誰かが自分のURLに<EM>?REMOTE_HOST=some.bogus.host</EM>と加えることにより、
こうした別のデータを記録するように PHP のログ機構を欺くことを防ぐためである。
しかし、POST メソッドによるデータはこれらの変数を上書きすることが可能である。
<P>

フォームにより作成される GET データの全ての構成要素(URL における '?' に続くデータ)
は<EM>word=something</EM> という形式であり、
<EM>something</EM> という値を有する変数 <EM>$word</EM> を定義する。
データがこの形式でない時でも、組み込み配列 $argv によりアクセスすることができる。
例えば、次のようなURL:<P>
<PRE>    /cgi-bin/php.cgi/file.html?abc+def+EMAIL_ADDR=rasmus@lerdorf.on.ca&amp;var=value</PRE>
においてPHPシンボルテーブルにおける関連する構成要素は次のようになる。:<P>
<PRE>    $argc       = 4
    $argv[0]    = abc
    $argv[1]    = def
    $argv[2]    = EMAIL_ADDR=rasmus@lerdorf.on.ca&amp;var=value
    $EMAIL_ADDR = rasmus@lerdorf.on.ca
    $var        = value</PRE>
<P>

データ中の EMAIL_ADDR の部分が、解釈されていない状態で $argv[2] の中と、
<EM>rasmus@lerdorf.on.ca</EM> という値を有するように作成された変数 $EMAIL_ADDR の名前の
双方に現れている。

<P>
変数 $EMAIL_ADDR は、
PHP のログ機能を使っている場合には便利な変数であるので、
上記の例で用いた。

ユーザーの e-mail アドレスが既知であるようなページにおける
リンクに次のように付け加えることにより、
次のページにそれを受け渡すことができる。:<P>
<PRE>    ?EMAIL_ADDR=</PRE>
<P>

PHP ログ機能は自動的にこの変数を見つけてユーザーの e-mail アドレスとして
値を記録する。
PHP1 のユーザーにとっては、上記の記述は PHP1 において URL に
<EM>?&lt;!--$email--&gt;</EM> を加えることにより
行なわれてきたことと同じ機能を与えるものである。
現仕様は若干複雑になっているようであるが、複雑なページの構築が可能なように
完全に一般的になっている。<P>

<P>
上記の例において、
GET メソッドによるデータにおいて &quot;&amp;&quot; 文字 で区切ることにより、
複数の変数を定義する手法も見ることができる。

この &quot;&amp;&quot; で区切られた変数のリストにおける定義を有効と
するためには、GETメソッドデータの最後の(そして、唯一の)
構成要素でなければならない。<P>

<P>
<A NAME="selmul"><STRONG><TT>SELECT MULTIPLE</TT> と PHP</STRONG></A><P>
<P>
HTML における SELECT MULTIPLE タグはリストから複数の項目を選択可能にする。
これらの項目はフォームのアクションハンドラに渡される。
問題は、全て同じウイジェット名でそれらが渡されることである。
すなわち、<P>
<PRE>    &lt;SELECT NAME=&quot;var&quot; MULTIPLE&gt;</PRE>
<P>
選択されたオプションの各々は、アクションハンドラに次のような形式で
送られる。:<P>
<P>
var=option1<BR>
var=option2<BR>
var=option3<P>
<P>

各々のオプションは、以前の $var 変数の内容を上書きするであろう。
解決策は、PHP/FI の添字無配列機能を用いることである。
次のような記述を行なう必要がある。:<P>

<P>
<PRE>    &lt;SELECT NAME=&quot;var[]&quot; MULTIPLE&gt;</PRE><P>
<P>

これは、PHP/FI に対して <EM>var</EM> を配列として取り扱うように
宣言するものである。
オプションの各々の値の割付けはこの配列 var[] へ要素を付加すること　
により行なわれる。

<P>

最初の項目は、$var[0]、次は $var[1] 等となる。
選択されたオプションの数を定義するために
関数 <A HREF="#count">count()</A> を用いることができる。
また、必要ならばオプション配列をソートするために 関数<A HREF="#sort">sort()</A>
を用いることができる。<P>
<HR>
<A NAME="imagecoord"><STRONG><TT>イメージによる投稿</TT> と PHP</STRONG></A><P>
<P>
フォームを投稿する時、通常の投稿(submit)ボタンの代わりに
次のようなタグによりイメージを用いることが可能である。:<P>
<P>
<PRE>    &lt;input type=image src=image.gif name=sub&gt;</PRE><P>
<P>
ユーザーがイメージのどこかをクリックした時、
<EM>sub_x</EM>と<EM>sub_y</EM>という2つの変数が付加されて
付随するフォームがサーバーに送られる。
この変数はユーザーがイメージ中でクリックした座標を保持している。
経験ある者は、
ブラウザから送られる実際の変数名はアンダースコアの代わりにピリオドとなる
(sub.x,sub.y)というかもしれない。
しかし、PHP はこのピリオドを自動的にアンダースコアに変換する。
<P>

<HR><H2>
<A NAME="relative">
相対URLと絶対URL もしくは、なぜイメージファイルが表示されないのか?</A></H2>
<P>全てのCGIラッパーに共通な問題の一つは、HTTPDプログラムがカレントディレクトリを
ロードしているものが保存されているディレクトリに変えてしまうことである。
CGIプログラムの場合は、カレントディレクトリはCGIプログラムが置かれたディレクトリに
セットされる。
このことは相対URL指定を受けた場合を除き通常問題とならない。<P>
<P>
相対URLは、
カレントディレクトリが現在処理中のHTMLファイルが置かれているディレクトリと
同じであることを前提としたURLである。
つまり、例えば以下のようなURLがあったとする。:<P>
<P>
<PRE>    http://my.machine/~rasmus/file.html</PRE><P>
<P>
実際のHTMLファイルは以下の場所にある。:<P>
<P>
<PRE>    ~rasmus/public_html/file.html</PRE><P>
<P>
仮にファイル <TT>file.html</TT>中に次のようなタグがあったとする。:<P>
<P>
<PRE>    &lt;IMG SRC=&quot;pic.gif&quot;&gt;</PRE><P>
<P>
正常に読み込まれた場合、この gif ファイルは
<TT>~rasmus/public_html/pic.gif</TT> にあると想定される。
しかし、次のようなURLのファイルがCGIラッパー経由で読み込まれたとすると、
<P>
<PRE>    http://my.machine/cgi-bin/php.cgi/~rasmus/file.html</PRE><P>
<P>
HTTPD はカレントディレクトリを <TT>/cgi-bin</TT> に
(あるいは、ScriptAlias で指定した場所に)セットする。:<P>
続いてこのページが読み込まれる際に、<TT>pic.gif</TT> ファイルは
<TT>/cgi-bin/pic.gif</TT> にあるものと想定されるが、
これは通常望んだ結果ではない。<P>
<P>
この問題の手っ取り早い解決手段は絶対URLを使うことである。
上記の例においてimageタグが次のようなものであった場合には、
何の問題も生じなかったであろう。:<P>
<PRE>    &lt;IMG SRC=&quot;/~rasmus/pic.gif&quot;&gt;</PRE>
<P>
絶対URLの使用は、ポータビリティを悪化させるため、
いつも望ましいわけではない。

この問題に関して次のような明白な疑問を生じるかもしれない。
「なぜ、PHP は正しい場所にカレントディレクトリを変えないのか?」

実際にはPHPはカレントディレクトリを表示中の HTML ファイルが
ある場所に変えている、というのが答えである。

PHP スクリプトタグ中で用いられるあらゆるファイルパスは
相対表現とすることができる。

問題は、PHP による制御の範囲外にある
&lt;img &gt; や &lt;a href &gt; のようなタグは、
PHP により処理されないということである。

これらが解釈される時、PHP はもはやアクティブではなく、
カレント作業ディレクトリはHTTP デーモンにより指定された
ディレクトリに戻されている。<P>
<P>
<STRONG>解決手段</STRONG> は妥協策である。PHP は
<STRONG>PATH_DIR</STRONG>という変数を提供する。
これは、現在処理中の HTML ファイルのディレクトリ部を常に保持している。
この PATH_DIR 変数を  &lt;img &gt; や &lt;a href &gt; タグ
に用いた場合、
サーバーが解釈する際には絶対URLのように見えるにもかかわらず、
相対URL を用いた場合と同様の効果が得られる。

上記の例において必要な変更点は img タグを次のように
変えることだけである。:
<PRE>    &lt;IMG SRC=&quot;&lt;?echo $PATH_DIR&gt;/pic.gif&quot;&gt;</PRE>

上記タグの使用により、このタグを含むファイルを移動することが
可能になる。
このタグは常に同じディレクトリにある<TT>pic.gif</TT> ファイルを
HTML ソースファイルとして参照する。<P>
<P>
この問題に対する伝統的な別の解決策は、
&lt;BASE HREF=...&gt; タグをHTMLファイル中に
用いることである。
<P>

<HR>

<H2><A NAME="gd_support">GD (GIF生成のためのグラフィックライブラリ)のPHPでのサポ
ート</A></H2>

PHPは、 Thomas Boutell氏が作成したGDバージョン1.2をサポートする。ただし、
PHPのパッケージにはGDのコードは含まれない。従って、PHPで、GDを使いたければ、
最初に、<A HREF="http://www.boutell.com/gd/gd1.2.tar.Z">
http://www.boutell.com/gd/gd1.2.tar.Z</A>を入手し、インストールした後、
再度、PHPをインストールする。

<P>
PHPはGDの全ての機能をサポートしない。PHPで利用できるGDの関数は、（後の）
アルファベット順の関数リストに示してある。ここで使える全てのGD関数は、
<EM>Image</EM> という単語で始まる。
GDについて、さらに詳細が知りたければ下記にアクセスの事。
<A HREF="http://www.boutell.com/gd/">http://www.boutell.com/gd/</A>


<P>
<EM>GD 1.2 is copyright 1994, 1995 Quest Protein Database Center, Cold Springs 
Harbor Labs.</EM>
<P>

<HR>

<H2><A NAME="virtual_hosts">PHP/FI と仮想ホスト</A></H2>

PHPは数種のHTTPサーバがサポートする仮想ホスト環境でも不都合なく動作する。
ひとつの問題は、仮想ホスト環境上ではHTTPDサーバが設定する環境変数
SCRIPT_NAME と矛盾を引き起こすかもしれない事である。
SCRIPT_NAME には、通常 HTTP サーバにおけるトップレベルルートディレクトリ
ROOT_DIR から相対的に CGIプログラム のあるパスが設定される。
しかしながら、仮想ホストを利用する場合、いくつかの HTTP サーバは
その仮想ホストの正しいトップレベルディレクトリからの相対パスとして
正確な SCRIPT_NAME 変数を設定することが出来ない。
もし、?configで出力されるメッセージに、Invalid URL
というエラーがあれば、PHPのセットアップに問題があったことになる。
その場合は、php.hというファイル中を編集し、#define VIRTUAL_PATH で
定義されるパスを仮想ホストのトップレベルディレクトリから php.cgi
への相対パスにセットする必要がある。
<P>

<HR>

<H2><A NAME="upload">ファイルアップロード</A></H2>
<P>
PHP/FIは、ブラウザーからのファイルアップロードを自動的に検知する。
この機能は、フォームベースのファイルアップロード機能で、
Xerox の <A HREF="mailto:nebel@xsoft.sd.xerox.com">E. Nebel</A>
と <A HREF="mailto:masinter@parc.xerox.com">L. Masinter</A> により
提案された。
詳細は、<A HREF="ftp://ds.internic.net/rfc/rfc1867.txt">RFC 1867</A>
による。<P>

ファイルをアップロードする画面は、下記のような特別なフォームを記述する
事で実現出来る。
<P>
<BLOCKQUOTE>

    &lt;FORM ENCTYPE="multipart/form-data" ACTION="_URL_" METHOD=POST&gt;

<BR>&lt;INPUT TYPE="hidden" name="MAX_FILE_SIZE" value="1000"&gt;

<BR>Send this file: &lt;INPUT NAME="userfile" TYPE="file"&gt;

<BR>&lt;INPUT TYPE="submit" VALUE="Send File"&gt;

<BR>&lt;/FORM&gt;

</BLOCKQUOTE>
<P>

<P>
_URL_ は、PHPで書かれたHTMLファイルの場所を指す必要がある。
hidden フィールド MAX_FILE_SIZE は、file 入力フィールドの前に
なければならない。
MAX_FILE_SIZEの値は、許容されるファイル容量の最大値をバイト単位で示した
ものである。
受信側のファイルにおいては、支障なくファイルのアップロードを
行うために次の環境変数が定義されている。:<P>

<DL>
<DT><STRONG>$userfile</STRONG>
<DD>
<P>
サーバマシン上に格納されたアップロードファイルの一時的なファイル名。<P>

<DT><STRONG>$userfile_name</STRONG>
<DD>
<P>送り側のオリジナルのファイル名。<P>
    
<DT><STRONG>$userfile_size</STRONG>
<DD>
<P>アップロードされたファイルのバイト容量。<P>
    
<DT><STRONG>$userfile_type</STRONG>
<DD>
<P>ブラウザが生成するファイルの MIME TYPE。例えば、"image/gif"。<P>
   
</DL>
<P>
上記変数のうし、<EM><STRONG>$userfile</STRONG></EM> のファイル名の部分は、
アップロードフォームの NAME フィールドに一致する。
<P>

<P>アップロードされたファイルはサーバのデフォールトの一時的なディレクトリーに
格納される。この場所は、PHP/FIが稼働する環境変数 TMPDIR の設定により
変更出来る。PHP/FI スクリプトの中で PutEnv()関数を使用して設定変更しても
うまくいかない。もしくは、<EM>php.h</EM> を編集し、
<STRONG>UPLOAD_TMPDIR</STRONG> 変数の定義を埋め込むことも可能である。<P>

<P>
アップロードファイルを受け取る PHP/FI スクリプトは、
アップロード時に行ったことを把握するために必要な
論理的手段を用意すべきである。例えば、小さすぎたり、大きすぎたりした
任意のファイルを破棄するために $file_size という変数を使用できる。
また、$file_type という変数を使って、正しくない型のファイルを破棄する
ことも可能である。
どのような論理的手段を用いた場合でも、アップロードされたファイルは
一時的なディレクトリから消すか他の場所へ移動すべきである。<P>

<P>
CERN HTTPD は、クライアントから送られたファイルの content-type mime
ヘッダーにおいて空白文字で始まる行を全て削除するということに注意されたい。
この様な仕様である限り、CERN HTTPD においてファイルアップロード機能はサポート
されないであろう。<P>

<HR>
<H2><A NAME="cookies">クッキー(Cookie)のサポート</A></H2>
<P>PHP/FI は
<A HREF="http://www.netscape.com/newsref/std/cookie_spec.html">Netscape's Spec</A>
に定義される HTTP クッキーを透過的にサポートする。
クッキーは、リモートブラウザにデータを保持する仕組みである。
これにより、再訪したユーザーの追跡や特定を行なう。
<A HREF="#setcookie">SetCookie()</A> 関数を用いて、クッキーをセットすることができる。
クッキーはHTTPヘッダーの一部であるので、
SetCookie() 関数は他の出力がブラウザに送られる前に呼ばれなければならない。
この制約は Header() 関数と同様のものである。<P>
クライアントからサーバーに送られるクッキーは、
GET や POST メソッドによるデータと全く同様に
自動的にPHP/FI 変数へ変換される。<P>
<P>一つのクッキーに複数の変数を割り付けたい場合には、
クッキーの名前に <b>[]</b> を加えるだけで良い。
例えば、:<P>
<PRE>    SetCookie("MyCookie[]","Rasmus Lerdorf", time()+3600);</PRE>

パスやドメイン名が異なっていない場合には、
クッキーはブラウザにおける同じ名前の以前のクッキーを置き換える。
ショッピングカートのアプリケーションにおいては、
カウンタとカートに入れられたものを保持したいと思うだろう。
すなわち、<P>
<PRE>    
    $Count++;
    SetCookie("Count",$Count, time()+3600);
    SetCookie("Cart[$Count]",$item, time()+3600);</PRE>

<HR>
<H2><A NAME="msql_support">mSQL サポート</A></H2>
<P>mini-SQL を意味する mSQL は、David Hughes により作られた
小型でかつ簡易な SQL データベースエンジンである。
この mSQL は、<A HREF="ftp://ftp.bond.edu.au/pub/Minerva/msql">
ftp://ftp.bond.edu.au/pub/Minerva/msql</A>
より入手可能である。<P>
<P>

PHP/FI は多くの mSQL サポート用関数を有している。
<P>
<DL>
<DT><A HREF="#msql">msql()</A>
<DT><A HREF="#msql_close">msql_Close()</A>
<DT><A HREF="#msql_connect">msql_Connect()</A>
<DT><A HREF="#msql_createdb">msql_CreateDB()</A>
<DT><A HREF="#msql_dbname">msql_dbName()</A>
<DT><A HREF="#msql_dropdb">msql_DropDB()</A>
<DT><A HREF="#msql_fieldflags">msql_FieldFlags()</A>
<DT><A HREF="#msql_fieldlen">msql_FieldLen()</A>
<DT><A HREF="#msql_fieldname">msql_FieldName()</A>
<DT><A HREF="#msql_fieldtype">msql_FieldType()</A>
<DT><A HREF="#msql_freeresult">msql_FreeResult()</A>
<DT><A HREF="#msql_listdbs">msql_ListDBs()</A>
<DT><A HREF="#msql_listfields">msql_Listfields()</A>
<DT><A HREF="#msql_listtables">msql_ListTables()</A>
<DT><A HREF="#msql_numfields">msql_NumFields()</A>
<DT><A HREF="#msql_numrows">msql_NumRows()</A>
<DT><A HREF="#msql_regcase">msql_RegCase()</A>
<DT><A HREF="#msql_result">msql_Result()</A>
<DT><A HREF="#msql_tablename">msql_TableName()</A>
</DL>
<P>

これらの関数に加えて、PHP/FI においては
GET もしくは POST データ中の前方引用付( ' )を
自動的にエスケープするようにコンパイルすることができる。

MAGIC_QUOTES 変数を <EM>php.h</EM> ファイル中で定義した場合には、
これらの引用付は自動的にエスケープされるので、
データを直接 msql クエリーに渡すことが容易になる。
<P>

<HR>
<H2><A NAME="pg95_support">Postgres95/PostgreSQL サポート</A></H2>
<P>
Postgres95/PostgreSQL は、SQL 言語の主要部分を実装した強力な public domain の
データベースであり、mSQL において使用できない多くのデータ型とコマンド
をサポートしている。
Postgres についての詳細な情報とソフトウエア自体は次のURLで
見つけることができる。:
<A HREF="http://www.postgreSQL.org/">
http://www.postgreSQL.org/</A><P>
<P>

次の PHP 関数が Postgres95/PostgreSQL 用に使用可能である。:<P>
<DL>
<DT><A HREF="#pg_connect">pg_Connect()</A>
<DT><A HREF="#pg_close">pg_Close()</A>
<DT><A HREF="#pg_host">pg_Host()</A>
<DT><A HREF="#pg_port">pg_Port()</A>
<DT><A HREF="#pg_options">pg_Options()</A>
<DT><A HREF="#pg_tty">pg_tty()</A>
<DT><A HREF="#pg_dbname">pg_DBname()</A>
<DT><A HREF="#pg_exec">pg_Exec()</A>
<DT><A HREF="#pg_result">pg_Result()</A>
<DT><A HREF="#pg_freeresult">pg_FreeResult()</A>
<DT><A HREF="#pg_getlastoid">pg_GetLastOid()</A>
<DT><A HREF="#pg_numrows">pg_NumRows()</A>
<DT><A HREF="#pg_numfields">pg_NumFields()</A>
<DT><A HREF="#pg_fieldnum">pg_FieldNum()</A>
<DT><A HREF="#pg_fieldname">pg_FieldName()</A>
<DT><A HREF="#pg_fieldtype">pg_FieldType()</A>
<DT><A HREF="#pg_fieldsize">pg_FieldSize()</A>
<DT><A HREF="#pg_fieldprtlen">pg_FieldPrtLen()</A>
<DT><A HREF="#pg_errorMessage">pg_errorMessage()</A>
</DL>
<P>

<STRONG>注意:</STRONG> バイナリカーソルはサポートしていない。
<P>
<P>
これらの関数に加えて、PHP/FI においては
GET もしくは POST データ中の前方引用付( ' ) または、引用符( &quot; )を
自動的にエスケープするようにコンパイルすることができる。
MAGIC_QUOTES 変数を <EM>php.h</EM> ファイル中で定義した場合には、
これらの引用付は自動的にエスケープされるので、
データを直接 Postgres クエリーに渡すことが容易になる。<P>
<P>
以下に localhost 上の 'mydb' というPostgres データベースと接続し
テーブル中の人の名前と年齢を引き出す
サンプルスクリプトを示す。:<P>
<P>
<PRE>
&lt;?
   $conn = pg_Connect("localhost", "5432", "", "", "mydb");
   if (!$conn) {
      echo "An error occured.\n";
      exit;
   }

   $result = pg_Exec($conn, "select * from table1");
   if (!$result) {
      echo "An error occured.\n";
      exit;
   }

   $num = pg_NumRows($result);
   $i = 0;

   while ($i &lt; $num) {
      echo "name: ";
      echo pg_Result($result, $i, "name");
      echo "  age: ";
      echo pg_Result($result, $i, "age");
      echo "&lt;BR&gt;";
      $i++;
   }

   pg_FreeResult($result);
   pg_Close($conn);
&gt;
</PRE><P>

<HR>
<H2><A NAME="mysql_support">mysql サポート</A></H2>
<P>mysql は、mSQL パッケージのクローンである。
<A HREF="http://www.tcx.se/">http://www.tcx.se/</A>から
コピーを手にいれることができる。
<P>
<P>
PHP/FI においては、多くの mysql 関数がサポートされる。:
<P>
<DL>
<DT><A HREF="#mysql">mysql()</A>
<DT><A HREF="#mysql_close">mysql_Close()</A>
<DT><A HREF="#mysql_connect">mysql_Connect()</A>
<DT><A HREF="#mysql_createdb">mysql_CreateDB()</A>
<DT><A HREF="#mysql_dbname">mysql_dbName()</A>
<DT><A HREF="#mysql_dropdb">mysql_DropDB()</A>
<DT><A HREF="#mysql_fieldflags">mysql_FieldFlags()</A>
<DT><A HREF="#mysql_fieldlen">mysql_FieldLen()</A>
<DT><A HREF="#mysql_fieldname">mysql_FieldName()</A>
<DT><A HREF="#mysql_fieldtype">mysql_FieldType()</A>
<DT><A HREF="#mysql_freeresult">mysql_FreeResult()</A>
<DT><A HREF="#mysql_listdbs">mysql_ListDBs()</A>
<DT><A HREF="#mysql_listfields">mysql_Listfields()</A>
<DT><A HREF="#mysql_listtables">mysql_ListTables()</A>
<DT><A HREF="#mysql_numfields">mysql_NumFields()</A>
<DT><A HREF="#mysql_numrows">mysql_NumRows()</A>
<DT><A HREF="#mysql_result">mysql_Result()</A>
<DT><A HREF="#mysql_tablename">mysql_TableName()</A>
</DL>
<P>

これらの関数に加えて、GET もしくは POST データに含まれる前方引用符を
自動的にエスケープするようにコンパイルすることが可能である。
MAGIC_QUOTES 変数が、<EM>php.h</EM> ファイルにおいて定義される場合には、
これらの前方引用符は自動的にエスケープされるので、
mysql クエリーに直接データを渡すことが容易になる。
<P>
<HR>
<H2><A NAME="solid_support">Solid サポート</A></H2>
<P>
Solid サーバーは、多機能な SQL サーバーである。ANSI SQL2、ODBC、
SAG CLI、X/Open SQL 標準をサポートする。
Solid サーバーに関するより詳しい情報は、
<A HREF="http://www.solidtech.com/">www.solidtech.com</A>
で手にはいる。
PHP 用 Solid インターフェースは、
<a href="solid.digiface.nl">DigiFace Internet Services</a> により
開発されたものである。
<P>
次のPHP 関数が Solid サーバーについて使用可能である。:<P>
<DL>
<DT><A HREF="#solid_connect">Solid_Connect()</A>
<DT><A HREF="#solid_close">Solid_Close()</A>
<DT><A HREF="#solid_exec">Solid_Exec()</A>
<DT><A HREF="#solid_result">Solid_Result()</A>
<DT><A HREF="#solid_freeresult">Solid_FreeResult()</A>
<DT><A HREF="#solid_numrows">Solid_NumRows()</A>
<DT><A HREF="#solid_numfields">Solid_NumFields()</A>
<DT><A HREF="#solid_fieldnum">Solid_FieldNum()</A>
<DT><A HREF="#solid_fieldname">Solid_FieldName()</A>
</DL>
<P>
これらの関数に加えて、GET もしくは POST データに含まれる前方引用符を
自動的にエスケープするようにコンパイルすることが可能である。
MAGIC_QUOTES 変数が、<EM>php.h</EM> ファイルにおいて定義される場合には、
これらの前方引用符は自動的にエスケープされるので、
Solid クエリーに直接データを渡すことが容易になる。
<P>
以下に、Postgres の節において用いたのと同じ例をSolid サーバー用にした
ものを示す。

<P>
<PRE>
&lt;?
   $conn = Solid_Connect("", "username", "password");
   if (!$conn) {
      echo "An error occured.\n";
      exit;
   }

   $result = Solid_Exec($conn, "select * from table1");
   if (!$result) {
      echo "An error occured.\n";
      exit;
   }

   while (Solid_FetchRow($result)) {
      echo "name: ";
      echo Solid_Result($result, "name");
      echo "  age: ";
      echo Solid_Result($result, "age");
      echo "&lt;BR&gt;";
   }

   Solid_FreeResult($result);
   Solid_Close($conn);
&gt;
</PRE><P>

<HR>
<H2><A NAME="sybase_support">Sybase サポート</A></H2>
サポート関数は、Sybase DB のライブラリ API コールを使用する。
したがって、sybase サポートを有効にして PHP/FI をコンパイルするためには、 
sybase API ライブラリとヘッダーファイルがシステムにインストールされている
必要がある。
<p>
次の PHP/FI 関数がSybase 用に使用可能である。<P>
<DL>
<DT><A HREF="#sybsql_checkconnect">SybSQL_CheckConnect()</A>
<DT><A HREF="#sybsql_connect">SybSQL_Connect()</A>
<DT><A HREF="#sybsql_DBuse">SybSQL_DBuse()</A>
<DT><A HREF="#sybsql_Exit">SybSQL_Exit()</A>
<DT><A HREF="#sybsql_fieldname">SybSQL_Fieldname()</A>
<DT><A HREF="#sybsql_getfield">SybSQL_GetField()</A>
<DT><A HREF="#sybsql_isrow">SybSQL_IsRow()</A>
<DT><A HREF="#sybsql_nextrow">SybSQL_NextRow()</A>
<DT><A HREF="#sybsql_numfields">SybSQL_NumFields()</A>
<DT><A HREF="#sybsql_numrows">SybSQL_NumRows()</A>
<DT><A HREF="#sybsql_query">SybSQL_Query()</A>
<DT><A HREF="#sybsql_result">SybSQL_Result()</A>
<DT><A HREF="#sybsql_result_all">SybSQL_Result_All()</A>
<DT><A HREF="#sybsql_seek">SybSQL_Seek()</A>
</DL><P>
完全な例については、以降の例 <A HREF="#sybsql_result">sybSQL_Result()</A>
関数を参照のこと。<P>

<H2><A NAME="oracle_support">Oracle サポート</A></H2>
Oracle 用 PHP/FI インターフェースは、Oracle Call Interface (OCI)
を使用する。
PHP/FI をOracle サポート付きでコンパイルするためには、
システム上に OCI ライブラリが必要である。
<P>
次の PHP/FI 関数が Oracle 用に利用可能である。<P>
<DL>
<DT><A HREF="#ora_bind">Ora_Bind()</A>
<DT><A HREF="#ora_close">Ora_Close()</A>
<DT><A HREF="#ora_commit">Ora_Commit()</A>
<DT><A HREF="#ora_commitoff">Ora_CommitOff()</A>
<DT><A HREF="#ora_commiton">Ora_CommitOn()</A>
<DT><A HREF="#ora_exec">Ora_Exec()</A>
<DT><A HREF="#ora_fetch">Ora_Fetch()</A>
<DT><A HREF="#ora_getcolumn">Ora_GetColumn()</A>
<DT><A HREF="#ora_logoff">Ora_Logoff()</A>
<DT><A HREF="#ora_logon">Ora_Logon()</A>
<DT><A HREF="#ora_open">Ora_Open()</A>
<DT><A HREF="#ora_parse">Ora_Parse()</A>
<DT><A HREF="#ora_rollback">Ora_Rollback()</A>
</DL><P>
PHP/FI Oracle アプリケーションの例を次に示す。
<PRE>
&lt;?
PutEnv(&quot;ORACLE_HOME=path_to_your_oracle_home&quot;
PutEnv(&quot;ORACLE_SID=database&quot;
  
/* Establish a connection between PHP and Oracle. */
$conn = Ora_Logon(&quot;username&quot; &quot;password&quot;
  
if ($conn &lt; 0) {
    echo(&quot;Could not connect to Oracle.\n&quot;
    exit;
}

/* Open a cursor in Oracle. */
$cursor = Ora_Open($conn);

if ($cursor &lt; 0) {
    echo(&quot;Could not open a cursor.\n&quot;
    Ora_Logoff($conn);
    exit;
}

/* Turn off autocommit. */
Ora_CommitOff($conn);

/* This is the SQL query. */
$query = &quot;SELECT * FROM some_table&quot;

if (Ora_Parse($cursor, $query) &lt; 0) {
    echo(&quot;Parse failed!\n&quot;
    Ora_Logoff($conn);
    exit;
}

/* Execute the SQL statement associated with $cursor and
   prepare storage for select-list items. */
$ncols = Ora_Exec($cursor);
 
echo &quot;lt;P&gt;\n&quot;
echo &quot;lt;TABLE BORDER=1 CELLSPACING=0&gt;\n&quot;

/*  Retrieve all rows from the database one after another. */
while (Ora_Fetch($cursor) == 1) {
    $i = 0;
    echo &quot;lt;TR&gt;\n&quot;
    while ($i &lt; $ncols) {
     /* Get data for a single column of currently fetched row. */
     $col = Ora_GetColumn($cursor, $i);
        echo(&quot;lt;TD&gt;$col&lt;/TD&gt;\n&quot;
     $i++;
    }
    echo(&quot;lt;/TR&gt;\n&quot;
}

echo &quot;&lt;/TABLE&gt;\n&quot;;

/* Close the Oracle connection. */
Ora_Close($cursor);
 
/* Disconnect the logon data area. */
Ora_Logoff($conn);
&gt;
</PRE>
<P>
<HR>
<H2><A NAME="illustra_support">Informix Illustra サポート</A></H2>
<P>

Illustra はInfomix により買収されたデータベース製品である。
幾つかの機能は、本インターフェースで(まだ)サポートされていない。
Illustra の優れた主な特徴は、オブジェクト指向により拡張可能な
オブジェクトリレーショナルデータベースであることである。
例えば、データベース内に基本型としてイメージ型を作成することが可能である。
より、詳しいｊ情報は、
<A HREF="http://www.illustra.com/">illustra ホームページ</A>
より得ることができる。
<P>
<P>
次の PHP 関数が Illustra 用に利用可能である。:<P>
<DL>
<DT><A HREF="#mi_connect">mi_Connect()</A>
<DT><A HREF="#mi_close">mi_Close()</A>
<DT><A HREF="#mi_dbname">mi_DBname()</A>
<DT><A HREF="#mi_exec">mi_Exec()</A>
<DT><A HREF="#mi_result">mi_Result()</A>
<DT><A HREF="#mi_numrows">mi_NumRows()</A>
<DT><A HREF="#mi_numfields">mi_NumFields()</A>
<DT><A HREF="#mi_fieldnum">mi_FieldNum()</A>
<DT><A HREF="#mi_fieldname">mi_FieldName()</A>
</DL>
<P>
<STRONG>注意:</STRONG> 型の演算は、まだサポートされていない。
<P>
<P>
以下にローカルホストの 'mydb' という名前の illustra データベースに接続し、
テーブルから人の名前と年齢を得るスクリプトを示す。:<P>
<P>
<PRE>
&lt;?
   $conn = mi_Connect("mydb", "username", "password");
   if ($conn&lt;0) {
      echo "An error occured on connection.\n";
      exit;
   }

   $result = mi_Exec($conn, "select * from table1");
   if ($result &lt; 0) {
      echo "An error occured.\n";
      exit;
   }

   $num = mi_NumRows($result);
   $i = 0;

   while ($i &lt; $num) {
      echo "name: ";
      echo mi_Result($result, $i, "name");
      echo "  age: ";
      echo mi_Result($result, $i, "age");
      echo "&lt;BR&gt;";
      $i++;
   }

   mi_Close($conn);
&gt;
</PRE><P>
<HR>
<H2><A NAME="adabas_support">Adabas サポート</A></H2>
<P>
Adabas D は、多くのプラットフォームで利用可能な先進的 RDBMS である。
パーソナル版という名前の特別なバージョンは、
Linux用と Win32用のものが無償で手に入る。
この版は、同時5ユーザーと100MBのデータに制限されている。
Adabas D に関する更に詳しい情報は、
<A HREF="http://www.softwareag.com">http://www.softwareag.com</A>を
参照されたい。
<P>
次の PHP 関数が、Adabas データベースにアクセスするために
利用可能である。:<P>
<DL>
<DT><A HREF="#ada_connect">Ada_Connect()</A>
<DT><A HREF="#ada_close">Ada_Close()</A>
<DT><A HREF="#ada_exec">Ada_Exec()</A>
<DT><A HREF="#ada_result">Ada_Result()</A>
<DT><A HREF="#ada_resultall">Ada_ResultAll()</A>
<DT><A HREF="#ada_freeresult">Ada_FreeResult()</A>
<DT><A HREF="#ada_numrows">Ada_NumRows()</A>
<DT><A HREF="#ada_numfields">Ada_NumFields()</A>
<DT><A HREF="#ada_numrows">Ada_NumRows()</A>
<DT><A HREF="#ada_numfields">Ada_NumFields()</A>
<DT><A HREF="#ada_fieldnum">Ada_FieldNum()</A>
<DT><A HREF="#ada_fieldname">Ada_FieldName()</A>
<DT><A HREF="#ada_fieldtype">Ada_FieldType()</A>
</DL>
以下に Postgres と Solid の節で示したのと同じスクリプトを
Adabas D 用に修正したものを示す。
<P>
<PRE>
&lt;?
   $conn = Ada_Connect("node:db", "username", "password");
   if (!$conn) {
      echo "An error occured.\n";
      exit;
   }

   $result = Ada_Exec($conn, "select * from table1");
   if (!$result) {
      echo "An error occured.\n";
      exit;
   }

   while (Ada_FetchRow($result)) {
      echo "name: ";
      echo Ada_Result($result, "name");
      echo "  age: ";
      echo Ada_Result($result, "age");
      echo "&lt;BR&gt;";
   }

   Ada_FreeResult($result);
   Ada_Close($conn);
&gt;
</PRE><P>

<HR>
<H2><A NAME="regexp">正規表現</A></H2>
<P>
正規表現は PHP/FI において複雑な文字列操作に用いられる。
次の関数を通じてスクリプトインターフェイスは正規表現をサポートしている:<BR>

<A HREF="#ereg">EReg()</A>,
<A HREF="#eregi">ERegi()</A>,
<A HREF="#ereg_replace">EReg_Replace()</A>,
<A HREF="#eregi_replace">ERegi_Replace()</A>,
<A HREF="#reg_match">Reg_Match()</A>,
<A HREF="#reg_replace">Reg_Replace()</A>, 
<A HREF="#reg_search">Reg_Search()</A>
<br>

全ての関数に対する最初の引数(argument)は正規表現文字列である。
EReg 関数は POSIX 1003.2 で定義された Posix 拡張正規表現を使っている。
一方、 Reg 関数は基本的な正規表現を実装している。
正規表現についての詳細は、man の regex(7) を参照のこと。
このページが無い場合には、Henry Spencer により書かれた regex(7) の
man ページが PHP/FI ディストリビューションの src/regex ディレクトリにある。
システム管理者にこの man ページをインストールするように頼むこと。<P>

正規表現とその動作についての例を以下に挙げる。<p>

<blockquote>
<dl>
<dt><tt>ereg("abc",$string);</tt>
<dd> $string の中で &quot;abc&quot を見つければ真( true ) を返す。<P>
<dt><tt>ereg("^abc",$string);</tt>
<dd> $string の最初に &quot;abc&quot を見つければ真( true ) を返す。<P>
<dt><tt>ereg("abc$",$string);</tt>
<dd> $string の終わりに &quot;abc&quot を見つければ真( true ) を返す。<P>
<dt><tt>eregi("(ozilla.[23]|MSIE.3)",$HTTP_USER_AGENT);</tt>
<dd>クライアントのブラウザがNetscape 2, 3 あるいは MSIE 3であれば真( true ) を返す。<P>
<dt><tt>ereg("([[:alnum:]]+) ([[:alnum:]]+) ([[:alnum:]]+)",$string,$regs);</tt><br>
<dd>空白で分離される3つの単語を $regs[1], $regs[2] と $regs[3] に代入する。<P>
<dt><tt>ereg_replace("^","&lt;BR&gt;",$string)</tt>
<dd>$string の始めに &lt;BR&gt; タグを入れる。<P>
<dt><tt>ereg_replace("$","&lt;BR&gt;",$string)</tt>
<dd>$string の終わりに &lt;BR&gt; タグを入れる。<P>
<dt><tt>ereg_replace(10,"",$string);</tt>
<dd>$string の中の全ての復改文字( LF )を取り除く。<P>
<dt><tt>ereg_replace(13,"&lt;BR&gt;",$string);</tt>
<dd>$string の中の全ての改行文字( CR )を &lt;BR&gt; tag で置き換える。<P>
</dl>
</blockquote>

<HR>
<H2><A NAME="escapes">エスケープ キャラクター</A></H2>
<P>
次のエスケープシークエンスは前方引用符で囲われた文字列引数が
使われるほとんどのところでサポートされている。<BR>

<blockquote>
<pre>	\a --&gt; bell(ベル)
 	\b --&gt; backspace(バックスペース)
 	\n --&gt; linefeed(ラインフィード)
 	\r --&gt; carriage return(改行)
 	\t --&gt; tab(タブ)
 	\nnn --&gt; octal char（8進数を表現する文字）
 	\xXX --&gt; （16進数を表現する文字）</pre>
</blockquote><P>

<HR>
<H2><A NAME="octal">UNIX ファイル許可属性の8進表記</a></H2>
<P>
PHP/FI スクリプト言語のいくつかの関数は、UNIX 形式の許可属性パラメータを
定義するために8進表記を要求する。
この8進表記においては、0-7の値を表わすために3ビットが用いられる。
3つの各ビットは、特定の許可属性を表わす。 
8進数は、従来より 0755 のように 0で始まる数で記述されてきた。
PHP においては、
8進数パラメータを要求する関数はパラメータが8進数であると単純に仮定するので、
この先頭の 0 は必要ない。
しかし、先頭に 0 を付けることは、10進数を処理していないことを自覚するため
の良い練習となる。
<P><B>ビット表記</B>
<PRE>    xxx
    ^^^
    ||+----1 bit (実行許可)
    |+-----2 bit (書き込み許可)
    +------4 bit (読み出し許可r)</PRE>

これらの3ビットは、所有者、グループ、全ての人に関して3回繰り返される。
つまり、0755 は以下を意味する。

<PRE>    owner: r,w,x
    group: r, ,x
    world: r, ,x</PRE>

ディレクトリの実行ビットは、'アクセス'を意味し、'実行'を意味しないことに
注意されたい。
0?755 のような4番目の8進数ニブル(半ワード)に拡張ビットも存在する。
つまり、
<PRE>    4: suid ビット   (userid をセット)
    2: sgid ビット   (グループ id をセット)
    1: sticky ビット (あるディレクトリにおいてその所有者のみが、ファイルを消去できる。)</PRE>
<P>
<HR>
<H2><A NAME="script">PHP/FI スクリプト言語</A></H2>

<P>
PHP スクリプト言語は多くの場合 C 言語の構文に似ている。
変数、配列、関数の呼び出し、異なる変数の型、そして cgi プログラムを
書くために必要なほとんどのものがサポートされている。

<P>
各々の PHP/FI 関数は次項で説明されている。
各関数の説明にはその名前でタグが付けてあるので、
このドキュメントの URL に #関数名 を付加することにより
容易に見つけることが可能であろう。

<P>
<H3><A NAME="syntax">構文</A></H3>

<P>
それぞれの PHP 命令は <PRE><?</PRE> で始り、
<PRE>></PRE> で終わる。
あるいは、PHP 命令を一組の <PRE><? ></PRE> によりグループ化し、
<PRE>;</PRE> 文字で分割しても良い。
<P>

<P>
変数はサポートされており、変数名の前に <STRONG>$</STRONG> を
付けることにより定義される。
例えば、変数に 5 をセットし、それからこの変数を表示するには
次のように書くのが正しい書き方である。
<P>
<P>
<PRE>	&lt;?$a = 5&gt;
	&lt;?echo $a&gt;</PRE><P>
<P>
以下のように書いても同じである。<P>
<P>
<PRE>	&lt?; $a = 5; echo $a &gt;</PRE>
<P>
また、これも同じ意味である。<P>
<P>
<PRE>	&lt?;
	$a = 5;
	echo $a;
	&gt;</PRE><P>
<P>
スペース、タブや改行のような余分な空白文字は無視される。
このため、PHP スクリプトのブロックをフォーマットして
読みやすくする為に空白文字を用いることができる。
変数においては大文字小文字は区別されるが、関数の呼び出しに
おいては区別されない。
後述する関数の概要において、大文字小文字の区別は関数名を読みやすくする
為だけに使われている。
実際のスクリプトにおいては、大文字、小文字の好きな方を用いて良い。
<P>

<P>
コメントもサポートされている。コメントは C 言語のコメントと全く同様に書くことが出来る。 <PRE>/*</PRE> で始り、 <PRE>*/</PRE> でコメントを終わる。コメントは <PRE><? ...></PRE> ブロックの中のどこに置いても構わない。

<HR>
<H3><A NAME="vars">変数</A></H3>

<P>
3種類の変数がサポートされている。
すなわち、<STRONG>ロング整数型</STRONG>、<STRONG>倍精度浮動小数型</STRONG>、
<STRONG>文字列型</STRONG>である。
これらは自動的に検出される。例えば、:

<P>
<PRE>	&lt;?$a = 5&gt;</PRE><P>
<P>
ここで $a はロング整数型の変数である。<P>

<P>
<PRE>	&lt;?$a = 5.0&gt;</PRE><P>
<P>
この時、$a は倍精度実数型である<P>

<P>
<PRE>	&lt;?$a = "5"&gt;</PRE><P>
<P>
この時、$a は文字列型である。<P>

<P>
変数の型はあまり重要ではない。あらゆる変数はその型にかかわらず内部で
すべて3つの型に変換され、様々な関数は正しい型を使おうとする。
2,3の関数だけが変数の型に影響される。<P>

3つの変数型はその名前に <STRONG>[値]</STRONG>を付けることで
すべて配列として扱うことも出来る。
C 言語とは異なり、それらは Perl で使うのと同様に実際には連想配列である。
次のように書くのが正しい:<P>
<P>
<PRE>	&lt;?
	  $a[0] = 5;
	  $a["hello"] = 6;
	  echo $a[0];
	  echo $a["hello"];
	&gt;
</PRE>
<P>

<P>
以下の点に注意すること。
ある変数名が配列と普通の変数と両方で使われる場合には、
普通の変数は配列中では添字"0"の要素を登録することと同じ事を意味する。

例えば、<P>
<P>
<PRE>    $a = 1;</PRE><P>
<P>
は次のように書かれるのと同じである。<P>
<P>
<PRE>    $a[0] = 1;</PRE><P>

<P>
PHP/FI は添字無し配列もサポートしている。
添字無し配列においては、要素が追加された時に独自に添字が作成される。
例えば、:<P>
<P>
<PRE>    $a[] = "Hello";
    $a[] = "There";</PRE><P>
    <P>

<P>
添字無し配列に代入された最初の要素は、常に添字 0 を割り当てられる。
2番目は添字 1 である。よって、先の要素は次のように出力される。<P>
<P>
  <PRE>    echo $a[0];
     echo $a[1];
  </PRE><P>
配列は、簡単な割り付けによりコピーすることができる。
$b が配列である場合、次のように入力することにより、
全ての値を $a という名前の新しい配列にコピーすることができる。:<P>
<PRE>    $a = $b;</PRE><P>
<P>PHP は変数を使用する前にその変数を定義することを強制しない
というのは、必ずしも望ましいことではない。
上記の命令において、$b が未定義の場合、$a は空の文字列(&quot;&quot;)
にセットされる。</P>
<P>
追加されるのが配列であることを示すために [] 記法も用いられる。
$a と $b が共に配列である場合に、次のように入力することにより、
$b を $a に追加することができる。:<P>
<PRE>    $a[] = $b;</PRE><P>
<P>
上の例では、連想配列と通常の番号をふられた配列の間に差が生じる。
番号をふられた配列の場合は、$b からの全ての要素が $a からの元の要素に
続くように番号がふりなおされる。
一方、連想配列においては $b の要素は、$a の要素に取り込まれる。
$a に既に存在する全ての要素(同じ項目名を有する項目)は、
$b の要素で上書きされる。<P>
配列の要素数を定義するために <A HREF="#count">count()</A> 関数
を使うことが出来る。<P>

<P>
言語の本質的な事実でもあるが、変数の型はある基本的な動作が
どのように実行されるかで決められる。例えば、:<P>
<P>
<PRE>    $a = $b + $c;</PRE><P>
<P>
は一連の異なった操作を行なう。$b が数字である場合には、数値 $c は
$b に加算され、合計が $a に代入される。この場合、$c の型は動作に
無関係である。
操作は最初の変数の型で支配される。$b が文字列ならば、文字列として $c の値が
$b に加えられ、最終的な文字列が $a に代入される。
これらの処理においてはいくつか注意すべき点がある。
これらの処理についてより深く理解するには、
<A HREF="#overload">演算子の多重定義</A>の項を参照のこと。<P>

<HR>
<H3><A NAME="assoc">連想配列</A></H3>
<P>
先ほどのセクションで連想配列を紹介した。連想配列は添字が連続した
数値である必要の無い配列である。
配列の添字はいかなる数でも文字でも良い。
PHP/FI はこれらの連想配列を上手く処理するために一連の関数を用意している。
その中には <A HREF="#next">Next()</A>、 <A HREF="#prev">Prev()</A>、
<A HREF="#reset">Reset()</A>、 <A HREF="#end">End()</A>、
<A HREF="#key">Key()</A>を含む。<P>

<HR>
<H3><A NAME="varvars">可変変数</A></H3>
<P>
可変変数名を使う事が便利な時がある。それは、宣言し使われている変数名が
動的に扱われるときである。通常の変数は次のように宣言される。<P>
<P>
<PRE>    $a = "hello";</PRE><P>
<P>
可変変数は変数の値を持ち、さらに変数名としても扱われる。
上の例では、<STRONG>hello</STRONG> は2つの $ を使って変数名と
しても使う事が出来る。例えば、<P>
<P>
<PRE>    $$a = "world";</PRE><P>
<P>
この時2つの変数が定義され、 PHP/FI のシンボルツリーに保存されている。<P>
<P>
<PRE>    Variable Name        Variable Content
         <EM>a</EM>                   <EM>hello</EM>
         <EM>hello</EM>               <EM>world</EM></PRE><P>
<P>
さらにこの文は<P>
<P>
<PRE>    echo "$a $$a";</PRE><P>
<P>
以下とまったく同じ出力をする。<P>
<P>
<PRE>    echo "$a $hello";</PRE><P>
<P>
すなわち、両方とも次のように出力される。 : <STRONG>hello world</STRONG><P>

<HR>
<H3><A NAME="lang">言語構造</A></H3>
<P>
言語構造に関する限り、 PHP 言語は非常に単純である。
次のコマンドはファイルの中で制御フローを導くのに使われている。<P>
<P>
<UL>
	<LI>if (condition)
	<LI>else
	<LI>elseif (condition)
	<LI>endif
	<LI>switch(expression)
	<LI>case expression
	<LI>default
	<LI>break
	<LI>endswitch
	<LI>while
	<LI>endwhile
	<LI>include
	<LI>exit
</UL><P>
条件構文は C 言語と似ている。
<STRONG>==</STRONG> は等しいことをテストする。
<STRONG>!=</STRONG> は等しくないことを表わす。
また次のものもサポートしている。
<STRONG>&gt;</STRONG>、 <STRONG>&lt;</STRONG>、
<STRONG>&gt;=</STRONG>、<STRONG>&lt;=</STRONG>。条件の積 (AND) は 
<STRONG>&&</STRONG>、 条件の和 (OR) は <STRONG>||</STRONG>である。<P>
例えば、
<P>
<PRE>    &lt;?
      if($a==5 &&  $b!=0 );
        $c = 100 + $a / $b;
      endif;
    &gt;</PRE><P>
<P>上の例は以下のように標準的な C の構文で書くこともできる。<BR>
この場合、閉じるのに使われている大括弧の後のセミコロンは必要ない。
<P>
<PRE>    &lt;?
      if($a==5 && $b!=0) {
          $c = 100 + $a / $b;
      }
    &gt;</PRE><P>
	<P>
2つの構文に違いはない。私は個人的に endif、 endswitch や endwhile を
使うのが好きなので、閉じる時には常に自明な方法を用いる。
しかし、これらの閉じるための構造を大括弧で置き換えることも出来る。
<P><P>

<P>
以下の点に注意すること。
言語処理の流れは、コードの中のスクリプトブロックの形態に依存していない。
1つのブロックの中で if で始まり、他の表現で終わることも出来る。例えば、<P>
<P>
<PRE>	&lt;?if($a==5 &&  $b!=0)>
		  &lt;b&gt;Normal html text&lt;/b&gt;
	&lt;?endif&gt;</PRE><P>
<P>この例では閉じる大括弧の代わりに <TT>endif</TT> を使うことが非常に
好ましい時がある事が容易に理解できる。上の例は次の例よりはるかに読みやすい。<P>
<P>
<PRE>	&lt;?if($a==5 &&  $b!=0) {>
		  &lt;b&gt;Normal html text&lt;/b&gt;
	&lt;? } &gt;</PRE><P>
<P>どちらの例も正しく、同じ事を行う。<P>
<HR>
<H3><A NAME="user_funcs">ユーザ定義関数</A></H3>

<P>次の文章のように PHP スクリプト中で関数を定義出来る。<P>

<PRE>    &lt;?
      Function Test (
        echo "This is a test\n";
      );
    &gt;</PRE><P>
<P>
この関数は定義した後ではスクリプト中のどこででも呼び出すことが出来る。
例えば、<P>
<P>
<PRE>    &lt;?
      Test();
    &gt;</PRE><P>
<P>
この様なユーザが定義した関数は、PHP の内部関数と全く同じように働く。
内部関数と同様に、関数に引数を渡し関数から値を返す事が可能である。
以下は 3つの引数を取り、それらの引数の合計を返す関数の定義である。<P>
<P>
<PRE>    &lt;?
      Function Sum $a,$b,$c (
        return($a+$b+$c);
      );

      echo Sum($a,$b,$c);
    &gt;</PRE><P>
<EM>return</EM> は関数から一つの値を返すのに使われる。
この方法により返すことができる値は一つだけである。
メインコードと関数の間でより多くの値を受け渡す必要がある場合には、
グローバル変数を用いることができる。
このことに関しては次項の「変数の範囲」でも説明する。<P>

<HR>
<H3><A NAME="scope">変数の範囲</A></H3>
<P>
変数の範囲はそれが定義されている文脈の中である。
大部分の PHP/FI の変数は単一の範囲を持つだけである。
しかし、ユーザ定義関数の中では、ローカルな関数範囲が使われる。
関数の内部で使われる変数はデフォルトでローカルな関数範囲に制限されている。
例えば、<P>
<P>
<PRE>    $a=1; /* global scope */
    Function Test (
      echo $a; /* reference to local scope variable */
    );
    Test();</PRE><P>

このスクリプトは全く出力をしないであろう。これは、<EM>echo</EM> 文が 
<EM>$a</EM> 変数のローカル版を参照しており、この範囲内では値が
割り付けられていないためである。

C 言語においては、ローカル変数の定義により上書きされない限り
グローバル変数を関数内部において自動的に使用することができる。
しかし、上記の動作はこれとやや異なっているということに必要である。
この方法では、
グローバル変数の値が誤って変更されるという問題を生じる可能性がある。
PHP/FI においては、関数で使用される全てのグローバル変数は
関数の内部で global として宣言されなかればならない。
例えば、<P>
<P>
<PRE>    $a=1;
    $b=2;
    Function Sum $first,$second (
      global $a,$b;

      $b = $a + $b;
    );
    Sum();
    echo $b;</PRE><P>
<P>
上のスクリプトは &quot;3&quot;を出力する。
$a and $b を関数内でglobal 宣言することにより、各々の変数への全ての参照は
グローバル変数を参照する。
関数によって処理されるグローバル変数の数に制限は無い。
しかし、変数は関数が呼ばれるよりも前のグローバルな範囲になければならない。
関数の中で新しいグローバル変数を作ることは出来ない。<P>
<P>
一方、「変数範囲」で重要な特徴は <EM>スタティック</EM> 変数である。
スタティック変数はローカルな関数の範囲内でのみ存在するが、
プログラムの実行がこの範囲を離れてもその値を失わない。
次の例で考えてみよう。<P>
<P>
<PRE>    Function Test (
      $a=0;
      echo $a;
      $a++;
    );</PRE><P>
<P>
この関数は全く役に立たない。何故ならば関数が呼ばれたときは常に
$a に 0 を代入し、 &quot;0&quot; を出力するからである。
変数を増加させる $a++ は関数が存在するとすぐに $a 変数がなくなるので
意味がない。
現在のカウントを失わないような役に立つ数を数える関数を作るには、
変数 $a をスタティックに宣言する。<P>
<P>
<PRE>    Function Test (
      static $a=0;
      echo $a;
      $a++;
    );</PRE><P>
<P>
Test() 関数が呼ばれるときは常に  $a の値を出力してその数を増やす。<P>
関数が再帰的に呼ばれる時にもスタティック変数は重要である。再帰的関数は
自分自身を呼ぶような関数である。
再帰的関数を書いている時には充分注意するべきである。
何故ならばそれがいつまでも再帰するように出来るからである。
再帰が適切に終わるようにしなければならない。
次の簡単な関数は10まで再帰的にカウントする。<P>
<PRE>    Function Test (
      static $count=0;

      $count++;
      echo $count;
      if($count <  10) {
        Test();
      }
    );
</PRE><P>

<HR>
<H3><A NAME="math">数学的表現</A></H3>
<P>
PHPは式が求められる全ての場所で完全な数学的演算をサポートする。
演算子の順番は考慮される。次のものは有効な演算子である:<P>
<P>
<PRE>	&lt;? $a = 2 + 1 &gt; <EM>足し算</EM>
	&lt;? $a = 2 - 1 &gt; <EM>引き算</EM>
	&lt;? $a = 2 * 1 &gt; <EM>かけ算</EM>
	&lt;? $a = 2 / 1 &gt; <EM>割算</EM>
	&lt;? $a = 2 % 1 &gt; <EM>剰余</EM>
 	&lt;? $a = 2 ^ 1 &gt; <EM>ビット毎の排他的OR</EM>
</PRE><P>

<P>
括弧での括りと演算子の順番はどちらもサポートされる。
よって、次のものは有効である:<P>
<P>
<PRE>	&lt;?$a = (2+1)*3+6/3&gt;</PRE><P>
<P>
C言語ライクなインクリメント演算子 <TT>+=</TT> と <TT>-=</TT> がサポートされる。
  <P>
すなわち<P>
<P>
<PRE>    &lt;? $a += $b&gt;</PRE><P>
<P>
これは、次と同義である:<P>
<P>
<PRE>    &lt;? $a = $a + $b&gt;</PRE><P>
<P>
C言語に似たビット演算子 <TT>&amp;=</TT>、<TT>|=</TT>、<TT>^=</TT> 
がサポートされる。
すなわち<P>
<P>
<PRE>    &lt;? $a &= 4&gt;</PRE>
これは、次と同義である:<P>
<P>
<PRE>    &lt;? $a = $a &  4&gt;</PRE><P>
<HR>
<H3><A NAME="while">While ループ</A></H3>
<P>
PHPスクリプト中で <EM>while(); endwhile;</EM> 構文によるループが使用できる。<P>
<P>
<PRE>	&lt;?
	  $a=0;
	  while($a&lt;100) {
		  $a++;
		  echo $list[$a];	
	  } 
	&gt;
</PRE><P>
<P>
上記は配列の内容を表示する while ループの使用例である。
<STRONG>注意</STRONG> PHP言語は <STRONG>++</STRONG> と <STRONG>-<!>-</STRONG> 
のような変数を加算減算するインクリメント演算子をサポートするが、
C言語のように厳密に扱われることはない。変数は即座にインクリメントされる。
C言語にみられるように、操作の前または後で変数をインクリメントする概念はない。

<P>上記の<A HREF="#lang">言語構造</A>の項で述べたように、
<EM>while(); endwhile;</EM> についても同様のことが可能である。
<P>

<HR>
<H3><A NAME="switch">Switch 構造</A></H3>
<P>
PHPはC言語と良く似た switch 構造をサポートする。<P>
<P>
<PRE>	&lt;?
	  $a=0;
	  switch($a) {
		case 1;
		  echo "a is 1";
		  break;
		case "hello";
		  echo "a is hello";
		  break;
		default;
		  echo "a is unknown";
		  break;
	  } 
	&gt;
</PRE><P>
<P>
上記は switch 構造の例である。これは一連の if/elseif/else 構造に似ているが、
より読みやすいものである。C言語とPHPとの switch 構造の違いは、
各行を区切るためにコロン(:)ではなくセミコロン(;)が用いられていることである。
<P>
上記の<A HREF="#lang">言語構造</A>の章で述べたように、
<EM>switch(); endswitch;</EM> を用いても同様のことが可能である。

<P>
これら全ての構造はもちろん、C言語と同様にネストして使用できる。
PHP配布パッケージの <EM>examples</EM>ディレクトリーにある様々なファイルが、
この言語を学ぶための良いスタート地点を提供するであろう。

<HR>
<H3><A NAME="secure">安全な変数 - GET メソッドのハッキング防止</A></H3>
<P>
前項では GET と POST のメソッドのデータと変数について述べた。
これについて考えてみると、セキュリティーに関する問題を想像できる
であろう。
例えば、ウェブのページでデータベースからあるデータを入手し、このデータを
&quot;data&quot;という変数に入れて POST メソッドのフォームから送ったとする。
その次のページでこの変数にアクセスし、それを使って何かをすることができる。
しかし、この2番目のページに直接アクセスし &quot;?data=something&quotを
URLに付け足すことにより GET メソッドの変数をセットした場合には、
元の POST メソッドを効果的に回避することが可能である。<P>

<P>
PHPは、変数名を安全な変数(secure variable)として指定する
<EM>SecureVar()</EM>関数を提供する。
これらの安全な変数は、PHP スクリプトの中で直接値をセットする
ことのみが可能である。
もしくは、POST メソッドのフォームから値を得ることが可能である。
この変数は GET メソッドによる変数定義の機構を使用してはセットできない。
上記の記述をもとに、次の行を実行する。:<P>
<P>
<PRE>    &lt;?SecureVar("data")&gt;</PRE><P>
<P>
これを二つめのページの始めに置くことにより、GET メソッドにおけるトリックは
機能しなくなる。&quot;data&quot;という変数は、最初のページの POST 
メソッドのフォームから直接来ない限り、空の状態になる。
<P>
<EM>SecureVar()</EM>は、実際は正規表現を引数としてとるため、
安全な方法で扱いたい変数の名前のパターンを指定することができる。
例えば、<P>

<P>
<PRE>    &lt;?SecureVar(".*data.*")&gt;</PRE><P>

は、&quot;data&quot;という語をその名前の中のどこかに含む全ての変数を指定する。
<P>
気をつけなければいけないのは、POSTメソッドは本質的に安全ではないという
点である。
システムのHTTPポートに単に telnet することで、
疑似的にフォームのデータの転送をすることができるのである。
実際にセキュリティが重要である場合には、このようなことが行なわれないように
適当なセキュリティチェックを行なう必要がある。
<P>

<HR>
<H3><A NAME="overload">演算子のオーバーロードと変数の型の扱い</A></H3>

オーバーロードされた演算子とは、例えば'+'のように、演算する式の型によって
違ったことのできる演算子である。<P>

問題は、PHPが三つの変数の型を理解することである。
整数(Integer)、倍精度小数(Double)、文字列(String)がそれである。
変数が最初に割り付けられた時にPHPは自動的に変数の型を判定する。<P>
<P>
すなわち、
<P>
<PRE>    $a = 1;     型は整数(integer)になる
    $b = 1.5;   型は倍精度小数(double)になる
    $c = "1";   型は文字列(string)になる
</PRE><P>
<P>
それでは、次のようにした場合どのようなことが起こるであろうか:<P>
<P>
<PRE>    $d = $a + $c;</PRE><P>
<P>
構文解析は最初の算術式を見て、結果と、成すべき計算の種類の型を
決めるために使用する。上記の例では $a が整数(integer)であるため、
$d は整数(integer)に、そして整数の足し算が結果として行なわれる:<P>

<P>
<PRE>    $d = 2      型は整数である</PRE><P>
<P>
従って:<P>
<P>
<PRE>    $d = $c + $a</PRE><P>
<P>
の結果は:<P>
<P>
<PRE>    $d = "11"   型は文字列である</PRE><P>
<P>
上の事項は私にとって理にかなっており、一度理解すれば実用になるであろう。
しかし、さらに複雑な式が使われた時、極端に混乱を招くものとなり得る。

<P>
解決方法は、単純な型キャストのメカニズムである。
<P>
実際、全ての変数は自動的に三つの全ての型に変換され、
内部的なフラッグがその変数が現にどの型なのかを示しているのである。
つまりいうなれば:<P>

<PRE>    $a = 1;</PRE><P>
<P>
内部的に記号表(symbol table)には三つのバージョンで保存されている。
<P>
<P>
<PRE>    Integer:  1    &lt;--- ここをフラッグが指している
    Double :  1.0
    String :  "1"</PRE><P>
<P>
<EM>SetType()</EM>関数は、この変数の型を示すフラッグを動かすことができる。
<P>
<P>
<PRE>    SetType($a,"double");</PRE><P>
<P>
これは、$a を倍精度小数(double)として、これから後強制的に扱うようにする。<P>

<P>
<EM>GetType()</EM>関数は型を返す。

この例で<EM>GetType()</EM>は、&quot;double&quot;を返す。

<P>
型のフラッグを動かさずにいろいろな三つの型を返す関数も存在する。
<P>
<P>
<PRE>    IntVal($a)     returns  1
    DoubleVal($a)  returns  1.0
    StrVal($a)     returns  "1"
</PRE><P>
<P>
これは、PHP変数のオーバーロードされた演算子の本質を変えることはないが、
それらをよりうまく扱うためのツールを提供する。PHPは一人前のPerlもどきではない。
小さく速くなくてはならない。Perlはオーバーロードされた演算子の落とし穴
を扱うのに、'+'の様な演算子は強制的に数字のみに働くようにする。
もし文字列を加えたいならば、'.'演算子を使わなければならない。
各々の型別に別れた演算子を持ち始めると、その言語をますます複雑なものと
することになる。すなわち、'=='を文字列に使うことができず、
'eq'を使うことになる。
こういったことは、
特にPHPの様にほとんどのスクリプトがどちらかといえば単純で、
多くの場合あまり学習曲線の高くない基本的な論理的構文の言語を求める
プログラマーでない人々が書くような言語においては意味があることとは思えない。
<P>

<HR>
<H3><A NAME="quiet">関数呼び出し時のエラー抑制</A></H3>
<P>
特定のPHP関数からの致命的なエラーを無視することが望ましい場合もある。
例えば、dbmopen() の呼び出しのエラーを無視して、ウェブの画面にエラー
メッセージを出すことなしに、単に戻り値をチェックしたいとする。
これは、&quot;@&quot;文字を関数の前に置くことで実現できる。
すなわち<P>

<P>
<PRE>    $err_code = @dbmopen($filename,"w");</PRE><P>
<P>
出力された実際のエラーメッセージは、PHPの内部変数である
<STRONG>$phperrmsg</STRONG>を見ることでチェックできる。<P>
<P>
より一般的なエラーメッセージ表示の抑制方法は、
<A HREF="#seterrorreporting">SetErrorReporting()</A>関数を使うことである。
この関数を用いて、全てのスクリプトコードのブロックで、次のような呼び出しを
含むブロックを前に置くことで、その後のエラーの表示を不能にすることができる:<P>
<P>
<PRE>    SetErrorReporting(0);</PRE><P>
<P>
これは、全てのエラー表示を消す。再度表示可能にするには以下のようにする:<P>
<P>
<PRE>    SetErrorReporting(1);</PRE><P>
<HR>
<H3><A NAME="funcs">内部関数</A></H3><A HREF="function"> </A>
<P>
PHPには多くの組み込み関数がある。関数の呼び出しは C言語のものと
同じ方法が用いられる。
一つあるいは複数の引数を取るものもあり、
変数に格納したり他の関数の引数にするための戻り値を返すものもある。
例えば:<P>
<P>
<PRE>	&lt;?$t=time()&gt;</PRE><P>
<P>
これは <EM>time()</EM>関数の戻り値を変数<EM>t</EM>に代入する。


<HR>
<H3>関数のアルファベット順リスト</H3>
<DL>  


<DT><A NAME="abs"><FONT SIZE="+1">Abs(引数)</FONT></A>
<DD>
<P>Abs は引数の絶対値を返す。<P>
  
<DT><A NAME="ada_close"><FONT SIZE="+1">Ada_Close(接続ID)</FONT></A>
<DD>
<P>Ada_Close は、指定された接続IDに関連する Adabas サーバーへの接続を閉じる。
<P>この関数は、PHP 側で Adabas サポートが有効である場合にのみ利用可能である。
<P>

<DT><A NAME="ada_connect"><FONT SIZE="+1">$connection = Ada_Connect(データソース名, ユーザ名, パスワード)</FONT></A>
<DD>
<P>Ada_Connect は、Adabas サーバーへの接続をオープンする。
各引数は、引用符付きの文字列でなければならない。
最初のパラメータ(データソース名)は、
"サーバ名:データベース名"という形式の文字列である。
ローカルのデータベースをアクセスする場合には、サーバ名を省略することができる。
 (コロンは省略不可。) 
この関数は、接続IDを返す。
このIDは、他の Adabas 関数を使用する際に必要である。
一度に複数の接続を開くことができる。この関数は、エラーの際に
<STRONG>0</STRONG> を返す。
<P>この関数は、PHP 側で Adabas サポートが有効である場合にのみ利用可能である。
<P>

<DT><A NAME="ada_exec"><FONT SIZE="+1">$result = Ada_Exec(接続ID, クエリー文字列)</FONT></A>
<DD>
<P>Ada_Exec は、接続IDで指定された Adabas サーバーに SQL 命令を送る。
接続IDは、Ada_Connect から返された有効な ID または
特別な値 <STRONG>0</STRONG> でなければならない。
接続IDが0の場合、ada_exec は
<A HREF="#directives">設定命令</A> 
<EM>phpAdaDefDB, phpAdaUser</EM> and <EM>phpAdaPW</EM>で
指定されたパラメータを用いて接続を試みようとする。
<BR>
この関数の返り値はIDであり、他のAdabas 関数が検索結果に
アクセスする際に用いられる。
この関数は、エラーの場合 <STRONG>0</STRONG> を返す。

この関数は、正常に実行された場合でもデータを返さないコマンド
(例えば insert や update コマンド)について <STRONG>1</STRONG> を返す。
select は、データを返さない場合でも 1 より大きい有効な値を返すことに
注意されたい。
<P>
この関数は、PHP 側で Adabas サポートが有効である場合にのみ利用可能である。
<P>

<DT><A NAME="ada_fetchrow"><FONT SIZE="+1">Ada_FetchRow(結果ID [,行番号])</FONT></A>
<DD>
<P>Ada_FetchRow は、Ada_Exec から返されたデータを一行取り出す。
Ada_FetchRow がコールされた後、この行のフィールドは Ada_Result で
アクセスすることがアクセスすることが可能である。
行番号が与えられない場合、Ada_FetchRow は結果の組から次の行を取り出そうと
試みる。
Ada_FetchRow がコールされる度に、Ada_Result により新しい行にアクセスする
ことができる。
Ada_FetchRow が成功した場合(行があった場合)には
<STRONG>1</STRONG> が返される。
もう行がない場合には、Ada_FetchRow は <STRONG>0</STRONG>を返す。
Ada_FetchRow の返り値は、while ループの条件として使用可能である。
行番号のない Ada_FetchRow() と行番号のある Ada_FetchRow() のコールを
混用することができる。
結果を再度読み出したい場合には、Ada_FetchRow()で行番号として1を指定した後、 
行番号無しで Add_FetchRow()を呼び出し続けることにより結果を再度見ることが
可能である。
<P>
この関数は、PHP 側で Adabas サポートが有効である場合にのみ利用可能である。<P>

<DT><A NAME="ada_fieldname"><FONT SIZE="+1">Ada_FieldName(結果ID,フィールド番号)</FONT></A>
<DD>
<P>Ada_FieldName は、指定した Adabas 結果ID においてカラム番号で
指定したフィールドの名前を返す。
フィールド番号は 0 から始まる。
<P>
この関数は、PHP 側で Adabas サポートが有効である場合にのみ利用可能である。<P>

<DT><A NAME="ada_fieldnum"><FONT SIZE="+1">Ada_FieldNum(結果ID,フィールド名)</FONT></A>
<DD>
<P>Ada_FieldNum は、Adabas 結果ID におけるフィールド名で対応する
カラムの番号を返す。
フィールド番号は 0 から始まる。
<P>
この関数は、エラーの場合に <STRONG>-1</STRONG> を返す。
<P>
この関数は、PHP 側で Adabas サポートが有効である場合にのみ利用可能である。<P>

<DT><A NAME="ada_fieldtype"><FONT SIZE="+1">Ada_FieldType(結果ID,フィールド名|フィールド番号)</FONT></A>
<DD>
<P>Ada_FieldType は指定した Adabas 結果IDにおいて名前または番号により
参照されるフィールドのSQL型を返す。注意:フィールド番号が0から始まる。
<P>
この関数は、PHP 側で Adabas サポートが有効である場合にのみ利用可能である。<P>

<DT><A NAME="ada_freeresult"><FONT SIZE="+1">Ada_FreeResult(結果ID)</FONT></A>
<DD>
<P>Ada_FreeResult は、スクリプト実行時にメモリを大量に使用したくない
場合にのみ必要である。
結果を保持する全てのメモリは、スクリプト終了時に自動的に解放される。
しかし、あるスクリプトにおいて結果データがもう必要でないことが確実である
場合には、結果ID を引数として Ada_FreeResult をコールし、メモリを解放する
ことが可能である。
<P>
この関数は、PHP 側で Adabas サポートが有効である場合にのみ利用可能である。<P>

<DT><A NAME="ada_numfields"><FONT SIZE="+1">Ada_NumFields(結果ID)</FONT></A>
<DD>
<P>Ada_NumFields は、Adabas の検索結果におけるフィールド(カラム)の
数を返す。
引数は、Ada_Exec により返された有効な結果IDである。
この関数は、エラーの場合に <STRONG>-1</STRONG> を返す。<P>
この関数は、PHP 側で Adabas サポートが有効である場合にのみ利用可能である。<P>

<DT><A NAME="ada_numrows"><FONT SIZE="+1">Ada_NumRows(結果ID)</FONT></A>
<DD>
<P>Ada_NumRows は、Adabas の結果における行数を返す。
引数は、Ada_Exec により返された有効な結果IDである。
この関数は、エラーの場合に <STRONG>-1</STRONG> を返す。
INSERT、UPDATE、DELETE 命令については、Ada_NumRows() は作用した行数を
返す。SELECT 文について、この関数は有効な行の数を返す。
<P>
この関数は、PHP 側で Adabas サポートが有効である場合にのみ利用可能である。<P>

<DT><A NAME="ada_result"><FONT SIZE="+1">Ada_Result(結果ID, フィールド名 | インデックス)</FONT></A>
<DD>
<P>Ada_Result は、Ada_Exec から返された結果IDを入力として実際の値を返す。
フィールド名は、行においてどのセルを返すかを指定する。
フィールドの名前を指定する代わりに、引用符無しの番号をフィールドインデックス
として使用することができる。
フィールドインデックスは、0から始まる。
要求されたフィールドが BYTE (バイナリ) または 4096バイトより大きい場合、
内容はクライアントに直接送られる。
ヒント: [VAR]CHAR BYTE フィールドは、データベース関数 HEX() を使用して
 PHP 変数に返すことができる。
例:SELECT HEX(SYSKEY) SYSKEY FORM MYTABLE
<P>
この関数は、PHP 側で Adabas サポートが有効である場合にのみ利用可能である。<P>

<DT><A NAME="ada_resultall"><FONT SIZE="+1">Ada_ResultAll(結果ID [,フォーマット])</FONT></A>
<DD>
<P>Ada_ResultAll は AdaExec により生成される結果IDから全ての行を
出力する。
結果は、HTML テーブルフォーマットで出力される。
フォーマット用オプションを付加することにより、テーブル全体に渡る
フォーマット指定が可能である。
(例えば、bgcolor= は背景色をセットする。
 &gt;caption&gt; &lt;/caption はキャプションをセットする。) 
注意: &quot;format&quot; の内容は、
&lt;table format &gt;... のようにHTML テーブルタグに挿入される。
<P>
この関数は、PHP 側で Adabas サポートが有効である場合にのみ利用可能である。<P>

<DT><A NAME="addslashes"><FONT SIZE="+1">AddSlashes(引数)</FONT></A>
<DD>
<P>全ての $ \ あるいは ' をバックスラッシュでエスケープする。
(MAGIC_QUOTES がセットされている場合)
<a href="#stripslashes">StripSlashes()</a> も参照のこと。<P>

<DT><A NAME="asort"><FONT SIZE="+1">ASort(配列)</FONT></A>
<DD>
<P>Sort は、PHP 連想配列を昇順にソートするために使用される。
    降順にソートする場合は、ARSort() を使用のこと。
<a href="#sort">Sort()</a> 関数とは異なり、ASort() は
index 値の組みを維持する。
この関数は、3つの変数型を理解し、配列が文字列を含む場合は
アルファベット順にソートし、数を含む場合は数値でソートする。
配列に複数の型がある場合には、配列の最初の型がソートの種類を
決定する。
連想配列でない配列をソートしようとする場合、
<a href="#sort">Sort()</a>関数を使う必要があることに注意されたい。<P>

<DT><A NAME="bindec"><FONT SIZE="+1">BinDec(2進文字列)</FONT></A>
<DD>
<P>BinDec は2進数表現の引数文字列と等価な10進数を返す。
31 ビット長で表される最大の数は、10進数では4294967295である。
<A HREF="#decbin">DecBin()</A> 関数も参照のこと。<P>

<DT><A NAME="ceil"><FONT SIZE="+1">Ceil(値)</FONT></A>
<DD>
<P>Ceil() は、浮動小数点数をこの数より大きな整数の側に丸める。
返り値は、倍精度実数型であり、複雑な式においても使用可能である。
整数型を得るためには次のようにする。
: <tt>$new = IntVal(Ceil($value));</tt><br>
<a href="#floor">Floor()</a>も参照のこと。<P>

<DT><A NAME="chdir"><FONT SIZE="+1">ChDir(ディレクトリ)</FONT></A>
<DD>
<P>ChDir はカレントディレクトリを引数で指定されたディレクトリに変更する。
<P>    

<DT><A NAME="chgrp"><FONT SIZE="+1">ChGrp(file,group)</FONT></A>
<DD>
<P>ChGrp は、指定されたファイルの グループ id を変更する。<P>    

<DT><A NAME="chmod"><FONT SIZE="+1">ChMod(ファイル,許可属性)</FONT></A>
<DD>
<P>ChMod は、指定されたファイルの許可属性を変更する。<EM>許可属性</EM>
パラメータは、<a href="#octal">8進表記</a>で指定しなければならない。
例: ChMod($filename,0755)<P>
<DT><A NAME="chown"><FONT SIZE="+1">ChOwn(ファイル,所有者)</FONT></A>
<DD>
<P>ChOwn は指定されたファイルを指定された所有者の所有に変更する。
    この関数は、PHP/FI 実行ファイルがルートとして実行されている
    場合にのみ使用可能である。
(PHP/FI をルートで実行することは通常好ましくない。)<P>    

<DT><A NAME="chop"><FONT SIZE="+1">Chop(文字列)</FONT></A>
<DD>
<P>Chop は、改行、タブ、空白を含む全ての最後の空白文字を削除し、
    新しい文字列を返す。<P>
    
<DT><A NAME="chr"><FONT SIZE="+1">Chr(引数)</FONT></A>
<DD>
<P>Chr は、整数引数で表わされた ASCII 文字列を返す。<P>
    
<DT><A NAME="clearstack"><FONT SIZE="+1">ClearStack()</FONT></A>
<DD>
<P>ClearStack() 関数は、PHP パーサの欠陥に対する取り合えずの対策
(hack/workaround)である。
この欠陥とは、PHP が一つの式スタックしか持っていないことである。
ユーザー定義関数の内部にあるとき、この式スタックは決してクリアされない。
これは、ユーザー定義関数がコールされた箇所の
複雑な式の中でその内容が必要になるかもしれないからである。
これは、ユーザー定義関数の中で多くの繰り返しを行う while ループを有している
場合、多くのスタック領域を消費してしまうことを意味する。
最大データ領域の制限にかかることも考えられる。
このメモリー消費を防止するために while ループの中で
ClearStack() をコールすることができる。
しかし、自分の関数を文の中で使用できない、つまり、
関数の出力を一時的な変数に割付け、この一時変数を必要とされる場所で
使用する必要があるというトレードオフがある。
<P>

<DT><A NAME="clearstatcache"><FONT SIZE="+1">ClearStatCache()</FONT></A>
<DD>
<P>stat() システムコールは、ほとんどのオペレーティングシステムにおいて
負荷の高い操作である。    
<a href="#fileperms">FilePerms()</a>、<a href="#fileinode">FileInode()</a>、
等のような様々な File* 関数を繰り返しコールする手段を講じるために、
最後の stat() コールの結果は常にキャッシュされる。
File* 関数の一つが再び同じ引数で呼ばれた場合には、
キャッシュされた stat() の結果が使用される。
強制的に新しいシステムコールを行うために、
この ClearStatCache() 関数がコールされる。
この関数は、キャッシュされた stat() の結果をクリアする。<P>
     
<DT><A NAME="closedir"><FONT SIZE="+1">CloseDir()</FONT></A>
<DD>
<P>CloseDir は、<A HREF="#opendir">openDir</A> 関数を用いて
    開かれたディレクトリを閉じる。<P>    
  
<DT><A NAME="closelog"><FONT SIZE="+1">CloseLog()</FONT></A>
<DD>
<P>
CloseLog() は、記述子 Syslog() を閉じる。
システムログに書くために使用する。
更に詳細な情報は、closelog(3) UNIX man ページを参照のこと。
また、<a href="#syslog">Syslog()</a>、<a href="#openlog">OpenLog()</a>、
<a href="#initsyslog">InitSyslog()</a> も参照のこと。
<P>
 
<DT><A NAME="cos"><FONT SIZE="+1">Cos(引数)</FONT></A>
<DD>
<P>Cos は、引数(ラジアン)のコサインを返す。<A HREF="#sin">Sin()</A>
と<A HREF="#tan">Tan()</A>も参照のこと。<P>    

<DT><A NAME="count"><FONT SIZE="+1">Count(配列)</FONT></A>
<DD>
<P>Count は、配列変数 array における要素数を返す。
変数が配列でない場合には、
(通常の変数は要素数が 1 の配列と同様であるので、)
返り値は 1 となる。    
変数が未定義の場合には。返り値は、0となる。<P>    

<DT><A NAME="crypt"><FONT SIZE="+1">Crypt(文字列,[salt])</FONT></A>
<DD>
<P>Crypt は、標準的な Unix DES 暗号化法を用いて文字列を暗号化する。
引数は暗号化する文字列である。
また、オプションとして暗号化の基底となる塩として2文字の文字列
(salt string)をとる。
より詳細な情報は、crypt 関数に関する Unix マニュアルを参照のこと。
もし、自分の Unix システムにcrypt 関数がない場合には、
デンマークで開発されたMichael Glad'の public domain UFC-Crypt パッケージを
使用することが可能である。
合州国外のサイトから ftp でこれを手にいれる限り、
合州国の輸出法による拘束を受けない。
<P>    

<DT><A NAME="date"><FONT SIZE="+1">Date(フォーマット,時間)</FONT></A>
<DD>
<P> Date 関数は、時間と日付を様々な手法で表示するために用いられる。
この関数はフォーマット文字列と時間を引数としてとる。
時間の引数が省略された場合には、現在の時間が使われる。
時間の引数は、Unix 時間(1970 年1月1日からの秒数)を表す整数で指定する。
フォーマット文字列は、表示する日付/時間要素と
それらの表示フォーマットを指定するために用いる。
次の文字はフォーマット文字列の中で認識される。
認識されない文字は、冗長に表示される。:<P>

<UL>
	<LI><TT>Y - Year eg. 1995</TT>
	<LI><TT>y - Year eg. 95</TT>
	<LI><TT>M - Month eg. Oct</TT>
	<LI><TT>m - Month eg. 10</TT>
	<LI><TT>F - Month eg. October</TT>
	<LI><TT>D - Day eg. Fri</TT>
	<LI><TT>l - Day eg. Friday</TT>
	<LI><TT>d - Day eg. 27</TT>
	<LI><TT>z - Day of the year eg. 299</TT>
	<LI><TT>H - Hours in 24 hour format eg. 13</TT>
	<LI><TT>h - Hours in 12 hour format eg. 1</TT>
	<LI><TT>i - Minutes eg. 5</TT>
	<LI><TT>s - Seconds eg. 40</TT>
	<LI><TT>U - Seconds since epoch eg. 814807830</TT>
	<LI><TT>A - AM/PM</TT>
	<LI><TT>a - am/pm</TT>
</UL><P>
<a href="#mktime">MkTime()</a> 関数も参照のこと。
<P>

<DT><A NAME="dblist"><FONT SIZE="+1">dbList()</FONT></A>
<DD>
<P>dbList は PHP に組み込まれた db サポートについての情報を出力する。<P>    

<DT><A NAME="dbmclose"><FONT SIZE="+1">dbmClose(ファイル名)</FONT></A>
<DD>
<P>dbmClose は指定されたdbm ファイルを閉じる。
この関数は、全てのロックファイルのロックを解除する。
そのため、オープンした全ての dbm ファイルを閉じることは
重要である。<P>

<DT><A NAME="dbmdelete"><FONT SIZE="+1">dbmDelete(ファイル名,キー)</FONT></A>
<DD>
<P>dbmDelete は、キー引数により指定された キー/内容の組を削除する。<P>
    
<DT><A NAME="dbmexists"><FONT SIZE="+1">dbmExists(ファイル名,キー)</FONT></A>
<DD>
<P>dbmExists は、キーが存在する場合には 1、それ以外は 0 を返す。<P>    

<DT><A NAME="dbmfetch"><FONT SIZE="+1">dbmFetch(ファイル名,キー)</FONT></A>
<DD>
<P>dbmFetch は、与えたキーに関連づけられた文字列を返す。<P>    

<DT><A NAME="dbmfirstkey"><FONT SIZE="+1">dbmFirstKey(ファイル名)</FONT></A>
<DD>
<P>dbmFirstKey は、dbm ファイルの最初のキーを返す。
キーの順番は dbm の実装毎に内部で計算されるハッシュテーブルの値に依存する。
このため、特定の順番は保証されない。
必要ならば dbm ファイルからの配列データをソートするために <A HREF="#sort">Sort</A> 関数を使用することが可能である。

<DT><A NAME="dbminsert"><FONT SIZE="+1">dbmInsert(ファイル名,キー,内容)</FONT></A>
<DD>
<P>dbmInsert は、新しいキー/内容の組を dbm ファイルに挿入する。
    キーが既に存在する場合には、挿入は失敗する。<P>    

<DT><A NAME="dbmnextkey"><FONT SIZE="+1">dbmNextKey(ファイル名,キー)</FONT></A>
<DD>
<P>dbmNextKey は、指定したキーの次のキーを返す。
<STRONG>dbmfirstkey()</STRONG>を呼んだ後に
<STRONG>dbmnextkey()</STRONG> を逐次呼びだすことにより、
dbm ファイルの中の全ての key/内容の組を見ることが可能である。
<P>
    
<DT><A NAME="dbmopen"><FONT SIZE="+1">dbmOpen(ファイル名,モード)</FONT></A>
<DD>
<P>dbmOpen() は dbm ファイルを開く。最初の引数は、開こうとする dbm ファイルの
    フルパス表現のファイル名である。2 番目はファイルを開くモードで
    あり、<B>&quot;r&quot;</B>、<B>&quot;n&quot;</B>、<B>&quot;w&quot;</B> により、それぞれ read、new (write を含む)、write を表す。
ndbm サポートを用いる場合には、ndbm は <EM>filename.dir</EM> と
<EM>filename.pag</EM> ファイルを作成する。
gdbm は、内部的にフラットなアスキーファイルをサポートしているので
一つのファイルのみを用いる。
Berkeley の libdb は、<EM>filename.db</EM> ファイルを作成する。
dbm ライブラリ自体により行なわれるであろうファイルのロックに加えて、
PHP も独自のファイルのロックを行なう。
PHP は、作成した <EM>.lck</EM> ファイルを削除しない。
PHPは、これらのファイルを単にファイルのロックを行なうための
固定された inode として用いる。 
dbm ファイルに関するより詳しい情報は、
Unix の man ページを見るか、もしくは、GNU の gdbm を
<A HREF="ftp://prep.ai.mit.edu/pub/gnu">ftp://prep.ai.mit.edu/pub/gnu</A>
より手にいれること。<P>

<DT><A NAME="dbmreplace"><FONT SIZE="+1">dbmReplace(ファイル名,キー,内容)</FONT></A>
<DD>
<P>dbmReplace は、<STRONG>dbminsert()</STRONG> 関数に似ている。
唯一の違いは、キーが既に存在する場合の動作である。
この関数においては、古い内容は新しい内容で置き換えられる。
<P>
    
<DT><A NAME="decbin"><FONT SIZE="+1">DecBin(数値)</FONT></A>
<DD>
<P>DecBin は、与えられた引数の2進表現を保持する文字列を返す。
変換できる最大の数は、31 ビット長、あるいは、10進数では
4294967295 である。
<A HREF="#bindec">BinDec()</A> 関数も参照のこと。<P>    

<DT><A NAME="dechex"><FONT SIZE="+1">DecHex(数値)</FONT></A>
<DD>
<P>DecHex は、10 進数を16 進数を表す文字列へ変換する。
<A HREF="#hexdec">HexDec()</A> 関数も参照のこと。<P>
    
<DT><A NAME="decoct"><FONT SIZE="+1">DecOct(数値)</FONT></A>
<DD>
<P>DecOct は、10進数を 8 進数へ変換する。
<A HREF="#octdec">OctDec()</A>も参照のこと。<P>    

<DT><A NAME="doubleval"><FONT SIZE="+1">doubleval(変数)</FONT></A>
<DD>
<P>doubleval は、変数を倍精度実数(浮動小数点)で表した値を返す。
<A HREF="#strval">strval()</A> と <A HREF="#intval">intval()</A>
関数も参照のこと。<P>    

<DT><A NAME="echo"><FONT SIZE="+1">Echo [フォーマット文字列] 式 [, 式 [,...]]</FONT></A>
<DD>
<P>Echo は関数ではない。
すなわち、引数の前後を括弧でくくりはしない。
Echo は、PHP 関数の結果もしくはPHP変数の表示に用いられる。
サポートされる特殊文字のリストについては、
<a href="#escapes">エスケープ文字の節</a>を参照のこと。
format_string はオプションである。
もしこれがない場合には、出力のフォーマットは行なわれない。
このフォーマット文字列は、C 言語の<EM>printf</EM>関数の
フォーマット文字列に似ている。
詳細は、<EM>printf</EM> のマニュアルページを参照のこと。
5 つまでの式が一回の echo コマンドで表示可能である。
それ以上を表示させようとすると、構文エラーとなる。
式の型は(出力と)関係ない。
フォーマット文字列がある時には、表現式は自動的に
フォーマット文字列により指定された適当な型に変換される。
ある変数をフォーマットし、フォーマットされた文字列を表示する代わりに
変数に割り付けたい場合には、
<A HREF="#sprintf">sprintf()</A> 関数を使うこと。<P>
<P>次の変換がサポートされている。<P>
<BLOCKQUOTE>
<P>
<DL>
<DT>%d %i</DT>
<DD>符合付きの10進数を表示する。</DD>
<DT>%o</DT>
<DD>8進数を表示する。</DD>
<DT>%u</DT>
<DD>符合無しの10進数を表示する。</DD>
<DT>%x %X</DT>
<DD>16進数を表示する。</DD>
<DT>%f</DT>
<DD>浮動小数点数を表示する。</DD>
<DT>%e %E</DT>
<DD>科学記数法で浮動小数点数を表示する。</DD>
<DT>%g %G</DT>
<DD>科学記数法または通常の標記のどちらか適当な方で浮動小数点数を表示する。</DD>
<DT>%c</DT>
<DD>一文字を表示する。</DD>
<DT>%s</DT>
<DD>文字列を表示する</DD>
<DT>%%</DT>
<DD>パーセント記号をそのまま表示する。</DD>
</DL>
<P>
次のフラグが使用可能である。
<DL>
<DT>'-'</DT>
<DD>フィールド幅の中で出力を左揃えする。</DD>
<DT>'+'</DT>
<DD>全ての整数が符合付きで(正/負の符合付きで)出力されることを指定する。</DD>
<DT>' '</DT>
<DD>'+' に似ている。しかし、プラス符合の代わりに空白を用いる。</DD>
<DT>'#'</DT>
<DD>16進数や8進数であることを明示するために、それらの前に前置記号を出力する。
</DD>
<DT>'''</DT>
<DD>複数の桁をグループに分割する。(通常は3桁の組毎にカンマで区切る。)</DD>
<DT>'0'</DT>
<DD>フィールド幅をゼロで埋める。</DD>
</DL>
<P>
これら全てのフラグは、自分のシステムにおける C ライブラリの printf 関数が
それらをサポートしているかどうかに依存している。
(例えば、'''は GNU における拡張である。)<P>
<P>
ほとんどの変換においては、
/examples ディレクトリ中の <TT>demo_echo.html</TT> ファイルに示すように、
フィールド幅と精度を指定できる。
いかなる型の変換も指定する必要はない。
実際、PHP は型の修正子に意味がない場合には、エラーとする。
(ほとんど、いつもこのケースである。)
PHP は、認識できないもの全てをエラーとする。
(そして、処理を拒絶する。)
そのフォーマット文字列により必要のない引数は全て無視される。<P>
</BLOCKQUOTE>


<DT><A NAME="end"><FONT SIZE="+1">End(変数)</FONT></A>
<DD>
<P>End は、与えられた変数に関する内部配列のポインタを配列の最後の要素に移動し、
最後の要素の値を返す。
この関数は、連想配列を後ろから移動する際に便利である。
<A HREF="#reset">Reset()</A> と <A HREF="#prev">Prev()</A> も参照のこと。
次の例は、連想配列を後ろから移動するものである。:<P>
<P>
<PRE>    &lt;?
      Reset($array);
      $first_key = key($array);
      End($array);
      $k = key($array);
      while($k != $first_key);
        echo $array[$k];
        prev($array);
        $k = key($array);
      endwhile;
      echo $array[$k];
    &gt;</PRE><P>

    
<DT><A NAME="ereg"><FONT SIZE="+1">ereg(正規表現,文字列[,regs])</FONT></A>
<DD>
<P>ereg は、正規表現が引数文字列にマッチする場合に非0を返す。
条件 <TT>&lt;?if (ereg(&quot;^This.*&quot;,&quot;This is an example string&quot;)&gt;</TT>を例にとると、
&quot;^This.*&quot;式は文字列の先頭にある <STRONG>This</STRONG> と
後ろに続く全ての文字にマッチすることを意味するので真となる。
引数 <EM>regs</EM> がある場合には、マッチレジスタの値が
引数 <EM>regs</EM> を名前とする配列の 0-10 番目に代入される。
レジスタ 0 は常にマッチした文字列全体を保持する。  
正規表現に関するより詳しい情報については、このドキュメント中の
<A HREF="#regexp">正規表現の節</A> を参照のこと。<P>    

<DT><A NAME="eregi"><FONT SIZE="+1">eregi(正規表現,文字列[,regs])</FONT></A>
<DD>
<P>eregi は、正規表現の大文字/小文字が無視されて適用されることを除いて
<a href="#ereg">ereg()</a> 関数と同じである。<P>

    
<DT><A NAME="ereg_replace"><FONT SIZE="+1">ereg_replace(正規表現,置換文字列,文字列)</FONT></A>
<DD>
<P>ereg_Replace は、引数文字列全体を探索し
与えられた式にマッチする文字列を全て置換文字列で置き換える。
例えば、文字列
<TT>&quot;This is an example string&quot;</TT> において、
次のコマンドを用いて非常に簡単に全ての空白をダッシュに置換できる。:
<STRONG>ereg_replace(" ","-","This is an example string")</STRONG>
正規表現に関するより詳しい情報については、このドキュメント中の
<A HREF="#regexp">正規表現の節</A> を参照のこと。<P>    

<DT><A NAME="eregi_replace"><FONT SIZE="+1">eregi_replace(正規表現,置換文字列,引数文字列)</FONT></A>
<DD>
<P>eregi_replace は、正規表現の大文字/小文字が無視されて適用されることを除いて
<a href="#ereg_replace">ereg_replace()</a> 関数と同じである。<P>

    
<DT><A NAME="escapeshellcmd"><FONT SIZE="+1">EscapeShellCmd(文字列)</FONT></A>
<DD><P>EscapeShellCmd は、文字列の中で
シェルコマンドをだまして任意のコマンドを実行させるために用いられる可能性が
ある全ての文字をエスケープする。
ユーザー入力から得られたデータを <A HREF="#exec">Exec()</A>
または <A HREF="#system">System()</A> 関数に処理させる際には、
事前にこの関数を用いてこのデータを確実にエスケープする必要がある。
通常の使い方を示す。:<P>
<P>
<PRE>    &lt;?system(EscapeShellCmd($cmd))&gt;</PRE><P>    

<DT><A NAME="eval"><FONT SIZE="+1">Eval(文字列)</FONT></A>
<DD>
<P>Eval は文字列を引数にとり、その内容をミニPHP/FIスクリプト
として取り扱う。
この内容は、独立した PHP/FI スクリプトとして実行される。
全ての変数は eval の内部からセットしたり、アクセスすることができる。
これらは、スクリプト中における eval 文の現在の文脈に応じて
大局的な参照フレームから得ることができる。
文字列引数においては変数の置換が行なわれる。
そのため、変数を文字列式の中で用いる際には、エスケープする必要がある。
いくつかの例を示す。:<P>
<P>
<PRE>    $a = "echo phpversion();";
    eval($a);

    eval("echo phpversion();");

    eval("\$a=1; echo \$a;");</PRE><P>    

<DT><A NAME="exec"><FONT SIZE="+1">Exec(コマンド文字列 [, 配列 [,返り値]])</FONT></A>
<DD>
<P>Exec は与えられた unix コマンドを実行する。
しかし、何も出力しない。
exec は単にコマンドの実行結果から最後の行を返すだけである。
あるコマンドを実行し、そのコマンドから得られる全てのデータを
全く変更なしに直接得る必要がある場合には、
<a href="#passthru">PassThru()</a> 関数を使用すること。
配列引数がある場合には、指定されたその配列に
unix コマンドからの出力の全ての行が代入される。
代入はその配列の最後から始められる。
すでにその配列が要素を保持しているおり、かつ、
0 番目の要素からコマンド出力を代入したい場合には、
関数のコール前に配列を<a href="#unset">UnSet</a> により未定義とすること。
配列引数と同時に返り値引数が指定された場合には、
実行された UNIX コマンドのリターンステータスがこの変数に代入される。
ユーザーから入力されたデータにより Exec 関数を実行可能とする場合には、
ユーザーがシステムをだまして任意のコマンドを実行することができない
ように<A HREF="#escpapeshellcmd">EscapeShellCmd()</A> 関数を
用いなければならない。
<A HREF="#system">system()</A> 関数も参照のこと。<P>

<DT><A NAME="exit"><FONT SIZE="+1">Exit</FONT></A>
<DD>
<P>Exit コマンドは、このタグが解釈されると同時に
解釈を終了するために用いる。<P>    

<DT><A NAME="exp"><FONT SIZE="+1">Exp(引数)</FONT></A>
<DD>
<P>Exp は、e の引数(arg)乗を返す。<a href="#pow">pow()</a>も参照のこと。<P>

<DT><A NAME="fclose"><FONT SIZE="+1">fclose($fd)</FONT></A>
<DD>
<P>fclose() は、<A HREF="#fopen">fopen()</A> により開かれたファイルを閉じる。
引数は、fopen() の呼び出しにより返されたファイルポインタの
インデックスである。
<P>    

<DT><A NAME="feof"><FONT SIZE="+1">feof($fd)</FONT></A>
<DD>
<P>Feof は、ファイルポインタ引数により参照されるファイルがファイルの終端に達した場合に真を返す。
<P>    

<DT><A NAME="fgets"><FONT SIZE="+1">fgets($fd,バイト数)</FONT></A>
<DD>
<P>fgets() は <A HREF="#fopen">fopen()</A> によりオープンされた
ファイルから1行読み込む。
引数は、fopen() から返されたファイルポインタと読み込む最大のバイト数である。
最大バイト数分のデータか行の終わりを読み込んだ場合には、読み込みを
終了する。
このことは、C の fgets() 関数のコールに似ている。
<A HREF="#fputs">fputs()</A>も参照のこと。<P>    

<DT><A NAME="fgetss"><FONT SIZE="+1">fgetss($fd,バイト数)</FONT></A>
<DD>
<P>fgets() 関数とほぼ同じである。この関数においてはファイルを読み込む際に
全ての HTML タグやPHP/FI スクリプトを取り除くというところが
異なっている。<P>    

<DT><A NAME="file"><FONT SIZE="+1">$array = File(ファイル名)</FONT></A>
<DD>
<P>File は、ファイル全体を読み込み、<STRONG>0</STRONG>番目の要素から
始まって各々の配列要素にファイルの各行が代入された配列を返す。<P>
    
<DT><A NAME="fileatime"><FONT SIZE="+1">fileAtime(ファイル名)</FONT></A>
<DD>
<P>fileAtime は最後にデータがアクセスされた時間を返す。
ファイルが存在しないか、アクセスできないような他の要因がある場合には、
この関数は -1 を返す。
fileAtime と他の file* 関数に関するコールが
繰り返し行われる際に、アクセスされたファイルが変更されたり、
消されたりした場合には、file* 関数をコールする前に 
<a href="#clearstatcache">ClearStatCache()</a> をコールする必要がある。
<P>

<DT><A NAME="filectime"><FONT SIZE="+1">fileCtime(ファイル名)</FONT></A>
<DD>
<P>fileCtime は最後にファイルのステータスが変更された時間を返す。
ファイルが存在しないか、アクセスできないような他の要因がある場合には、
この関数は -1 を返す。
fileCtime と他の file* 関数に関するコールが
繰り返し行われる際に、アクセスされたファイルが変更されたり、
消されたりした場合には、file* 関数をコールする前に 
<a href="#clearstatcache">ClearStatCache()</a> をコールする必要がある。
<P>    

<DT><A NAME="filegroup"><FONT SIZE="+1">fileGroup(ファイル名)</FONT></A>
<DD>
<P>fileGroup は、ファイルの所有者のグループIDを返す。
ファイルが存在しないか、アクセスできないような他の要因がある場合には、
この関数は -1 を返す。
fileGroup と他の file* 関数に関するコールが
繰り返し行われる際に、アクセスされたファイルが変更されたり、
消されたりした場合には、file* 関数をコールする前に 
<a href="#clearstatcache">ClearStatCache()</a> をコールする必要がある。
<P>        


<DT><A NAME="fileinode"><FONT SIZE="+1">fileInode(ファイル名)</FONT></A>
<DD>
<P>fileInode はファイルの inode を返す。
ファイルが存在しないか、アクセスできないような他の要因がある場合には、
この関数は -1 を返す。
fileInode と他の file* 関数に関するコールが
繰り返し行われる際に、アクセスされたファイルが変更されたり、
消されたりした場合には、file* 関数をコールする前に 
<a href="#clearstatcache">ClearStatCache()</a> をコールする必要がある。
<P>            

<DT><A NAME="filemtime"><FONT SIZE="+1">fileMtime(ファイル名)</FONT></A>
<DD>
<P>fileMtime は最後に修正が行なわれた時間を返す。
ファイルが存在しないか、アクセスできないような他の要因がある場合には、
この関数は -1 を返す。
fileMtime と他の file* 関数に関するコールが
繰り返し行われる際に、アクセスされたファイルが変更されたり、
消されたりした場合には、file* 関数をコールする前に 
<a href="#clearstatcache">ClearStatCache()</a> をコールする必要がある。
<P>            
    
<DT><A NAME="fileowner"><FONT SIZE="+1">fileOwner(ファイル名)</FONT></A>
<DD>
<P>fileOwner はファイルの所有者のユーザーID(uid) を返す。
ファイルが存在しないか、アクセスできないような他の要因がある場合には、
この関数は -1 を返す。
fileOwner と他の file* 関数に関するコールが
繰り返し行われる際に、アクセスされたファイルが変更されたり、
消されたりした場合には、file* 関数をコールする前に 
<a href="#clearstatcache">ClearStatCache()</a> をコールする必要がある。
<P>            
    
<DT><A NAME="fileperms"><FONT SIZE="+1">filePerms(ファイル名)</FONT></A>
<DD>
<P>filePerms は、ファイルの許可属性ビットを返す。
これは、 UNIX C 言語における stat 構造体の <EM>st_mode</EM>
フィールドである。
ファイルが存在しないか、アクセスできないような他の要因がある場合には、
この関数は -1 を返す。
filePerms と他の file* 関数に関するコールが
繰り返し行われる際に、アクセスされたファイルが変更されたり、
消されたりした場合には、file* 関数をコールする前に 
<a href="#clearstatcache">ClearStatCache()</a> をコールする必要がある。
<P>
    
<DT><A NAME="filesize"><FONT SIZE="+1">fileSize(ファイル名)</FONT></A>
<DD>
<P>fileSize は、ファイルの大きさをバイト数で返す。
ファイルが存在しないか、アクセスできないような他の要因がある場合には、
この関数は -1 を返す。
fileSize と他の file* 関数に関するコールが
繰り返し行われる際に、アクセスされたファイルが変更されたり、
消されたりした場合には、file* 関数をコールする前に 
<a href="#clearstatcache">ClearStatCache()</a> をコールする必要がある。
<P>

<DT><A NAME="filetype"><FONT SIZE="+1">fileType(ファイル名)</FONT></A>
<DD>
<P>fileType は、ファイルの型を返す。返り値は、
&quot;dir&quot;、&quot;file&quot;、&quot;fifo&quot;、&quot;char&quot;、
&quot;block&quot;、&quot;link&quot; のうちの一つである。
これらは、それぞれ、ディレクトリ、標準ファイル、fifo スペシャル、
文字スペシャル、ブロックスペシャル、シンボリックリンクである。    
<P>

<DT><A NAME="floor"><FONT SIZE="+1">Floor(値)</FONT></A>
<DD>
<P>Floor() は、浮動小数点数をこの数より小さい整数の側に丸める。
返り値は倍精度実数型(浮動小数点数)であり、
複雑な方程式に使用することが可能である、
整数型を得るためには次のようにする。: 
<tt>$new = IntVal(Floor($value));</tt><br>
<a href="#ceil">Ceil()</a>も参照のこと。<P>

<DT><A NAME="flush"><FONT SIZE="+1">Flush()</FONT></A>
<DD>
<P>Flush() 関数は、出力バッファをフラッシュするために使用される。
Apache モジュールの場合、この関数は Apache の出力バッファをフラッシュし、
CGI版の場合、単に標準出力をフラッシュする。
Apache で CGI として実行される場合、
サーバーは、CGI スクリプトの出力をバッファリングするので、
この Flush() 関数はあまり有効な動作をしない。
Apache web サーバーのもとで PHP の CGI 版を実行する場合には、
スクリプトを nph- スクリプトとして実行することを考えてみること。
さもなくば、PHP のモジュール版を実行すること。<P>

<DT><A NAME="fopen"><FONT SIZE="+1">$fp = fopen(ファイル名,モード)</FONT></A>
<DD>
<P>fopen() は、ファイルをオープンしファイルのポインタを返す。
ファイルがオープンできない場合は、この関数は -1 を返す。<P>            
これは、C のfopen() コールと同様である。
filename 引数は開こうとするファイルの相対もしくは絶対パス
である。
mode 引数は "r", "r+", "w", "w+", "a", "a+" のどれかである。
より詳しい情報を得るには、 fopen() コールの Unix man ページを
参照のこと。
<A HREF="#popen">popen()</A> 関数に関する記述も参照のこと。
 <A HREF="#fclose">fclose()</A> 関数に関する記述も参照のこと。<P>
<P>例:<P>
<PRE>    $fp = fopen("/home/rasmus/file.txt","r");</PRE>

    
<DT><A NAME="fputs"><FONT SIZE="+1">fputs(fp,文字列)</FONT></A>
<DD>
<P>fputs() は、<A HREF="#fopen">fopen()</A> により開かれたファイルに
1 行書き込む。
引数は、fopen() より返されたファイルポインタと書き込む文字列である。
string 引数には、改行や復改、タブを出力するためにそれぞれ
<STRONG>\n</STRONG>、<STRONG>\r</STRONG> 、<STRONG>\t</STRONG>
を使う等の特別なエスケープ文字を用いることができる。
<A HREF="#fgets">fgets()</A>も参照のこと。<P>    

<DT><A NAME="fpassthru"><FONT SIZE="+1">FPassThru(fp)</FONT></A>
<DD>
<P>FPassThru() は、<I>fp</I> に残るデータを全て直接的に出力する。
この関数は <A HREF="#readfile">ReadFile()</A> とは異なり、
<A HREF="#fsockopen">fsockopen()</A> でオープンされた
ファイルも取り扱うことが可能である。
この関数は <A HREF="#passthru">PassThru()</A> とは異なり、
コマンド出力に対応せずオープンされたファイルに対応する。
FPassThru() は、読み込んで書き込んだバイト数を返す。<P>

<DT><A NAME="fseek"><FONT SIZE="+1">fseek(fp,位置)</FONT></A>
<DD>
<P>fseek() は、<A HREF="#fopen">fopen()</A> コールの返り値である
$id 引数により特定されるファイルポインタをファイル上の指定した位置に
移動させる。
ファイルポインタは、ファイルの開始位置に対して <STRONG>pos</STRONG> 引数で
指定されるオフセット分だけ加えた位置に移動される。
<A HREF="#ftell">ftell()</A> および <A HREF="#rewind">rewind()</A>
も参照のこと。<P>

<DT><A NAME="fsockopen"><FONT SIZE="+1">fp = fsockopen(hostname,port)</FONT></A>
<DD>
<P>fsockopen() は、ソケットコネクションをオープンし、
ファイルポインタを返す。
ファイルポインタは、<A HREF="#fgets">fgets</A>、<A HREF="#fputs">fputs</A>
、<A HREF="#fclose">fclose</A>により使用することができる。
引数はホスト名とポート番号である。
返り値は次のようになる。:ソケットが作成できなかった場合は -3 、ホスト名の dns による検索が失敗した場合は -4、コネクションが拒否されるか時間切れの場合は-5、
fdopen() コールが失敗した場合は -6、
setvbuf() コールが失敗した場合は -7。
オペレーティングシステムが UNIX ドメインソケットをサポートしている場合、
ポート番号が0 の時には ホスト名引数は UNIX ドメインソケットの
ファイル名として扱われる。
<P>

<DT><A NAME="ftell"><FONT SIZE="+1">pos = ftell(fp)</FONT></A>
<DD>
<P>ftell() は、<A HREF="#fopen">fopen()</A> コールの返り値である
fp 引数により指定されたファイルポインタの位置を返す。
この位置は、後に fseek() の引数として用いることが可能である。
<A HREF="#fseek">fseek()</A> と <A HREF="#rewind">rewind()</A>
も参照のこと。<P>  

<DT><A NAME="getaccdir"><FONT SIZE="+1">getAccDir()</FONT></A>
<DD>
<P>getAccDir は PHP のアクセス情報ファイルが存在する
ディレクトリ名を返す。
このアクセス情報ファイルの存在するディレクトリ名は、
アクセス情報を記録するファイルを所有するユーザーの
ユーザーID番号から付けられる。
 

<DT><A NAME="getenv"><FONT SIZE="+1">GetEnv(文字列)</FONT></A>
<DD>
<P>GetEnvは<EM>文字列</EM>で指定された環境変数の値を返す。PHP/FIでは、
環境変数は直接扱う事が出来るので、通常はこの関数は使わない。仮に、
内部のシンボルテーブルに見当たらない変数の参照が発生すれば、自動的に
環境変数空間を探すのである。
<P>
環境変数が通常のPHP/FI変数で書き換えられない事を
保証する必要がある時には、GetEnvを使うべきである。
セキュリティ機構が、HTTP サーバーが定義した REMOTE_ADDR や
REMOTE_HOST のような変数に基づく場合には、
これらの変数を $REMOTE_ADDR として直接参照せずに
GetEnv を用いてロードするべきである。
これは、誰かが偽りのフォームを作ってサーバーにそのデータを
ポストした場合に、結果として、どのようなセキュリティ機構をもってしても
すり抜けられてしまうことを避けるためである。
    
<DT><A NAME="gethostbyname"><FONT 
SIZE="+1">getHostByName(ドメイン名)</FONT></A>
<DD>
<P>getHostByNameは、与えられたドメイン名を、nnn.nnn.nnn.nnn形式の
IPアドレスに変換する。

<DT><A NAME="gethostbyaddr"><FONT SIZE="+1">getHostByAddr(IPアドレス)</FONT></A>
<DD>
<P>getHostByAddrは、nnn.nnn.nnn.nnnで与えられたアドレスをFQDN形式の
ドメイン名に変換する。

<DT><A NAME="getimagesize"><FONT SIZE="+1">GetImageSize(ファイル名)</FONT></A>
<DD>
<P>The GetImageSize() 関数は、ファイルの絶対パスまたは呼び出す
    スクリプトからの相対パスをとる。この関数は、幅、高さ、型の
    3つの要素からなる配列を返す。幅と高さは、ピクセル単位であり、
    型は、1 が GIF ファイル、2 が JPG ファイル、3 が PNG ファイルを意味する。
    他の型はサポートされていない。返される配列の4番目の要素は、
     &quot;width=x height=y&quot; という文字列を含んでおり、
    これは、直接 IMG タグとして使用可能である。
    この関数を使用するために GD イメージライブラリは必要ないことに
    注意されたい。例を以下に示す。
</P>
<P><PRE>    &lt;?
        $result = GetImageSize("img/flag.jpg");
    &gt;
    &lt;IMG SRC=&quot;img/flag.jpg&quot; ?echo $result[3]&gt; &gt;</PRE></P>
 
<DT><A NAME="getlastaccess"><FONT SIZE="+1">getLastAccess()</FONT></A>
<DD>
<P>getLastAccessは現在のページが最後にアクセスされた時間をUNIXのtime
形式で返す。この値は、<A HREF="#date">Date()</A>関数を通してフォーマット
出来る。
この関数は、PHPのコンパイル時に、アクセスログ機能を有効にした時のみ
利用できる。<P>


<DT><A NAME="getlastbrowser"><FONT SIZE="+1">getLastbrowser()</FONT></A>
<DD>
<P>getLastBrowserは、現在のページを最後にアクセスしたユーザの
ブラウザーを表す文字列を返す。
この関数は、PHPのコンパイル時に、アクセスログ機能を有効にした時のみ
利用できる。<P>

<DT><A NAME="getlastemail"><FONT SIZE="+1">getLastEmail()</FONT></A>
<DD>
<P>getLastEmailは現在のページを最後に参照したユーザーのE-Mailアドレスを
返す。<BR>
この関数は、PHPのコンパイル時に、アクセスログ機能を有効にした時のみ
利用できる。<P>

<DT><A NAME="getlasthost"><FONT SIZE="+1">getLastHost()</FONT></A>
<DD>
<P>getLastHostは現在のページを最後に参照したユーザーのホスト名を
返す。<BR>
この関数は、PHPのコンパイル時に、アクセスログ機能を有効にした時のみ
利用できる。<P>

<DT><A NAME="getlastmod"><FONT SIZE="+1">getLastMod()</FONT></A>
<DD>
<P>getLastModは、現在のページを最後に修正した時刻(日付と時間)を、
UNIXのtime形式で返す。この値は<A HREF="#date">Date()</A>でフォーマット
出来る。<BR>
この関数は、PHPのコンパイル時に、アクセスログ機能を有効にした時のみ
利用できる。<P>

<DT><A NAME="getlastref"><FONT SIZE="+1">getLastref()</FONT></A>
<DD>
<P>getLastRefは、現在のページを最後にアクセスしたユーザが参照した
URLを返す。<BR>
この関数は、PHPのコンパイル時に、アクセスログ機能を有効にした時のみ
利用できる。<P>

<DT><A NAME="getlogdir"><FONT SIZE="+1">getLogDir()</FONT></A>
<DD>
<P>getLogDir は PHP のログファイルが存在する
最上位階層のディレクトリを返す。
実際のログファイルは、このディレクトリの下のディレクトリに
存在する。
各サブディレクトリ名は、ログファイルの属するユーザのユーザID番号
である。
それらのディレクトリの中にいくつかの dbm ログファイルがある。
各 dbm ファイル は、名前の最初の部分が示すファイルの inode 数を保持している。

<DT><A NAME="getmyinode"><FONT SIZE="+1">getMyInode()</FONT></A>
<DD>
<P>getMyInodeは、現在のHTMLファイルの inode 数を返す。<P>

<DT><A NAME="getmypid"><FONT SIZE="+1">getMyPid()</FONT></A>
<DD>
<P>getMyPid()は、現在の PHP 処理プロセスのプロセスIDを返す。<P>

<DT><A NAME="getmyuid"><FONT SIZE="+1">getMyUid()</FONT></A>
<DD>
<P>getMyUidは、現在のHTMLファイルの所有者のID番号を返す。<P>

<DT><A NAME="getrandmax"><FONT SIZE="+1">getRandMax()</FONT></A>
<DD>
<P>getRandMaxは<A HREF="#rand">Rand</A>関数が返す乱数の最大値を返す。
この値が正確でないと思われれる場合には、
PHP配布ファイル中の php.h のソースを見て、より詳細な情報を得ること。
<P>
<DT><A NAME="getstartlogging"><FONT SIZE="+1">getStartLogging()</FONT></A>
<DD>

<P>getStartLogging は現在のページに関するログの記録が開始された日時を、
UNIXの time 形式で返す。
mSQL によりログを記録した場合には、タイムスタンプが各ログファイルへ
記録されるので、この日時は、より正確になる。
dbm によりログを記録する場合には、そのユーザーのログ用ディレクトリが
作成された時間が返される。
<P>
    
<DT><A NAME="gettoday"><FONT SIZE="+1">getToday()</FONT></A>
<DD>
<P>getTodayは現在のページに関するローカル時間の深夜12時からの
総アクセス数を返す。
<BR>この関数は、PHPのコンパイル時に、アクセスログ機能を有効にした時のみ
利用できる。<P>

<DT><A NAME="gettotal"><FONT SIZE="+1">getTotal()</FONT></A>
<DD>
<P>getTotalは、アクセス記録を始めてから現在のページが受けた
総ヒット数を返す。<BR>
この関数は、PHPのコンパイル時に、アクセスログ機能を有効にした時のみ
利用できる。<P>

<DT><A NAME="gettype"><FONT SIZE="+1">GetType(変数)</FONT></A>
<DD>
<P>GetTypeは変数の型を返す。返り値は文字列で、
&quot&quot;integer&quot;、&quot;double&quot;、string&quot;の
いづれかである。
<A HREF="#settype">SetType()</A>関数も参照の事。<P>

<DT><A NAME="gmdate"><FONT SIZE="+1">gmDate(フォーマット,時間)</FONT></A>
<DD>
<p>gmDateは、ローカルタイムの代わりにグリニッジ標準時を用いること以外、
<A HREF="#date">Date</A>と同一である。<P>

<DT><A NAME="header"><FONT SIZE="+1">Header(ヘッダー文字列)</FONT></A>
<DD>
<P>Headerコマンドは、HTMLファイルの先頭で、HTTPのヘッダー文字列を
送るのに使われる。HTTPヘッダーについての詳細は<A HREF="http://www.w3.org/
hypertext/WWW/Protocols/HTTP1.0/draft-ietf-http-spec.html">
HTTP Specification</A>を参照の事。Header()コマンドは通常のHTMLタグや
PHP の echo コマンドにより実際の出力が行なわれる前に使用しなければならない。
<BR>
使用例は、<A HREF="#http_auth">HTTP 認証</A>節において参照可能である。
<P>

    
<DT><A NAME="hexdec"><FONT SIZE="+1">HexDec(16進文字列)</FONT></A>
<DD>
<P>HexDecは16進数を10進数に変換する。<A HREF="#dechex">DecHex()</A>も
参照の事。<P>

<DT><A NAME="htmlspecialchars"><FONT SIZE="+1">
HtmlSpecialChars(文字列)</FONT></A>
<DD>
<P>HtmlSpecialCharsは、
160から255までのアスキーコードを有する任意の文字を示す
引数文字列を対応する実際の HTML 名に変換する。
この関数は、変換された文字列を返す。
<b>&lt;</b>、<b>&gt;</b>、<b>&amp;</b>、<b>&quot;</b> も変換される。<P>

<DT><A NAME="imagearc"><FONT SIZE="+1">
ImageArc(im, cx, cy, w, h, s, e, col)</FONT></A>
<DD>
<P>ImageArcは、<A HREF="#imagecreate">im</A>で現わされるイメージ上に、
cx,cyを中心（左上を原点）とする部分楕円を描く。wとhは、それぞれ、
楕円の幅と高さを特定する。一方、始点と終点は、sとeで示す角度で特定する。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagechar"><FONT SIZE="+1">
ImageChar(im, size, x, y, c, col)</FONT></A>
<DD>
<P>ImageCharは、<A HREF="#imagecreate">im</A>で識別されるイメージ上の
x,y座標（左上が原点）にcol色の文字cを描画する。引数sizeは、1,2,3,4,
5のいづれかの値であり、1が最小で、5が最大である。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagecharup"><FONT SIZE="+1">
ImageCharUp(im, size, x, y, c, col)</FONT></A>
<DD>
<P>ImageCharUpは、<A HREF="#imagecreate">im</A>で識別されるイメージ上の
x,y座標（左上が原点）にcol色の文字cを縦に描画する。引数sizeは、1,2,3,4
,5のいづれかの値であり、1が最小で、5が最大である。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>


<DT><A NAME="imagecolorallocate"><FONT SIZE="+1">col = ImageColorAllocate
(im, red, green, blue)</FONT></A>
<DD>
<P>ImageColorAllocateは、指定した RGB 要素で構成される色を
示す色識別子を返す。引数 im は、
<A HREF="#imagecreate">ImageCreate</A>関数の返り値である。
ImageColorAllocateは、imで現わされるイメージで使われる個々の色を作成する
ために呼び出す必要がある。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagecolortransparent"><FONT SIZE="+1">
ImageColorTransparent(im, col)</FONT></A>
<DD>
<P>ImageColorTransparentは、イメージ im の透明色をcolにする。
imは<A HREF="#imagecreate">ImageCreate</A>で返されるイメージ識別子で、
colは<A HREF="#imagecolorallocate">ImageColorAllocate</A>で返される
色識別子である。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagecopyresized"><FONT SIZE="+1">
ImageCopyResized(dst_im, src_im, dstX, dstY, srcX, srcY, 
dstW, dstH, srcW, srcH )</FONT></A>
<DD>
<P>ImageCopyResizedは、イメージの一矩形領域を、別のイメージにコピーする。
<EM>dst_im</EM>はコピー先のイメージ名であり、<EM>src_im</EM>はコピー元の
イメージ名である。コピー元とコピー先のイメージの座標や幅や高さが異なれば、
適当な伸縮が行なわれる。座標系は、左上隅を基準とする。
この関数は、同一イメージ内(<EM>dst_im</EM>と<EM>src_im</EM>が同じ場合)
における領域のコピーにも用いることが出来るが、その領域が重なった場合の
結果は予測不可能である。
<BR>本関数は、GD がPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagecreate"><FONT SIZE="+1">
im = ImageCreate(x_size, y_size)</FONT></A>
<DD>
<P>ImageCreateは、x_size × y_size の大きさの空のイメージを表す
イメージ識別子を返す。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagecreatefromgif"><FONT SIZE="+1">
im = ImageCreateFromGif(ファイル名)</FONT></A>
<DD>
<P>ImageCreateFromGifは与えられた<EM>ファイル名</EM>
から得られるイメージを表すイメージ識別子を返す。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagedestroy"><FONT SIZE="+1">
ImageDestroy(im)</FONT></A>
<DD>
<P>ImageDestroyはイメージ im に関連するメモリを開放する。
im は<A HREF="#imagecreate"> ImageCreate</A>関数が返すイメージ識別子である。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagefill"><FONT SIZE="+1">
ImageFill(im, x, y, col)</FONT></A>
<DD>
<P>ImageFillはイメージimをcol色で、座標x, y（左上が原点）から塗りつぶす。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagefilledpolygon"><FONT SIZE="+1">
ImageFilledPolygon(im, points, num_points, col)</FONT></A>
<DD>
<P>ImageFilledPolygonは、イメージ <A HREF="#imagecreate">im</A> の中に
塗りつぶされた多角形を作成する。
points は多角形の頂点を要素とするPHP配列である。
すなわち、points[0] = x0, points[1] = y0, points[2] =x1, points[3] = y1
等となる。num_points は頂点の総数である。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagefilledrectangle"><FONT SIZE="+1">
ImageFilledRectangle(im, x1, y1, x2, y2, col)</FONT></A>
<DD>
<P>ImageFilledRectangleは、イメージ im 上に
左上の座標 x1,y1 から始まって右下の座標 x2,y2 までの
色 col の塗りつぶされた矩形を作成する。左上隅がイメージの原点である。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagefilltoborder"><FONT SIZE="+1">
ImageFillToBorder(im, x, y, border, col)</FONT></A>
<DD>
<P>ImageFillToBorderは border で定義される境界色を用いて、
塗りつぶす。x,yは塗りつぶしを始める点で（左上が原点）、col色で塗りつぶす。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagegif"><FONT SIZE="+1">
ImageGif(im [,filename])</FONT></A>
<DD>
<P>ImageGifは、イメージ im から filename という名前の GIFファイル
を作成する。引数imは、<A HREF="#imagecreate">ImageCreate</A>関数の
返り値である。引数filenameはオプションであり、省かれた場合には、
画像データが直接ストリームに書きだされる。
<a href="#header">Header()</a>関数を使用して、content-typeに
<em>image/gif</em>を送る事で、この関数を使って直接GIF画像を生成する
PHPスクリプトを記述できる。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imageinterlace"><FONT SIZE="+1">
ImageInterlace(im, interlace)</FONT></A>
<DD>
<P>ImageInterlaceは、インターレースビットのオンオフを切り替える。
interlaceが 1 ならば、イメージ im はインターレース化される。
interlaceが0ならば、インターレースビットはオフになる。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>


<DT><A NAME="imageline"><FONT SIZE="+1">
ImageLine(im, x1, y1, x2, y2, col)</FONT></A>
<DD>
<P>ImageLineは、イメージ<A HREF="#imagecreate">im</A>上に
<A HREF="#imagecolorallocate">col</A>色で、x1,y1からx2,y2(左角を原点とする)
への直線を描画する。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagepolygon"><FONT SIZE="+1">ImagePolygon(im, points, num_points, 
col)</FONT></A>
<DD>
<P>ImageFilledPolygonは、イメージ <A HREF="#imagecreate">im</A> の中に
多角形を描画する。pointsは多角形の頂点を含むPHPの配列である。
すなわち、points[0] = x0, points[1] = y0, points[2] =x1, points[3] = y1
等となる。num_points は頂点の総数である。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagerectangle"><FONT SIZE="+1">
ImageRectangle(im, x1, y1, x2, y2, col)</FONT></A>
<DD>
<P>ImageRectangleは、イメージim上に、左上隅を起点として、x1,y1を左上の始点、
x2,y2を右下の終点とするcol色の矩形を生成する。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagesetpixel"><FONT SIZE="+1">
ImageSetPixel(im, x, y, col)</FONT></A>
<DD>
<P> ImageSetPixelは、<A HREF="#imagecreate">im</A>で示されるイメージ上の
x,yで示される座標（左上が原点）に、<A HREF="#imagecolorallocate">col</A>色の
点を描画する。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagestring"><FONT SIZE="+1">ImageString(im, size, x, y, s, 
col)</FONT></A>
<DD>
<P> ImageStringは、<A HREF="#imagecreate">im</A>を識別子とする
イメージにおいて、x,yで示される座標（左上が原点）に
colで示される色で文字列 s を描画する。
引数 sizeは 1,2,3,4,5の値を取り、1が最小で、5が最大である。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagestringup"><FONT SIZE="+1">
ImageStringUp(im, size, x, y, s, col)</FONT></A>
<DD>
<P>ImageStringUpは、
x,yで示される座標（左上が原点）に、
<A HREF="#imagecreate">im</A>を識別子とするイメージにおいて
colで示される色で文字列 s を垂直に描画する。
引数 sizeは、1,2,3,4,5の値を取り、1が最小で 5が最大である。
<BR>本関数は、GDがPHPに組み込まれていれば機能する。<P>

<DT><A NAME="imagesx"><FONT SIZE="+1">ImageSX(im)</FONT></A>
<DD>
<P>ImageSXは、<em>im</em>を識別子とするイメージの幅を返す。<P>

<DT><A NAME="imagesy"><FONT SIZE="+1">ImageSY(im)</FONT></A>
<DD>
<P>ImageSYは、<em>im</em>を識別子とするイメージの高さを返す。<P>

<DT><A NAME="include"><FONT SIZE="+1">Include(filename)</FONT></A>
<DD>
<P>Includeコマンドは、現在のHTMLファイル中に、他のファイルを挿入するのに
用いられる。ヘッダーやフッターを何百ものHTMLファイルに加える必要が
ある際には非常に便利である。
include コマンドを使う場合には、変更の必要がある時にヘッダーもしくはフッターを
一個所で修正するだけで済む。
インクルードファイルにおいても PHP による解釈は完全に行なわれるので、
これまで書いた共通の PHP スクリプト を include コマンドで読み込ませる
ことも可能である。　
いわば、プリミティブな共有ライブラリを有しているが如く、
自分の HTML ファイルから呼び出すことが可能である。
このような共通ライブラリファイルを一つのディレクトリに置き、
PHP のインクルードパスをセットすることにより、
ファイルをパス名付きで参照する必要がないようにすることが可能である。
Apache モジュールのユーザーについては、
<STRONG>phpIncludePath</STRONG> ディレクティブによりこの機能を
設定することが可能である。    
CGI 版のユーザーについては、PHP_INCLUDE_PATH 環境変数により
設定が可能である。
このパスは、ちょうど UNIX シェルにおける <CODE>$PATH</CODE> のように
コロンで区切られている。
例えば、<PRE>    &lt;?include(&quot;/path/filename.txt&quot;)&gt;</PRE>
<P>

<DT><A NAME="initsyslog"><FONT SIZE="+1">InitSyslog()</FONT></A>
<DD>
<P>
InitSyslog() は、OpenLog() および Syslog() を使用する際に必要となる
いくつかの PHP 変数を定義する。
これらの変数は、デフォルトでは効率のため定義されない。
変数は、&lt;syslog.h&gt; C インクルードファイル 
と同様の方法で($LOG_LOCAL0 のように)名前が付けられている。
更に詳細な情報については、syslog(3) UNIX マニュアルを参照されたい。
<a href="#initsyslog">InitSyslog()</a>、<a href="#syslog">Syslog()</a>
、<a href="#closelog">CloseLog()</a> も参照のこと。
<P>

<DT><A NAME="intval"><FONT SIZE="+1">intval(変数)</FONT></A>
<DD>
<P> intval関数は、変数の倍精度整数値(long integer)を返す。
<A HREF="#strval">strval()</A> や<A HREF="#doubleval">doubleval()</A>
も参照のこと。<P>

<DT><A NAME="isset"><FONT SIZE="+1">IsSet(変数)</FONT></A>
<DD>
<P> IsSet関数は、変数が定義されていれば1を返し、そうでなければ0を返す。
<P>


<DT><A NAME="key"><FONT SIZE="+1">Key(変数)</FONT></A>

<DD>
<P>
Key は現在の配列要素のキーを返す。その要素は与えられた変数の
配列ポインタの位置によって定義される。
この配列ポインタは関数 <A HREF="#reset">Reset()</A>、<A HREF="#end">End()</A>、
<A HREF="#next">Next()</A>、<A HREF="#prev">Prev()</A> により操作される。
この関数は普通の配列でも充分使えるが、主として連想配列中の要素に関する
キーの値を決めるために使用される。
<P>

<DD>
<P>Link() はハードリンクを作る。シンボリック(ソフト)リンクを作るには<a href="#symlink">Symlink()</a> を参照のこと。また、<a href="#readlink">ReadLink</A> および <A HREF="#LinkInfo">LinkInfo</A> 関数も参照のこと。<P>
 
<DT><A NAME="linkinfo"><FONT SIZE="+1">LinkInfo(パス)</FONT></A>
<DD>
<P>LinkInfo は lstat システムコールで返される UNIX の C 言語の stat 構造体の
st_dev フィールドを返す。この関数は(パスが指す)link が本当に
存在しているかを
(stat.h の中で定義されている S_ISLNK マクロと同じ方法を使って)
確認する為に使われる。エラーの場合は -1 を返す。<P>

<DT><A NAME="log"><FONT SIZE="+1">Log(引数)</FONT></A>
<DD>
<P>Log は引数の自然対数を返す。<P>

<DT><A NAME="log10"><FONT SIZE="+1">Log10(引数)</FONT></A>
<DD>
<P>Log10 は引数の基底が 10 の対数を返す。<P>

<DT><A NAME="logas"><FONT SIZE="+1">LogAs(ファイル名)</FONT></A>
<DD>
<P>LogAs() 関数は、カレントのページへのアクセスを
実際には引数で指定されたファイルにアクセスされたものとして
記録する。<P>
 
<DT><A NAME="mail"><FONT SIZE="+1">Mail(to,題名,メッセージ[,ヘッダ文字列])</FONT></A>
<DD>
<P>Mail は、メッセージ引数で指定されたメッセージを
to 引数で指定された宛先に向けて自動的にメールする。
to 引数において宛先の間を空白で区切ることにより複数の宛先を
指定できる。
<P>
例えば、
    <PRE>   mail(&quot;rasmus@lerdorf.on.ca&quot;, 
        &quot;My Subject&quot;, 
        &quot;Line 1\nLine 2\nLine 3&quot;);</PRE>

4番目の引数として文字列が渡された場合、この文字列がヘッダの最後に挿入される。
例えば、    
<PRE>
   mail(&quot;ssb@guardian.no&quot;, &quot;the subject&quot;, $message,
        &quot;X-Mailer: PHP/FI &quot; + phpversion());
</PRE>

<DT><A NAME="max"><FONT SIZE="+1">Max(配列)</FONT></A>
<DD>
<P>Max は PHP 配列の中で最大値を返す。
すなわち、最大要素を探して配列全体を検索する。
array が文字列の配列である場合には、配列の中でソートした場合に
アルファベット順で最後となる文字列が返される。<P>

<DT><A NAME="md5"><FONT SIZE="+1">Md5(メッセージ)</FONT></A>
<DD>
<P>Md5 は、文字列の MD5 ハッシュ値を返す。<P>

<DT><A NAME="mi_close"><FONT SIZE="+1">mi_Close(接続ID)</FONT></A>
<DD>
<P>mi_Close は、指定された接続IDに関連付けられた Illustra データベース
への接続を閉じる。
<P>
<P>
この関数は、PHPにおいて Illustra サポートが有効な場合にのみ
実行可能である。
<P>

<DT><A NAME="mi_connect"><FONT SIZE="+1">$connection = mi_Connect(
データベース,ユーザ名,パスワード)</FONT></A>
<DD>
<P>mi_Connect は、Illustra データベースへの接続を開く。
各引数は、引用符付きの文字列でなければならない。
この関数は、接続IDを返す。このIDは、他の Illustra 関数使用の際に
必要である。複数の接続を同時に開くことが可能である。
接続可能なホストは、 PHP が実行されているマシン上の
MI_PARAMS ファイルに拘束される。
リモート実行はまだサポートされていない。
この関数は、エラーの場合に <STRONG>-1</STRONG> を返す。<P>
<P>
この関数は、PHPにおいて Illustra サポートが有効な場合にのみ
実行可能である。
<P>

<DT><A NAME="mi_dbname"><FONT SIZE="+1">mi_DBname(接続ID)</FONT></A>
<DD>
<P>mi_DBname は、指定した Illustra 接続IDが接続するデータベースの
名前を返す。
<P>
<P>
この関数は、PHPにおいて Illustra サポートが有効な場合にのみ
実行可能である。
<P>

<DT><A NAME="mi_exec"><FONT SIZE="+1">$result = mi_Exec(接続ID, 
クエリー文字列)</FONT></A>
<DD>
<P>mi_Exec は、接続IDで指定された Illustra データベースに SQL 命令を
送信する。
接続IDは、mi_Connect から返された有効なIDでなければならない。
この関数の返り値は、他の Illustra 関数が結果にアクセスする際に
使用される結果IDである。
この関数は、エラーの場合に <STRONG>-1</STRONG> を返す。<P>
この関数は、PHPにおいて Illustra サポートが有効な場合にのみ
実行可能である。
<P>

<DT><A NAME="mi_fieldname"><FONT SIZE="+1">mi_FieldName(接続ID,
結果ID,フィールド番号)</FONT></A>
<DD>
<P>mi_FieldName は、指定された Illustra 結果ID、接続IDについて
指定されたカラム番号に存在するフィールドの名前を返す。
フィールド番号は、0から始まる。
<P>
この関数は、エラーの場合に <STRONG>-1</STRONG> を返す。<P>
この関数は、PHPにおいて Illustra サポートが有効な場合にのみ
実行可能である。
<P>

<DT><A NAME="mi_fieldnum"><FONT SIZE="+1">mi_FieldNum(接続ID, 
結果ID, フィールド名)</FONT></A>
<DD>
<P>mi_FieldNum は、指定された Illustra 結果IDについてフィールド名に対応する
カラムの番号を返す。
フィールド番号は、0から始まる。
<P>
この関数は、エラーの場合に <STRONG>-1</STRONG> を返す。<P>
<P>
この関数は、PHPにおいて Illustra サポートが有効な場合にのみ
実行可能である。
<P>

<DT><A NAME="mi_numfields"><FONT SIZE="+1">mi_NumFields(接続ID, 結果ID)</FONT></A>
<DD>
<P>mi_NumFields は、Illustra 結果におけるフィールド(カラム)の数を返す。
引数は、mi_Exec により返された有効な結果IDである。
<P>
この関数は、エラーの場合に <STRONG>-1</STRONG> を返す。<P>
<P>
この関数は、PHPにおいて Illustra サポートが有効な場合にのみ
実行可能である。
<P>

<DT><A NAME="mi_numrows"><FONT SIZE="+1">mi_NumRows(接続ID, 結果ID)</FONT></A>
<DD>
<P>mi_NumRows は、Illustra 結果における行の数を返す。
引数は、mi_Exec により返された有効な結果IDである。
<P>
この関数は、エラーの場合に <STRONG>-1</STRONG> を返す。<P>
<P>
この関数は、PHPにおいて Illustra サポートが有効な場合にのみ
実行可能である。
<P>

<DT><A NAME="mi_result"><FONT SIZE="+1">mi_Result(接続ID, 結果ID, 行番号, フィールド名/インデックス)</FONT></A>
<DD>
<P>mi_Result は、mi_Exec により生成された結果IDから値を取り出す。
行番号とフィールド名によりテーブル中のどのセルを返すかを指定する。
フィールド名を指定する代わりに、引用符無しの番号である
フィールドインデックスで指定することもできる。
フィールドインデックスは、0から始まる。
<P>
<P>
現在は、型検出ができないため、データベースから返される全ての値は、文字列型である。
<P>
この関数は、PHPにおいて Illustra サポートが有効な場合にのみ
実行可能である。
<P>

<DT><A NAME="microtime"><FONT SIZE="+1">Microtime()</FONT></A>
<DD>
<P>Microtime() は文字列 "msec sec" を返す。
ここで sec は 1970年1月1日 00:00 GMT からの経過秒数であり、
msec は(秒の一部分である)マイクロ秒の部分である。
例えば、"0.87633900 825010464" である。
<BR>この関数は gettimeofdat() システムコールを
サポートするオペレーティングシステムでのみ使用可能である。<P>

<DT><A NAME="min"><FONT SIZE="+1">Min(配列)</FONT></A>
<DD>
<P>Min は PHP 配列の中で最小値を返す。
すなわち、最小要素を探して配列全体を検索する。
array が文字列の配列である場合には、配列の中でソートした場合に
アルファベット順で最初となる文字列が返される。<P>
    
<DT><A NAME="mkdir"><FONT SIZE="+1">MkDir(ディレクトリ,モード)</FONT></A>
<DD>
<P>MkDir はディレクトリを作る。
<EM>モード</EM> パラメータは<a href="#octal">8進表記</a>で与えなければならない。
例: MkDir("DirName",0755);<P>

<DT><A NAME="mktime"><FONT SIZE="+1">MkTime(hour,min,sec,mon,day,year)</FONT></A>
<DD>
<P>MkTime は引数により指定された日時に対応する時間を Unix タイムスタンプ 
(ロング整数)フォーマット で返す。
与える引数成分が現在のローカル日時に基づいた値に設定されている場合には
引数は省略できる。
この引数の省略は、右から左にのみ可能である。
例えば、 <TT>MkTime(hour,min,sec)</TT> は正しいが、
<TT>MkTime(mon,day,year)</TT> は誤りである。<P>
この関数は、日付計算および日付の有効性確認の両方を行うツールとして
非常に便利であるということに注意されたい。
この関数に 12より大きい月や、31より大きい日付といった
無効なパラメータを与えることができる。
この場合でも、この関数は正しい日付を計算する。
パラメータのどれかが標準の値の外側にある場合にエラーメッセージを
生成したりもする。
関数を呼ぶ前にこのエラー告知を解除するためには、
<a href="#seterrorreporting">SetErrorReporting(0)</a> 関数を
使用すること。
この場合、生じる可能性がある全てのエラーについて $phperrmsg で確認することが
可能である。<P>
例
<PRE>        SetErrorReporting(0);
        $a = MkTime(0,0,0,13,1,1997);
        SetErrorReporting(1);
        echo $phperrmsg;</PRE>

<DT><A NAME="msql"><FONT SIZE="+1">$result = msql($database,$query)</FONT></A>
<DD>
<P>msql は mSQL クエリーを送る。引数はデータベース名とクエリー文字列である。
すなわち、<STRONG><TT>&lt;?msql(&quot;MyDatabase&quot; , &quot;select * from
table&quot;)&gt;</TT></STRONG><STRONG><TT>&lt;?msql(&quot;MyDatabase&quot; , &quot;select * from table&quot;)&gt;</TT></STRONG> である。
この関数から返される値は、他の msql関数から得られる結果にアクセスするための
結果識別子(result identifier)である。結果識別子は、正の整数である。
結果識別子が作成されない場合には、<STRONG>0</STRONG> を返す。
これは何も返さないクエリー、例えば、<EM>create</EM>, <EM>update</EM>,<EM>drop</EM>, <EM>insert</EM> や <EM>delete</EM>の場合である。
エラーが生じた場合、関数は <STRONG>-1</STRONG> を返す。
そのエラーについて記述した文字列が $phperrmsg にセットされる。
msql 関数を <STRONG>@msql()</STRONG> として呼ばない限り、
このエラー文字列の出力も行なわれる。
mSQL 2.0 においては、$result 変数には実行された SQL コマンドにより
作用された行数が返される。
アプリケーションが mSQL 1.0 との互換性を保つためには、
これに依存するべきではない。

<BR>この関数は PHP において mSQL がサポートされている場合のみ利用できる。<P>

  
<DT><A NAME="msql_close"><FONT SIZE="+1">msql_close()</FONT></A>
<DD>
<P>msql_Close は、開かれたソケット結合がある場合には、
msql デーモンに対するその結合を閉じる。
同時に開くことができる mSQL セッションは一つだけなので、
この関数は引数を取らない。    
<P>
    
<DT><A NAME="msql_connect"><FONT SIZE="+1">msql_connect($hostname)</FONT></A>
<DD>
<P>msql_Connect は mSQL データベースエンジンが属するホスト名または IP を
指定する。
これは mSQL の C 言語での API の中の msqlConnect() 関数と同じである。
この関数の C API との唯一の違いは、この関数をコールしなくても
msql() 関数に対する最初のコールが行なわれた際にデフォルトで
ローカルホストへの接続が行なわれるということである。
そして、同時に有効な接続は 1つだけであるので、msql_close 関数は必要ない。
一つのファイル中で msql_connect() の 2回目のコールを行なう場合には、
最初のホストに対する接続は自動的に閉じられる。
ローカルホストの msql デーモンに明示的に接続する為に
<STRONG><TT>&lt;?msql_connect(&quot;localhost&quot;)&gt;</TT></STRONG>
を使う。<BR> この関数は PHP で mSQL がサポートされている場合のみ利用出来る。<P>
      
<DT><A NAME="msql_createdb"><FONT SIZE="+1">msql_CreateDB($database)</FONT></A>
<DD>
<P>msql_CreateDB は与えられたデータベースを作成する。
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="msql_dbname"><FONT SIZE="+1">msql_dbName($result,$i)</FONT></A>
<DD>
<P>msql_dbName は <A HREF="#msql_listdbs">msql_ListDbs()</A> 関数から
返される結果(result)ポインタの <EM>$i</EM> 番目に格納されている
データベース名を返す。
<A HREF="#msql_numrows">msql_NumRows()</A> 関数は有効な
データベース名の数を調べるために使うことができる。
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="msql_dropdb"><FONT SIZE="+1">msql_DropDB($database)</FONT></A>
<DD>
<P>msql_DropDB は指定された mSQL データベース (database)を削除する。
そのデータベース中の全てのデータを失うので注意して使用すること。
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="msql_fieldflags"><FONT SIZE="+1">msql_FieldFlags($result,$i)</FONT></A>
<DD>
<P>msql_FieldFlags は指定されたフィールドのフィールドフラッグを返す。
現在、この返り値は "not null"、"primary key"、これら2つの結合、あるいは ""
(空の文字列)のいずれかである。
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="msql_fieldlen"><FONT SIZE="+1">msql_FieldLen($result,$i)</FONT></A>
<DD>
<P>msql_FieldLen は指定されたフィールドの長さを返す。
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="msql_fieldname"><FONT SIZE="+1">msql_FieldName($result,$i)</FONT></A>
<DD>
<P>msql_FieldName は指定されたフィールドの名前を返す。
関数の引数は結果識別子とフィールドインデックスである。
すなわち、<TT>msql_FieldName($result,2);</TT> は、
結果識別子 (result) に結合された結果において 2番目のフィールド名を返す。
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="msql_fieldtype"><FONT SIZE="+1">msql_FieldType($result,$i)</FONT></A>
<DD>
<P>msql_FieldType は msql_FieldName() 関数と似ている。
引数は全く同じであるが、フィールドの型が返される。
これは、"int"、"char"、"real" のどれかである。
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用できる。<P>

    
<DT><A NAME="msql_freeresult"><FONT SIZE="+1">msql_FreeResult($result)</FONT></A>
<DD>
<P>msql_FreeResult は、スクリプトを走らせる際のメモリー使用量が
多すぎると危惧される場合にのみコールする必要が生じる。
結果(result)を保持する全てのメモリーはスクリプト終了時に自動的に解放される。
しかし、スクリプト中でこれ以上結果のデータを必要としないことが確かならば、
結果識別子を引数として msql_freeresult をコールし、
関連する結果を保持するメモリーを解放することが可能である。
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用できる。<P>  

<DT><A NAME="msql_listdbs"><FONT SIZE="+1">$result = msql_ListDBs()</FONT></A>
<DD>
<P>msql_ListDBs は現在の mSQL デーモンから利用できるデータベースを
含む結果(result)へのポインタを返す。
この結果ポインタの内容にアクセスするには、
<A HREF="#msql_dbname">msql_dbName()</A> 関数を使用すること。
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用できる。<P>

<DT><A NAME="msql_listfields"><FONT SIZE="+1">$result = msql_Listfields($database,$tablename)</FONT></A>
<DD>
<P>msql_Listfields はテーブル名(tablename)で指定されたテーブル
に関する情報を調べる。引数はデータベース名とテーブル名である。
返り値である結果(result)ポインタは、
msql_fieldflags, msql_fieldlen, msql_fieldname, msql_fieldtype で使用
可能である。結果識別子は正の整数である。
エラーを生じた場合には関数は -1 を返す。
そのエラーについて記述した文字列が $phperrmsg にセットされる。
関数を <STRONG>@msql()</STRONG> のように呼ばない限りこのエラー文字列の
出力も行なわれる。
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用できる。<P>

<DT><A NAME="msql_listtables"><FONT SIZE="+1">$result = msql_ListTables($database)</FONT></A>
<DD>
<P>msql_ListTables は <A HREF="#msql">msql()</A> 関数と同様に
データベース名を引数、結果(result)ポインタを返り値とする。
この結果ポインタから実際のテーブル名を展開するには、
<A HREF="#msql_tablename">msql_TableName()</A> 関数を用いる必要がある。
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用できる。<P>

<DT><A NAME="msql_numfields"><FONT SIZE="+1">msql_NumFields($result)</FONT></A>
<DD>
<P>msql_NumFields は結果(result)の中のフィールド数を返す。
引数は msql() 関数で返された結果識別子である。   
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用できる。<P>

<DT><A NAME="msql_numrows"><FONT SIZE="+1">msql_NumRows($result)</FONT></A>
<DD>
<P>msql_NumRows は単に結果(result)の行数を返す。 引数 msql() 関数から
返された結果識別子である。   
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用できる。<P>

<DT><A NAME="msql_regcase"><FONT SIZE="+1">msql_RegCase(string)</FONT></A>
<DD>
<P>msql_RegCase は文字列引数をとり、それを大文字小文字を区別しない
マッチングを行なう際に mSQL に送る必要のある正規表現に変換する。
この関数は文字列 &quot;abc&quot を &quot;[Aa][Bb][Cc]&quot; にすると
いった変換を行なう。
<BR>この関数は PHP で mSQL がサポートされている場合のみ利用できる。<P>

<DT><A NAME="msql_result"><FONT SIZE="+1">msql_Result($result,$i,field)</FONT></A>
<DD>
<P>msql_Result は返されたレコードからフィールド(field)を表示する。
引数は msql() 関数によって返される結果識別子(result)、
表示するレコードのインデックスを示す整数およびフィールド名である。
フィールド名(field)引数は結合関数(join) からの結果を処理するために
&quot;table.field&quot; 構文をサポートしている。
この関数は以下の完全な例により最も良く説明されるであろう。<P>
<P>
<PRE>
    &lt;?
      $name = &quot;bob&quot;;	
      $result = msql($database,&quot;select * from table where firstname='$name'&quot;);
      $num = msql_numrows($result);
      echo &quot;$num records found!&lt;p&gt;&quot;;
      $i=0;
      while($i<$num);
        echo msql_result($result,$i,&quot;fullname&quot;);
        echo &quot;&lt;br&gt;&quot;;
        echo msql_result($result,$i,&quot;address&quot;);
        echo &quot;&lt;br&gt;&quot;;
        $i++;
      endwhile;
    &gt;</PRE><P>
<P>上のスクリプトはローカルマシン上の mSQL エンジンに接続し、
<EM>name</EM> 変数に <EM>bob</EM>  をセットする。
そして、table において <EM>firstname</EM> フィールドが <EM>bob</EM> である
全てのフィールドを検索するクエリーを送る。
見つかったレコードの数を表示した後、見つかったレコードにおいてループを
行ない、レコード毎に <EM>fullname</EM> と <EM>address</EM> フィールドを
表示する。
見ればわかるように、出力するフィールドの前後に HTML タグを付けることにより、
結果を表や望ましい形式にフォーマットすることは簡単である。
msql_connect() が呼ばれていない事に注意されたい。
msql_connect はリモートデータベースへの接続が要求された時にのみ、
呼ばれる必要がある。<P>
<P>
この関数は PHP で mSQL がサポートされている場合のみ使用出来る。<P>
<P>

<DT><A NAME="msql_tablename"><FONT SIZE="+1">msql_TableName($result,$i)</FONT></A>
<DD>
<P>msql_TableName は、<A HREF="#msql_listtables">msql_ListTables()</A> 関数に
よって返される結果(result)ポインタとインデックス整数(i) をとり、
テーブルの名前を返す。
結果ポインタにおけるテーブルの数を定義するために
<A HREF="#msql_numrows">msql_NumRows()</A> 関数が用いられる。
例えば、<P>
<P>
<PRE>
    &lt;?
      $result = msql_listtables(&quot;dbname&quot;);
      $i=0;
      while($i <  msql_numrows($result));
        $tb_names[$i]=msql_tablename($result, $i);
        echo $tb_names[$i];
        echo "&lt;BR&gt;";
        $i++;
      endwhile;
    &gt;</PRE>
<BR>この関数は PHP で mSQL がサポートされている場合のみ使用できる。<P>

  
<DT><A NAME="mysql"><FONT SIZE="+1">$result = mysql($database,$query)</FONT></A>
<DD>
<P>mysql は、mysql クエリーを送信する。
引数は、データベース名とクエリー文字列である。すなわち、
<STRONG><TT>&lt;?mysql(&quot;MyDatabase&quot; , &quot;select * from
table&quot;)&gt;</TT></STRONG>
この関数からの返り値は結果識別子であり、
他の mysql_ 関数により結果にアクセスするために用いられる。
結果識別子は、正の整数である。
関数は、結果識別子が作成されない場合、<STRONG>0</STRONG> を返す。
これは、<EM>create</EM>、<EM>update</EM>、<EM>drop</EM>、<EM>insert</EM>、
<EM>delete</EM>のように結果を何も返さないクエリーの場合である。
エラーの場合に、この関数は、<STRONG>-1</STRONG> を返す。
エラー内容を記述する文字列が $phperrmsg にセットされる。
関数が <STRONG>@mysql()</STRONG> のように呼ばれない限り、
このエラー文字列は出力も行なわれる。
<BR>この関数は、PHP において mysql がサポートされている場合にのみ
使用可能である。<P>

<DT><A NAME="mysql_affected_rows"><FONT SIZE="+1">mysql_affected_rows()</FONT></A>
<DD>
<P>mysql_affected_rows() は、最後の INSERT,UPDATE,DELETE クエリーで
    作用された行の数を返す。<P>
 
<DT><A NAME="mysql_close"><FONT SIZE="+1">mysql_close()</FONT></A>
<DD>
<P>mysql_Close は mysql に対する開かれたソケット結合があるならば、
その結合を閉じる。<P>

<DT><A NAME="mysql_connect"><FONT SIZE="+1">mysql_connect($hostname [,username [,password]])</FONT></A>
<DD>
<P>mysql_Connect は、mysql データベースエンジンが動作する
ホスト名または IP を指定する。
この関数は、mysql の C 言語 API における mysqlConnect() 関数と
等価である。
この関数の C API との唯一の違いは、この関数をコールしなくても
mysql() 関数に対する最初のコールが行なわれた際にデフォルトで
ローカルホストへの接続が行なわれるということである。
そして、同時に有効な接続は 1つだけであるので、mysql_close 関数を呼ぶ必要はない。
一つのファイル中で mysql_connect() の 2回目のコールを行なう場合には、
最初のホストに対する接続は自動的に閉じられる。
オプションでユーザー名とパスワードを与えることができる。
PHP が <a href="#safemode">SAFE MODE</a> で実行するようにコンパイルされている場合、
ユーザ名は、処理されるファイルの所有者または httpd プロセスの所有者(通常は、nobody)のどちらか
と同じである必要がある。他のユーザ名は失敗する。<P>
ローカルホストの mysql デーモンに明示的に接続する為に
<STRONG><TT>&lt;?mysql_connect(&quot;localhost&quot;)&gt;</TT></STRONG>
を使う。<BR> この関数は PHP で mysql がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="mysql_createdb"><FONT SIZE="+1">mysql_CreateDB($database)</FONT></A>
<DD>
<P>mysql_CreateDB は与えられたデータベースを作成する。
<BR>この関数は PHP で mysql がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="mysql_dbname"><FONT SIZE="+1">mysql_dbName($result,$i)</FONT></A>    
<DD>
<P>mysql_dbName は <A HREF="#mysql_listdbs">mysql_ListDbs()</A> 関数から
返される結果(result)ポインタの <EM>$i</EM> 番目に格納されている
データベース名を返す。
<A HREF="#mysql_numrows">mysql_NumRows()</A> 関数は有効な
データベース名の数を調べるために使うことができる。
<BR>この関数は PHP で mysql がサポートされている場合のみ利用出来る。<P>

    
<DT><A NAME="mysql_dropdb"><FONT SIZE="+1">mysql_DropDB($database)</FONT></A>
<DD>
<P>mysql_DropDB は指定された mysql データベース (database)を削除する。
そのデータベース中の全てのデータを失うので注意して使用すること。
<BR>この関数は PHP で mysql がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="mysql_fieldflags"><FONT SIZE="+1">mysql_FieldFlags($result,$i)</FONT></A>
<DD>
<P>mysql_FieldFlags は指定されたフィールドのフィールドフラッグを返す。
現在、この返り値は "not null"、"primary key"、これら2つの結合、あるいは ""
(空の文字列)のいずれかである。
<BR>この関数は PHP で mysql がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="mysql_fieldlen"><FONT SIZE="+1">mysql_FieldLen($result,$i)</FONT></A>
<DD>
<P>mysql_FieldLen は指定されたフィールドの長さを返す。
<BR>この関数は PHP で mysql がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="mysql_fieldname"><FONT SIZE="+1">mysql_FieldName($result,$i)</FONT></A>
<DD>
<P>mysql_FieldName は指定されたフィールドの名前を返す。
関数の引数は結果識別子とフィールドインデックスである。
すなわち、<TT>mysql_FieldName($result,2);</TT> は、
結果識別子 (result) に結合された結果において 2番目のフィールド名を返す。
<BR>この関数は PHP で mysql がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="mysql_fieldtype"><FONT SIZE="+1">mysql_FieldType($result,$i)</FONT></A>
<DD>
<P>mysql_FieldType は mysql_FieldName() 関数と似ている。
引数は全く同じであるが、フィールドの型が返される。
これは、"int"、"char"、"real" のどれかである。
<BR>この関数は PHP で mysql がサポートされている場合のみ利用できる。<P>
 
<DT><A NAME="mysql_freeresult"><FONT SIZE="+1">mysql_FreeResult($result)</FONT></A>
<DD>
<P>mysql_FreeResult は、スクリプトを走らせる際のメモリー使用量が
多すぎると危惧される場合にのみコールする必要が生じる。
結果(result)を保持する全てのメモリーはスクリプト終了時に自動的に解放される。
しかし、スクリプト中でこれ以上結果のデータを必要としないことが確かならば、
結果識別子を引数として mysql_freeresult をコールし、
関連する結果を保持するメモリーを解放することが可能である。
<BR>この関数は PHP で mysql がサポートされている場合のみ利用できる。<P>  

<DT><A NAME="mysql_insert_id"><FONT SIZE="+1">mysql_insert_id()</FONT></A>
<DD>
<P>mysql_insert_id() は、AUTO_INCREMENT フィールドで生成された ID を返す。
    この関数は、引数を取らない。
    この関数は、最後の INSERT クエリーが実行された際に、自動的に生成された
    ID を返す。<P>
    
<DT><A NAME="mysql_listdbs"><FONT SIZE="+1">$result = mysql_ListDBs()</FONT></A>
<DD>
<P>mysql_ListDBs は現在の mysql デーモンから利用できるデータベースを
含む結果(result)へのポインタを返す。
この結果ポインタの内容にアクセスするには、
<A HREF="#mysql_dbname">mysql_dbName()</A> 関数を使用すること。
<BR>この関数は PHP で mysql がサポートされている場合のみ利用できる。<P>

<DT><A NAME="mysql_listfields"><FONT SIZE="+1">$result = mysql_Listfields($database,$tablename)</FONT></A>
<DD>
<P>mysql_Listfields はテーブル名(tablename)で指定されたテーブル
に関する情報を調べる。引数はデータベース名とテーブル名である。
返り値である結果(result)ポインタは、
mysql_fieldflags, mysql_fieldlen, mysql_fieldname, mysql_fieldtype で使用
可能である。結果識別子は正の整数である。
エラーを生じた場合には関数は -1 を返す。
そのエラーについて記述した文字列が $phperrmsg にセットされる。
関数を <STRONG>@mysql()</STRONG> のように呼ばない限りこのエラー文字列の
出力も行なわれる。
<BR>この関数は PHP で mysql がサポートされている場合のみ利用できる。<P>

<DT><A NAME="mysql_listtables"><FONT SIZE="+1">$result = mysql_ListTables($database)</FONT></A>
<DD>
<P>mysql_ListTables は <A HREF="#msql">mysql()</A> 関数と同様に
データベース名を引数、結果(result)ポインタを返り値とする。
この結果ポインタから実際のテーブル名を展開するには、
<A HREF="#mysql_tablename">mysql_TableName()</A> 関数を用いる必要がある。
<BR>この関数は PHP で mysql がサポートされている場合のみ利用できる。<P>

<DT><A NAME="mysql_numfields"><FONT SIZE="+1">mysql_NumFields($result)</FONT></A>
<DD>
<P>mysql_NumFields は結果(result)の中のフィールド数を返す。
引数は mysql() 関数で返された結果識別子である。   
<BR>この関数は PHP で mysql がサポートされている場合のみ利用できる。<P>
 
<DT><A NAME="mysql_numrows"><FONT SIZE="+1">mysql_NumRows($result)</FONT></A>
<DD>
<P>mysql_NumRows は単に結果(result)の行数を返す。 引数 mysql() 関数から
返された結果識別子である。   
<BR>この関数は PHP で mysql がサポートされている場合のみ利用できる。<P>

<DT><A NAME="mysql_result"><FONT SIZE="+1">mysql_Result($result,$i,field)</FONT></A>
<DD>
<P>mysql_Result は返されたレコードからフィールド(field)を表示する。
引数は mysql() 関数によって返される結果識別子(result)、
表示するレコードのインデックスを示す整数およびフィールド名である。
フィールド名(field)引数は結合関数(join) からの結果を処理するために
&quot;table.field&quot; 構文をサポートしている。
mSQL 1.0 と mysql の間の違いの一つは、mysql が結果データに
作用する関数をサポートしていることである。
それらの関数は、この関数において用いることができる。
この関数は以下の完全な例により最も良く説明されるであろう。<P>
<P>
<PRE>
    &lt;?
      $name = &quot;bob&quot;;	
      $result = mysql($database,&quot;select * from table where firstname='$name'&quot;);
      $num = mysql_numrows($result);
      echo &quot;$num records found!&lt;p&gt;&quot;;
      $i=0;
      while($i<$num);
        echo mysql_result($result,$i,&quot;lcase(fullname)&quot;);    
        echo &quot;&lt;br&gt;&quot;;
        echo mysql_result($result,$i,&quot;address&quot;);
        echo &quot;&lt;br&gt;&quot;;
        $i++;
      endwhile;
    &gt;
</PRE><P>
<P>
<P>上のスクリプトはローカルマシン上の mysql エンジンに接続し、
<EM>name</EM> 変数に <EM>bob</EM>  をセットする。
そして、table において <EM>firstname</EM> フィールドが <EM>bob</EM> である
全てのフィールドを検索するクエリーを送る。
見つかったレコードの数を表示した後、見つかったレコードにおいてループを
行ない、レコード毎に <EM>fullname</EM> と <EM>address</EM> フィールドを
表示する。
result 関数における lcase() のコールは、
返された文字列を小文字に変換する。
結果データに対して適用可能な関数の完全なリストについては、
mysql のドキュメントを参照のこと。
見ればわかるように、出力するフィールドの前後に HTML タグを付けることにより、
結果を表や望ましい形式にフォーマットすることは簡単である。
mysql_connect() が呼ばれていない事に注意されたい。
mysql_connect はリモートデータベースへの接続が要求された時にのみ、
呼ばれる必要がある。<P>
<P>
この関数は PHP で mysql がサポートされている場合のみ使用出来る。<P>
<P>

<DT><A NAME="mysql_tablename"><FONT SIZE="+1">mysql_TableName($result,$i)</FONT></A>
<DD>
<P>mysql_TableName は、<A HREF="#mysql_listtables">mysql_ListTables()</A>
関数によって返される結果(result)ポインタとインデックス整数(i) をとり、
テーブルの名前を返す。
結果ポインタにおけるテーブルの数を定義するために
<A HREF="#mysql_numrows">mysql_NumRows()</A> 関数が用いられる。
例えば、<P>
<P>
<PRE>
    &lt;?
      $result = mysql_listtables(&quot;dbname&quot;);
      $i=0;
      while($i <  mysql_numrows($result));
        $tb_names[$i]=mysql_tablename($result, $i);
        echo $tb_names[$i];
        echo "&lt;BR&gt;";
        $i++;
      endwhile;
    &gt;
</PRE>
<BR>この関数は PHP で mSQL がサポートされている場合のみ使用できる。<P>    
    
<DT><A NAME="next"><FONT SIZE="+1">Next(変数)</FONT></A>
<DD>
<P>Next は配列の内部ポインタを配列中の次の要素に移動させる。
配列がインデックス無し法($array[])を用いてアクセスされた時に
この関数は自動的に呼ばれる。この関数は新しい要素の値を返す。
この関数は配列に明示的にアクセスすることなしに
ポインタを前方へ移動させる事が出来る。
一つの使用法としては次のようなものがある。
この例では、連想配列を連続的にアクセスし、配列のキーのみを出力し
実際の内容は出力しない。
<P>
<P>    
<PRE>    &lt;?
      Reset($array);
      $i=0;
      while($i &lt; count($array));
        echo key($array);
        next($array);
        $i++;
      endwhile;
    &gt;</PRE><P>

<DT><A NAME="octdec"><FONT SIZE="+1">OctDec(8進数)</FONT></A>
<DD>
<P>OctDec は8進数を10進数に変換する。<A HREF="#decoct">DecOct()</A>も
参照のこと。<P>

<DT><A NAME="opendir"><FONT SIZE="+1">openDir(ディレクトリ)</FONT></A>
<DD>
<P>openDir は指定されたディレクトリを開き、
ディレクトリの始めに内部ポインタを置く。
ディレクトリのエントリーは <A HREF="#readdir">readDir</A> 関数を
使って読まれ、
開かれたディレクトリは <A HREF="#closedir">closeDir</A> 関数で閉じる。<P>

<DT><A NAME="openlog"><FONT SIZE="+1">OpenLog(ident,options,facility)</FONT></A>
<DD>
<P>
OpenLog() は、後に行われる Syslog() コールのためにシステムを初期化する。
更に詳細な情報は、openlog(3) UNIX man ページを参照のこと。
<a href="#initsyslog">InitSyslog()</a>、<a href="#syslog">Syslog()</a> 、
<a href="#closelog">CloseLog()</a> も参照のこと。
<P>

<DT><A NAME="ora_bind"><FONT SIZE="+1">Ora_Bind(カーソルID, 
PHP変数名, SQL変数名, サイズ)</FONT></A><BR>
<DD>Ora_Bind() は、PHP 変数を Oracle の変数に割付ける。
<BR><BR>
この関数パラメータは次のようなものである。:<BR>
<DT><DD><VAR>カーソルID</VAR> - _parsed_ SQL クエリーまたは PL/SQL ブロック用の
Oracle カーソルID<BR>
<VAR>PHP変数名</VAR> - '$' で始まる PHP スクリプトにおける変数名。<BR>
<VAR>SQL変数名</VAR> - コロンで始まる SQL 変数名<BR>
<VAR>サイズ</VAR> - 変数割付時に考慮される最大バイト数<BR><BR>
</DT>
<B>注意:</B> <BR>
1) PHP 変数は、返されるだけの変数である場合でも
<B>サイズ</B> バイトの長さ以上で初期化されなければ<B>ならない</B>。
<BR>

2) Ora_Bind() は、Ora_Parse の後で、かつ Ora_Exec の前に
使用されなければ<B>ならない</B>。
SQL 文を再解釈する場合には、全ての使用される変数は、元に戻されている
必要がある。
<BR><BR>
Ora_Bind() は、成功した場合に 0を、失敗した場合に -1 を返す。<BR>
<P>
以下に Ora_Bind() の使用例を示す。<BR>
<PRE>

        /* This is the PHP variable to be bound */
        $rc  = "12345";

        /* This is the SQL query. */
        $query = "SELECT * FROM my_table where my_index = :indiana";
        
        ........

        if (Ora_Parse($cursor, $query) < 0) {
            echo("Parse failed!\n")
            Ora_Logoff($conn);
            exit;
        } 

        if (Ora_Bind($cursor, "rc", ":indiana", strlen($rc)) < 0) {
            echo("Binding failed!\n")
            Ora_Logoff($conn);
            exit;
        } 

        /* Execute the SQL statement associated with $cursor and
        prepare storage for select-list items. */
        $ncols = Ora_Exec($cursor);
        
        ......

</PRE>
<P>

<DT><A NAME="ora_close"><FONT SIZE="+1">Ora_Close(接続ID)</FONT></A>
<DD>Ora_Close() は、<var>接続ID</var> により定義された
Oracle 接続を閉じる。成功した場合に 0、失敗した場合に -1 を返す。
<P>

<DT><A NAME="ora_commit"><FONT SIZE="+1">Ora_Commit(接続ID)</FONT></A>
<DD>カレントの処理(トランザクション)を <var>接続ID</var> に引き渡す。
カレントの処理は、<A HREF="#ora_logon">Ora_Logon()</A> コール、
直近の Ora_Commit()、<A HREF="#ora_rollback">Ora_Rollback()</A> から始まり、
Ora_Commit()、<A HREF="#ora_rollback">Ora_Rollback()</A>、
<A HREF="#ora_logoff">Ora_Logoff()</A> コールが発行されるまで続く。
Ora_Commit() は、失敗した場合に -1 (とエラーメッセージ)を返す。<P>

<DT><A NAME="ora_commitoff"><FONT SIZE="+1">Ora_CommitOff(接続ID)</FONT></A>
<DD>Ora_CommitOff() は、Oracle <var>接続ID</var> に関して
    autocommit (各 SQL データ操作命令毎に自動的に渡される。)
    をオフにする。
<P>

<DT><A NAME="ora_commiton"><FONT SIZE="+1">Ora_CommitOn(接続ID)</FONT></A>
<DD>Ora_CommitOn() は、Oracle <var>接続ID</var> に関して
    autocommit (各 SQL データ操作命令毎に自動的に渡される。)
    をオンにする。
<P>    

<DT><A NAME="ora_exec"><FONT SIZE="+1">Ora_Exec(カーソルID)</FONT></A>
<DD>Ora_Exec() は、<var>カーソルID</var> に関連する SQL 命令を実行し、
選択リスト項目用の記憶領域を準備する。
返り値は、選択されたカラムの数である。エラーの場合 -1 を返す。
<P>

<DT><A NAME="ora_fetch"><FONT SIZE="+1">Ora_Fetch(カーソルID)</FONT></A>
<DD>Ora_Fetch() は、データベースから1行分のデータを取り出す。
1 カラム分のデータが取り出された場合に 1、1カラムもデータが取り出せない
場合に 0 、エラーの場合に -1 を返す。
<P>

<DT><A NAME="ora_getcolumn"><FONT SIZE="+1">Ora_GetColumn(カーソルID,
カラム)</FONT></A>
<DD>Ora_GetColumn() は、返された行において指定したカラムのデータを
取り出す。
<A HREF="ora_fetch">Ora_Fetch()</A> が、Ora_GetColumn() の前にコールされて
いなければならない。
<P>
    
<DT><A NAME="ora_logoff"><FONT
SIZE="+1">Ora_Logoff(接続ID)</FONT></A>
<DD>Ora_Logoff() は、<var>接続ID</var> に属するログオンデータエリアの
接続を切り、Oracle で使用されるリソースを開放する。<P>

<DT><A NAME="ora_logoff"><FONT
SIZE="+1">Ora_Logon(ユーザーID, パスワード)</FONT></A>
<DD>Ora_Logon() は、指定したユーザーID とパスワードで
PHP と Oracle データベースの接続を確立する。
成功した場合に 0 、失敗した場合に -1 を返す。
<P>

<DT><A NAME="ora_open"><FONT SIZE="+1">Ora_Open(接続ID)</FONT></A>
<DD>Ora_Open() は、Oracle において SQL 命令の処理に関する情報を維持する
カーソルを開く。
カーソルのインデックスを返す。失敗した場合には -1 を返す。
<P>
    
<DT><A NAME="ora_parse"><FONT SIZE="+1">Ora_Parse(カーソルID,
SQL命令 [, defer])</FONT></A>
<DD>Ora_Parse() は、SQL 命令または PL/SQL ブロックを処理し、
それをカーソルに関連づける。オプションの 3 番目の引数は、
処理を延期する場合に 1 をセットする。
成功した場合に 0 、失敗した場合に -1 を返す。
<P>

<DT><A NAME="ora_rollback"><FONT
SIZE="+1">Ora_Rollback(カーソルID)</FONT></A>
<DD>Ora_Rollback() は、カレントの処理を元に戻す。
カレントの処理の定義については、<A HREF="#ora_commit">Ora_Commit()</A> を
参照のこと。<P>

<DT><A NAME="ord"><FONT SIZE="+1">Ord(引数)</FONT></A>
<DD>
<P>Ord は引数の最初の文字の ASCII 値を返す。<P>

  
<DT><A NAME="parse_str"><FONT SIZE="+1">Parse_Str(引数)</FONT></A>
<DD>
<P>Parse_str は、標準のURLエンコードされた文字列と同じ形式の文字列をとり、
変数とその値に展開する。<br>
例えば、
<PRE>    &lt;? parse_str("a[]=hello+world&amp;a[]=second+variable");
        echo $a[],"&lt;br&gt;";
        echo $a[],"&lt;br&gt;";
    &gt;
は、以下のような出力を行なう。

hello world
second variable</PRE>

    
<DT><A NAME="passthru"><FONT SIZE="+1">PassThru(コマンド文字列 [,返り値])</FONT></A>
<DD>
<P>The PassThru() 関数は内部で Unix コマンドを実行する
<a href="#exec">Exec()</a> 関数と似ている。
返り値引数が存在する場合には、ここに Unix コマンドの返り値が
セットされる。
Unix コマンドからの出力がバイナリデータであり、ブラウザに直接渡す必要が
ある場合には、Exec やSystem の代わりにこのコマンドを用いる必要がある。
通常、この関数を使用するのはイメージストリームを直接出力出来る
pbmplus ユーティリティーのようなものを実行する時である。
content-type に <em>image/gif</em> を設定し、
gif を出力する pbmplus プログラムを呼ぶことにより、
イメージを直接出力する PHP/FI スクリプトを作る事が出来る。  <P>

<DT><A NAME="pclose"><FONT SIZE="+1">pclose(fp)</FONT></A>
<DD>
<P>Pclose は <A HREF="#popen">popen()</A> 関数を使って開いたパイプを閉じる関数である。<P>

    
<DT><A NAME="pg_close"><FONT SIZE="+1">pg_Close(接続ID)</FONT></A>
<DD>
<P>pg_Close は指定された接続識別子で関連づけられる Postgres データベース
への接続を閉じる。<P>

<P>この関数は PHP で Postgres がサポートされている場合のみ使用出来る。<P>

<DT><A NAME="pg_connect"><FONT SIZE="+1">$connection = pg_Connect(ホスト, ポート, オプション, tty, データベース名)</FONT></A>
<DD>
<P>pg_Connect は Postgres データベースへの接続を開く。
それぞれの引数はポート番号を含めてクオートされた文字列である必要がある。
引数のうちオプションと tty はオプションであり、空の文字列とすることが
可能である。この関数は接続IDを返す。
この識別子は他の Postgres の関数を使用する場合に必要である。
同時に複数の接続も可能である。
エラーを生じた場合、この関数は <STRONG>0</STRONG> を返す。<P>
<P>この関数は PHP で Postgres がサポートされている時のみ使用できる。<P>

<DT><A NAME="pg_dbname"><FONT SIZE="+1">pg_DBname(接続ID)</FONT></A>
<DD>
<P>pg_DBname は、与えられた Postgres の接続IDが接続している
データベースの名前を返す。<P>

この関数は PHP で Postgres がサポートされている時のみ使用できる。<P>

<DT><A NAME="pg_errorMessage"><FONT SIZE="+1">pg_ErrorMessage(接続ID)</FONT></A>
<DD>
<P>有効な接続が存在する時に最新のデータベースの動作でエラーが生じた
場合には、この関数は back-end サーバにより作成されたエラーメッセージを
含んだ文字列を返す。<P>

<P>この関数は PHP で Postgres がサポートされている場合使用のみ使用できる。<P>

<DT><A NAME="pg_exec"><FONT SIZE="+1">$result = 
pg_Exec(接続ID, クエリー文字列)</FONT></A>
<DD>
<P>pg_Exec は 接続ID にて指定された Postgres データベースに
SQL 命令を送る。
この 接続ID は pg_Connect により返された有効な識別子で
なければならない。
この関数の返り値は識別子であり、他の Postgres の関数が結果にアクセスする際に
用いられる。
この関数はエラーの時に <STRONG>0</STRONG> を返す。
コマンドが正常に実行されたがデータが返って来るのが期待できない場合
(例えば insert や update コマンド)には <STRONG>1</STRONG> を返す。
ただし、データ無し(no data)を返す select は 1 より大きな有効な result を返す
ことに注意されたい。<P>

<P>この関数は PHP で Postgres がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="pg_fieldname"><FONT SIZE="+1">
pg_FieldName(結果ID, フィールド番号)</FONT></A>
<DD>
<P>pg_FieldName は、Postgres の結果IDにおいて、指定した
フィールド番号を有するフィールド名を返す。
フィールド番号は 0 から始まる。<P>
<P>この関数は PHP で Postgres がサポートされている場合のみ利用できる。<P>

<DT><A NAME="pg_fieldprtlen"><FONT SIZE="+1">pg_FieldPrtLen(結果ID, 行番号
,フィールド名)</FONT></A>
<DD>
<P>pg_FieldPrtLen は Postgres の結果IDにおいて
指定された値の実際に出力された長さ(文字の数)を返す。
行数は 0 から始まる。
エラーを生じた場合にこの関数は <STRONG>-1</STRONG> を返す。<P>
<P>この関数は PHP で Postgres がサポートされている場合のみ利用出来る。<P>

<DT><A NAME="pg_fieldnum"><FONT SIZE="+1">pg_FieldNum(結果ID, 
フィールド名)</FONT></A>
<DD>
<P>pg_FieldNum は、与えられた Postgres の結果IDにおいて
フィールド名と一致するカラム位置の番号を返す。
フィールド番号は 0 から始まる。この関数はエラーの時に -1 を返す。<P>
<P>この関数は PHP で Postgres がサポートされている場合のみ使用出来る。<P>

<DT><A NAME="pg_fieldsize"><FONT SIZE="+1">pg_FieldSize(
結果ID, フィールド名)</FONT></A>
<DD>
<P>pg_FieldSize は、与えられた Postgres の結果IDにおいて
フィールド名で指定されるフィールドの内部記憶領域の大きさを
(バイト数で)返す。
<P>
<P>この関数は PHP で Postgres がサポートされている場合のみ使用できる。<P>

<DT><A NAME="pg_fieldtype"><FONT SIZE="+1">pg_FieldType(
結果ID, フィールド番号)</FONT></A>
<DD>
<P>pg_FieldType は、与えられた Postgres の結果IDにおいて、
指定したフィールド番号の型の名前を含んだ文字列を返す。
フィールド番号は 0 から始まる。<P>
<P>この関数は PHP で Postgres がサポートされている場合のみ使用できる。<P>

<DT><A NAME="pg_freeresult"><FONT SIZE="+1">pg_FreeResult(結果ID)</FONT></A>
<DD>
<P>スクリプト実行時にメモリ使用量が非常に多いと危惧される場合にのみ
pg_FreeResult は呼ばれる必要を生じる。
スクリプト終了時にメモリは自動的に解放される。
しかし、スクリプトの中でこれ以上結果データを必要としないことが
確実である場合には、結果IDを引数として
pg_freeresult 呼び出すことが可能である。
これにより、関連する結果を保持するメモリが解放される。
<P>
<P>この関数は PHP で Postgres がサポートされている場合のみ使用できる。<P>

<DT><A NAME="pg_getlastoid"><FONT SIZE="+1">pg_GetLastOid()</FONT></A>
<DD>
<P>
pg_GetLastOid は、
pg_Exec 経由で送られた最後のコマンドが SQL 挿入である場合に
挿入されたタプル(集合)に割り当てられた Oid を検索する事が出来る。
この関数は、有効な Oid があれば正の整数を返す。
エラーが起こったり、pg_Exec により送られた最後のコマンドが
挿入ではない場合に <STRONG>-1</STRONG> を返す。<P>

<P>この関数は PHP で Postgres がサポートされている場合のみ使用できる。<P>

<DT><A NAME="pg_host"><FONT SIZE="+1">pg_Host(接続ID)</FONT></A>
<DD>
<P>pg_Host は与えられた Postgres の接続IDが
接続しているホスト名を返す。
<P>この関数は PHP で Postgres がサポートされている場合のみ使用できる。<P>

<DT><A NAME="pg_numfields"><FONT SIZE="+1">pg_NumFields(結果ID)</FONT></A>
<DD>
<P>pg_NumFields は Postgres の結果のフィールド(カラム)数を返す。
引数は pg_Exec によって返された有効な結果IDである。
この関数はエラーの時には <STRONG>-1</STRONG> を返す。
<P>
この関数は PHP で Postgres がサポートされている場合のみ使用できる。
<P>
    
<DT><A NAME="pg_numrows"><FONT SIZE="+1">pg_NumRows(result_id)</FONT></A>
<DD>
<P>pg_NumRows は Postgres の結果の行数を返す。
引数は pg_Exec で返された有効な結果識別子(result_id)である。
この関数はエラーの時には <STRONG>-1</STRONG> を返す。<P>
<P>この関数は PHP でPostgres がサポートされている場合のみ使用できる。<P>

<DT><A NAME="pg_options"><FONT SIZE="+1">pg_Options(接続ID)</FONT></A>
<DD>
<P>pg_Options は与えられた Postgres の接続IDにおいて
指定されたオプションを含む文字列を返す。<P>

<P>この関数は PHP で Postgres がサポートされている場合のみ使用できる。<P>

<DT><A NAME="pg_port"><FONT SIZE="+1">pg_Port(接続ID)</FONT></A>
<DD>
<P>pg_Port は与えられた Postgres の接続IDが接続するポート番号を返す。<P>

<P>この関数は PHP でPostgres がサポートされている場合のみ使用できる。<P>

<DT><A NAME="pg_result"><FONT SIZE="+1">pg_Result(結果ID, 行番号, フィールド名/インデックス)</FONT></A>
<DD>
<P>pg_Result は pg_Exec にて作成された結果IDから
実際の値を返す。
行番号とフィールド名は、返す結果のテーブルの中における
セル位置を指定する。行番号は 0 から始まる。
フィールドを名前で指定する代わりに、前方引用符無しの番号で表した
フィールドインデックスを使うことも可能である。
フィールドインデックスは 0 から始まる。
<P>
Postgres は多くの組み込み型を持っているが、
ここでは基本的な型だけが直接サポートされている。
整数(integer)、boolean や oid 型は全て整数値で返される。
浮動小数点(float)や実数(real) 型は全て倍精度値で返される。
配列を含む他の型は、同じくデフォルトの Postgres 形式で
フォーマットされた文字列で返される。
これは、'monitor' や 'psql' プログラムにおいても同様である。
<P>Postgres の結果から数値や文字列を含む PHP 配列を返す機能については、
今後のサポートを予定している。
<P>この関数は PHP で Postgres がサポートされている場合のみ使用できる。<P>

<DT><A NAME="pg_tty"><FONT SIZE="+1">pg_tty(接続ID)</FONT></A>
<DD>
<P>pg_tty は、与えられた Postgres の接続識別子(接続ID)において
サーバ側のデバッグ情報出力が送られる tty 名を返す。<P>

<P>この関数は PHP で Postgres がサポートされている場合のみ使用できる。<P>

<DT><A NAME="phpinfo"><FONT SIZE="+1">phpInfo()</FONT></A>
<DD>
<P>phpInfo は PHP/FI により処理される URL に &quot;?info&quot; を加えた時、
または php.cgi バイナリ自体を起動した時に得られるページと
同じページを出力する。
この関数は多くの有益な内部データを表示するので、Apache モジュール版において
デバッグを行なう際に特に便利である。
<P>

<DT><A NAME="phpversion"><FONT SIZE="+1">phpVersion()</FONT></A>
<DD>
<P>phpVersion は現在動作している PHP/FI のバージョンを返す。<P>

<DT><A NAME="popen"><FONT SIZE="+1">fp = popen(コマンド,モード)</FONT></A>
<DD>
<P>Popen はコマンドへのパイプを開き、ファイルのポインタインデックスを返す。
このファイルのポインタインデックスは、<A HREF="#fgets">fgets</A>、
<A HREF="#fputs">fputs</A>、<A HREF="#fclose">fclose</A>で使う事が出来る。
引数は実行するコマンドとモードである。
このモードには読み取り用には &quot;r&quot; 、書き込み用には &quot;w&quot;
のいずれかを用いる。
より詳細な情報は、UNIX の C ライブラリ中の popen の man ページを参照のこと。
popen で開いたファイルは、<A HREF="#pclose">pclose()</A> 関数で閉じる事が
出来る。<P>

<DT><A NAME="pos"><FONT SIZE="+1">pos(配列)</FONT></A>
<DD>
<P>Pos() 関数は、配列における要素の位置を数値で返す。
この関数は、通常の配列ではあまり役に立たないが、
連想配列では便利である。</P>

<DT><A NAME="pow"><FONT SIZE="+1">pow(x,y)</FONT></A>
<DD>
<P>x の y 乗を計算する。<a href="#exp">Exp()</a> も参照のこと。<P>

<DT><A NAME="prev"><FONT SIZE="+1">Prev(変数)</FONT></A>
<DD>
<P>Prev は与えられた変数について内部配列ポインタを
配列中の前の要素に移動する。
既にリストの始めにある場合には、ポインタは最初の要素を指す。
この関数は新しい要素の値を返す。
この関数は連想配列を逆順に遡る時に有用である。
<A HREF="#end">End()</A> の定義における例を参照のこと。
また、<A HREF="#next">Next()</A> も参照のこと。<P>

<DT><A NAME="putenv"><FONT SIZE="+1">PutEnv(文字列)</FONT></A>
<DD>
<P>PutEnv は環境変数に与えられた文字列をセットする。
あるページにおいて PHP の実行が終了するとローカルな環境変数は
消去されるので、非常に有効というわけではない。
しかし、ある PHP スクリプトからコールした他のプログラムが環境変数を
チェックするような場合には、便利である。
例えば、複数の mSQL のデーモンプロセスを実行させたい場合、
異なったソケット間を行き来するために PutEnv を使う必要がある。<P>

<DT><A NAME="quotemeta"><FONT SIZE=+1>QuoteMeta(引数)</FONT></A>
<DD>
<P>QuoteMeta は引数の中の正規表現の特殊文字を
バックスラッシュでエスケープした文字列を返す。</P>
   
<DT><A NAME="rand"><FONT SIZE=+1>Rand()</FONT></A>
<DD>
<P>Rand は0からRANDMAXまでの間の乱数を返す。
rand() をコールする前に、<a href="#srand">srand()</a> をコールして    
乱数ジェネレータに乱数の種(seed)を与えることを<B>覚えておくこと</B>。
乱数ジェネレータに種を与えるのは、一度だけで良い。    
RANDMAXは<A HREF="#getrandmax">getRandMax</A>
関数で求めることができる。通常、戻り値に対して単に係数をかけることにより
特定の範囲を指定する。</P>

<DT><A NAME="readdir"><FONT SIZE=+1>readDir()</FONT></A>
<DD>
<P>readDir は現在開いているディレクトリ構造の次のエントリーを読み込む。
一度エントリーが読み込まれると、ポインターはそのディレクトリの次のエントリーへ移動し、
次回のこの関数の呼出ではそのディレクトリの次のエントリーが返される。
この関数を呼び出す前に<A HREF="#opendir">openDir</A>関数でディレクトリを
開くこと。</P>

<DT><A NAME="readfile"><FONT SIZE="+1">ReadFile(ファイル名)</FONT></A>
<DD>
<P>$size = ReadFile(Filename) - は、ファイル Filename を読み込み、
これを単に直接出力する。この関数は、実際に読みこんだバイト数を返す。
この関数は、ファイルをメモリに保存しないという点で  File() コマンドとは
異なっている。また、バイナリファイルに関しても安全に使用できる。
この関数は、通常、PassThru("cat filename") として行っていた
ケースで使用される。ReadFile を使用する方がより効率的である。<P>
    
<DT><A NAME="readlink"><FONT SIZE=+1>ReadLink(パス)</FONT></A>
<DD>
<P>ReadLinkはC言語関数のreadlinkと同様の動作をし、シンボリックリンクの内容または
エラー時に-1を返す。<A HREF="#linkinfo">LinkInfo</A>も参照のこと。</P>

<DT><A NAME="reg_match"><FONT SIZE=+1>reg_Match(
正規表現,引数文字列[,regs])</FONT></A>
<DD>
<P>reg_Matchは引数文字列に正規表現がマッチするとゼロでない数字を返す。
例えば、<TT>&lt;?if (reg_match(&quot;^This.*&quot;,&quot;This is an example string&quot;)&gt;
</TT>は&quot;^This.*&quot;が<STRONG>This</STRONG>という語が先頭にある文字列で
その後はどのような文字にもマッチするため真を返すであろう。
引数<EM>regs</EM>がある場合には、
マッチレジスタの値が引数<EM>regs</EM>という名前の配列の0〜10の位置に代入される。
レジスタ 0 には常にマッチした文字列全体が代入される。正規表現の詳細については、
この文書の<A HREF="#regexp">正規表現の節</A>を参照のこと。</P>

<DT><A NAME="reg_replace"><FONT SIZE=+1>reg_replace(
正規表現,置換文字列,引数文字列)</FONT></A>
<DD>
<P>reg_Replace は引数の文字列を全て検索し、表現にマッチした文字列の部分を全て
置換文字列に指定されたものに置き換える。例えば、<TT>&quot;This is an example string&quot;</TT>
という文字列について、次のようなコマンドを用いて非常に簡単に
すべての空白文字をダッシュに置き換えることができる。
<STRONG>reg_replace(" ","-","This is an example string")</STRONG>
正規表現の詳細については、この文書のこの文書の<A HREF="#regexp">正規表現の節</A>を参照のこと。</P>


<DT><A NAME="reg_search"><FONT SIZE=+1>reg_Search(
正規表現,引数文字列[,regs])</FONT></A>
<DD>
<P>reg_Search は引数の文字列の全てについて与えられた正規表現に
マッチするものを検索する。
もしマッチするものが見つかったならば、マッチが成立したところから始まる
文字列の部分を返す。
もしマッチするものが見つからない場合には、長さゼロの文字列が戻される。
引数<EM>regs</EM>がある場合には、マッチレジスタの値が引数<EM>regs</EM>
という名前の配列の0〜10の位置に代入される。レジスタ 0 には常にマッチした文字列全体が代入される。
正規表現の詳細については、この文書の<A HREF="#regexp">正規表現の節</A>を参照のこと。</P>


<DT><A NAME="rename"><FONT SIZE=+1>Rename(old,new)</FONT></A>
<DD>
<P>Rename はファイルの名前を old から new に変更する。
Unix C の rename()関数と同様である。


<DT><A NAME="reset"><FONT SIZE=+1>Reset(変数)</FONT></A>
<DD>
<P>Reset は与えられた配列変数について、内部ポインタをその配列の先頭に移動し、
そのアイテムの値を返す。この関数は連想配列または添字無し配列の内部で移動する
際に便利である。<A HREF="#end">End()</A>と<A HREF="#next">Next()</A>も参照のこと。
次の例は連想配列中を移動するものである。</P>

<P>
<PRE>    &lt;?
      Reset($array);
      $i=0;
      while($i &lt; count($array));
        echo $array[]; /* pointer automatically moves ahead one */
        $i++;
      endwhile;
    &gt;</PRE></P>


<DT><A NAME="return"><FONT SIZE=+1>return(値)</FONT></A>
<DD>
<P>Return は現在の関数呼出を終了し、指定された値を呼出元に返す。
より詳しい情報については<A HREF="#user_funcs">ユーザ定義関数</A>を参照のこと。</P>


<DT><A NAME="rewind"><FONT SIZE=+1>rewind(fd)</FONT></A>
<DD>
<P>rewind() は引数 fd で指定されたファイルポインタをリセットする。
引数 fd は <A HREF="#fopen">fopen()</A>の戻り値である。
ファイルポインタはファイルの先頭に置かれる。
<A HREF="#ftell">ftell()</A>と<A HREF="#fseek">fseek()</A>も参照のこと。</P>


<DT><A NAME="rewinddir"><FONT SIZE=+1>rewindDir()</FONT></A>
<DD>
<P>rewindDir は現在のディレクトリポインタをそのディレクトリの先頭に戻す。
この関数を使用する前に<A HREF="#opendir">openDir</A>関数でディレクトリを
開かなくてはならない。</P>


<DT><A NAME="rmdir"><FONT SIZE=+1>RmDir(ディレクトリ)</FONT></A>
<DD>
<P>RmDir() は与えられたディレクトリを削除する。通常のファイルについては
<a href="#unlink">Unlink()</a>関数を参照のこと。</P>


<DT><A NAME="setcookie"><FONT SIZE=+1>SetCookie(name,value,expire,path,domain,secure)</FONT></A>
<DD>
<P>SetCookie() はヘッダー情報に付随して送られるクッキー(cookie)を定義する。
name 引数以外の引数はすべてオプションである。もし name 引数のみが与えられた場合、
name で指定されたクッキー(cookie)はリモートのクライアントから削除される。
また特定の引数を空文字列(<b>&quot;&quot;</b>)に替えることにより、
その引数をスキップすることもできる。
引数 expire と secure は整数であり、空文字列でスキップすることはできない。
ゼロ(<b>0</b>)を代わりに使用する。引数 expire は<a href="#time">time()</a>または<a href="#mktime">mktime()</a>
関数の戻り値である通常の Unix の時間整数である。幾つかの例を次に挙げる。<P>
<PRE>    SetCookie("TestCookie","Test Value");
    SetCookie("TestCookie",$value,time()+3600);  /* 1 時間で期限切れとする */
    SetCookie("TestCookie",$value,time()+3600,"/~rasmus/",".utoronto.ca",1);</PRE>
<P>クッキー(cookie)の値の部分は、送るときには自動的に URLエンコードされ、受け取る時には
自動的に URLデコードされて、クッキー(cookie)の名前と同じ名前の変数に格納される。
すなわち、上記スクリプト中の test cokkie の内容を見るには、次のようにするだけで良い。</P>
<PRE>    echo $TestCookie;</PRE>


<DT><A NAME="seterrorreporting"><FONT SIZE=+1>SetErrorReporting(引数)</FONT></A>
<DD>
<P>SetErrorReporting は現在のエラーレポート状態を<EM>引数</EM>の値にセットする。
もしゼロでない値が与えられた場合エラーは表示され、0の場合表示されない。
関数の戻り値はそれまでのエラーレポート状態である。
これは個々の関数に'@'文字を先頭につけるよりも、より一般的な
エラーレポートをしないようにするための手続きである。
より詳しい情報については<A HREF="#quiet">関数呼出時のエラー抑制</A>の章を参照のこと。</P>


<DT><A NAME="setlogging"><FONT SIZE=+1>SetLogging(引数)</FONT></A>
<DD>
<P> SetLogging() はページについてのアクセス統計のログを有効または無効にする。
<EM>引数</EM>がゼロでない場合にはログは有効になり、ゼロの場合には無効になる。</P>


<DT><A NAME="setshowinfo"><FONT SIZE=+1>SetShowInfo(引数)</FONT></A>
<DD>
<P>SetShowInfo() は PHP を通してロードされたページの下部にある
フッター情報を有効または無効にする。<EM>引数</EM>がゼロでない場合、
フッターは有効になり、ゼロの場合無効になる。</P>


<DT><A NAME="settype"><FONT SIZE=+1>SetType(変数,型)</FONT></A>
<DD>
<P>SetType は変数の型をセットする。引数の型は、
&quot;整数(integer)&quot;、&quot;倍精度小数(double)&quot;
もしくは&quot;文字列(string)&quot;のいずれかである。
<A HREF="#gettype">GetType()</A>関数も参照のこと。</P>

<DT><A NAME="shl"><FONT SIZE="+1">shl(n,b)</FONT></A>
<DD>
<P>値 <b>n</b> を左に <b>b</b> ビット分シフトする。<P>

<DT><A NAME="shr"><FONT SIZE="+1">shr(n,b)</FONT></A>
<DD>
<P>値 <b>n</b> を右に <b>b</b> ビット分シフトする。<P>

<DT><A NAME="sin"><FONT SIZE=+1>Sin(引数)</FONT></A>
<DD>
<P>Sin は引数のサイン値をラジアンで返す。<A HREF="#cos">Cos()</A>と
<A HREF="#tan">Tan()</A>も参照のこと。</P>


<DT><A NAME="sleep"><FONT SIZE=+1>Sleep(secs)</FONT></A>
<DD>
<P>Sleep は secs 秒の遅延を行なう。Unix C の sleep()関数と同様である。
<A HREF="#usleep">USleep()</A> 関数も参照のこと。</P>

  
<DT><A NAME="solid_close"><FONT SIZE="+1">Solid_Close(接続ID)</FONT></A>
<DD>
<P>Solid_Close は、与えられた接続識別子(接続ID) に関連する
Solid サーバーへの結合を閉じる。<P>
<P>
この関数は、PHP において Solid がサポートされている場合にのみ
使用可能である。<P>

<DT><A NAME="solid_connect"><FONT SIZE="+1">$connection = 
Solid_Connect(データソース名, ユーザー名, パスワード)</FONT>
<DD>
<P>Solid_Connect は、Solid サーバーへの結合を開く。
各引数は、前方引用符で囲まれた文字列でなければならない。
最初のパラメータ(データソース名)は、空の文字列とすることが可能である。
この場合、localhost 上のデフォルトのサーバーに結合される。
この関数は、接続IDを返す。
この識別子は、他の Solid 関数の実行時に必要である。
複数の接続を同時に開くことが可能である。
エラーの場合に、この関数は <STRONG>0</STRONG> を返す。
<P>
この関数は、PHP において Solid がサポートされている場合にのみ
使用可能である。<P>
 
<DT><A NAME="solid_exec"><FONT SIZE="+1">$result = Solid_Exec(
接続ID, クエリー文字列)</FONT>
<DD>
<P>Solid_Exec は、SQL 文を 接続ID で指定された Solid サーバーに送る。
接続ID は、Solid_Connect により返された有効な識別子でなければならない。
この関数の返り値は識別子であり、他の Solid 関数が結果にアクセスする際に用いる。
エラーの際に、この関数は<STRONG>0</STRONG> を返す。
コマンドは正しく実行されたが、返り値データが期待できない場合
(例えば、insert や update)には、<STRONG>1</STRONG> を返す。
データを返さない selects は、1 より大きな有効な結果を返すことに注意されたい。
<P>
この関数は、PHP において Solid がサポートされている場合にのみ
使用可能である。<P>

<DT><A NAME="solid_fetchrow"><FONT SIZE="+1">Solid_FetchRow(結果ID)</FONT>
<DD>
<P>Solid_FetchRow は、Solid_Exec より返されたデータから1行を取り出す。
Solid_FetchRow が呼ばれた後、その行のフィールドは、Solid_Result により
アクセス可能である。
Solid_FetchRow が成功した場合には、(新たに1行が作成される)<STRONG>1</STRONG>
が返される。
行がもう存在しない場合には、Solid_FetchRow は、<STRONG>0</STRONG>
を返す。
Solid_FetchRow の返り値は、while ループの条件として用いることが可能である。
<P>
この関数は、PHP において Solid がサポートされている場合にのみ
使用可能である。<P>    
 
<DT><A NAME="solid_fieldname"><FONT SIZE="+1">Solid_FieldName(
結果ID, フィールド番号)</FONT>
<DD>
<P>Solid_FieldName は、Solid の結果IDにおいて、指定した
フィールド番号を有するフィールド名を返す。
フィールド番号は 0 から始まる。<P>
<P>この関数は PHP で Solid がサポートされている場合のみ利用できる。<P>

    
<DT><A NAME="solid_fieldnum"><FONT SIZE="+1">Solid_FieldNum(
結果ID, フィールド名)</FONT>
<DD>
<P>Solid_FieldNum は、与えられた Solid 結果IDにおいて
フィールド名が一致するカラム位置の番号を返す。
フィールド番号は 0 から始まる。この関数はエラーの時に -1 を返す。<P>
<P>この関数は PHP で Solid がサポートされている場合のみ使用出来る。<P>

    
<DT><A NAME="solid_freeresult"><FONT SIZE="+1">Solid_FreeResult(結果ID)</FONT>
<DD>
<P>スクリプト実行時にメモリ使用量が非常に多いと危惧される場合にのみ
Solid_FreeResult は呼ばれる必要を生じる。
スクリプト終了時にメモリは自動的に解放される。
しかし、スクリプトの中でこれ以上結果データを必要としないことが
確実である場合には、結果IDを引数として
Solid_FreeResult 呼び出すことが可能である。
これにより、関連する結果を保持するメモリが解放される。
<P>
<P>この関数は PHP で Solid がサポートされている場合のみ使用できる。<P>

    
<DT><A NAME="solid_numfields"><FONT SIZE="+1">Solid_NumFields(結果ID)</FONT>
<DD>
<P>Solid_NumFields は Solid の結果のフィールド(カラム)数を返す。
引数は Solid_Exec によって返された有効な結果IDである。
この関数はエラーの時には <STRONG>-1</STRONG> を返す。<P>
<P>この関数は PHP で Solid がサポートされている場合のみ使用できる。
<P>

    
<DT><A NAME="solid_numrows"><FONT SIZE="+1">Solid_NumRows(結果ID)</FONT>
<DD>
<P>Solid_NumRows は Solid の結果の行数を返す。
引数は Solid_Exec で返された有効な結果IDである。
この関数はエラーの時には <STRONG>-1</STRONG> を返す。
<B>重要な注意点:</B>
SOLID SQL サーバーは、ODBC をプライマリインターフェース(そして、唯一の)
として用いている。
SolidNumRows() は、行の数を得るために低位の関数として SQLRowCount
を用いている。
SQLRowCount は、マイクロソフトの古くさい伝統にしたがっており、
不必要な制限、奇妙な例外、その他の妙な現象を生じる。
このような現象とは、次のようなものである。
この関数は、INSERT、UPDATE、DELETE 構文により作用された行の数を
返すが、SELECT については返さない!
実用面では、    
SQL の count() 命令や行の数を数える while-loop を試すことが可能である。
SELECT 構文の実行により読み込まれたレコードの数を表示するために
Solid_NumRows() を必要とする場合には、代わりに
<a href="#solid_fetchrow">Solid_FetchRow()</a> からの返り値を
チェックしてみること。
つまり、以下の代わりに:<P>
<PRE>     $num = Solid_NumRows();
    $i=0;
    while ($i < $num) {
        /* 結果の表示... */
        $i++;
    }
</PRE><P>
次を試してみる良い。:<P>
<PRE>    while(Solid_FetchRow($result)) {
        /* 結果の表示... */
    }
</PRE>    
<P>この関数は PHP で Solid がサポートされている場合のみ使用できる。<P>

    
<DT><A NAME="solid_result"><FONT SIZE="+1">Solid_Result(
結果ID, フィールド名/インデックス)</FONT></A>
<DD>
<P>Solid_Result は Solid_Exec にて作成された結果IDから
実際の値を返す。
フィールド名は、行の中でどのセルを返すかを指定する。
フィールドを名前で指定する代わりに、前方引用符無しの番号で表した
フィールドインデックスを使うことも可能である。
フィールドインデックスは 0 から始まる。
<P>
<P>この関数は PHP で Solid がサポートされている場合のみ使用できる。<P>
    
<DT><A NAME="sort"><FONT SIZE=+1>Sort(配列)</FONT></A>
<DD>
<P>Sort は PHP の配列を昇順にソートする。
降順にソートする場合は、RSort()関数を使用のこと。
3 種の変数型を理解し、
文字列型ならアルファベット順に、また配列が数値ならば数値的にソートする。
配列にいろいろな型が混ざっている場合には、
配列の一番先頭の型がソートの手段として用いられる。</P>
連想配列のソートを行う場合には、<a href="#asort">ASort()</a>関数を用いる必要が
あることに注意されたい。<P>
      
<DT><A NAME="soundex"><FONT SIZE="+1">Soundex(文字列)</FONT></A>
<DD>
<P>この関数は、文字列引数をとり、soundex キーを文字列
    として返す。soundex キーには、同じように発音される単語は
    同じ soundex キーとなるという特性がある。これにより、
    発音は知っているがスペルは知らない場合にデータベースを検索する
    ことを簡単化するために使用することが可能である。
   この soundex 関数は、ある文字で始まる 4 文字の長さの文字列を返す。<BR>
   このタイプの  soundex 関数は、Donald Knuth により
    "The Art Of Computer Programming, vol. 3: Sorting And
   Searching",  Addison-Wesley (1973), pp. 391-392 で記述されている。
   <BR>
   例:
   <PRE>
   Euler と Ellery は、E460 にマップされる。
   Gauss と Ghosh は、G200 にマップされる。
   Hilbert と Heilbronn は、H416 にマップされる。
   Knuth と Kant は、K530 にマップされる。
   Lloyd と Ladd は、L300 にマップされる。
   Lukasiewicz と Lissajous は、L222 にマップされる。
     </PRE>
<P>

<DT><A NAME="sprintf"><FONT SIZE="+1">Sprintf(format,arg [,arg,arg,arg,arg])</FONT></A>
<DD>
<P>Sprintf は、引数 format と arg によって定義されたフォーマット済み出力の
文字列を返す。この関数は、フォーマット指定付きの <A HREF="#echo">echo</A> コマンド
と似ているが、echo がそれを表示するのに対して、これは単に文字列を返すだけである。
また、これは C 言語の同名の関数にも似ている。
違いは、このバージョンでは 6 つ以上の <EM>arg</EM> 引数をとることができないと
いう点である。一つの文字列において 6 つ以上の引数をフォーマットする
必要がある場合には、単純に引数の各グループについて sprintf() を複数回コール
すること。引数の型は、出力に対して何の影響も与えないところに注目されたい。
引数の型は、自動的に(かつ魔法の様に)
フォーマット文字列に指定された型に一致するように変換される。</P>

<DT><A NAME="sqrt"><FONT SIZE=+1>Sqrt(引数)</FONT></A>
<DD>
<P>Sqrt は引数の平方根を返す。</P>


<DT><A NAME="srand"><FONT SIZE=+1>Srand(整数)</FONT></A>
<DD>
<P>Srand は乱数発生のシード(seed)を行なう。
この関数は引数にどのような整数でも取る。
シードの値としての一つの選択は、<STRONG>date</STRONG>関数で現在の秒を使うことである。
この関数は<B>戻り値を持たない</B>ことに注目されたい。
この関数は単に、後の<A HREF="#rand">rand()</A>関数の呼び出しのための乱数発生のシードを行なうのみである。
例として以下のようになる。<P>
<PRE>	&lt;?srand(date(&quot;s&quot))&gt;</PRE></P></P>


<DT><A NAME="strchr"><FONT SIZE=+1>strchr(文字列,引数)</FONT></A>
<DD>
<P>strchr と <A HREF="#strstr">strstr</A> はまったく同一の関数である。
両者は交換可能であり、両者とも完全性のために導入されている。
第二引数が見つかった場所から始まる引数 string の部分が返される。
例えば、上記の&quot;This is an example string&quot; という文字列において、
<TT>&lt;echo strctr($string,&quot;an &quot;)&gt;</TT>という呼び出しは
<TT>&quot;an example string&quot;</TT>という文字列を返す。</P>

<DT><A NAME="strtr"><FONT SIZE="+1">strtr(input,set1,set2)</FONT></A>
<DD>strtr() は、&quot;string&quot; 中の各文字において
&quot;set1&quot; にある文字を対応する&quot;set2&quot; にある文字
に変換する。
set1 にない文字は、変更されない。
ある文字が &quot;set1&quot; に2度以上現れ、対応する文字が全て同じでない
場合には、最後に指定された文字で置換される。
&quot;set1&quot; または &quot;set2&quot;のどちらかが長い場合には、
短い側の長さまで短かくされる。 <P>

<DT><A NAME="stripslashes"><FONT SIZE="+1">StripSlashes(引数)</FONT></A>
<DD>
<P>StripSlashes は、文字引数よりエスケープ文字を取り除く。
<a href="#addslashes">AddSlashes()</a>も参照のこと<P>

<DT><A NAME="strlen"><FONT SIZE=+1>strlen(文字列)</FONT></A>
<DD>
<P>strlen は文字列の長さを返す。</P>

<DT><A NAME="strrchr"><FONT SIZE=+1>strrchr(文字列,引数)</FONT></A>
<DD>
<P>strrchr は引数の終りから始めて逆向きに 1文字を検索する。
検索文字が見つかればその文字から始まる文字列を返し、
見つからなければ空の文字列を返す。</P>


<DT><A NAME="strstr"><FONT SIZE=+1>strstr(文字列,引数)</FONT></A>
<DD>
<P>strstr と <A HREF="#strchr">strchr</A> はまったく同一の関数である。
両者は交換可能であり、両者とも互換性のために導入されている。
第二引数が見つかった場所から始まる引数文字列の部分が返される。
例えば、上記の&quot;This is an example string&quot; という文字列において、
<TT>&lt;echo strstr($string,&quot;an &quot;)&gt;</TT>という呼び出しは
<TT>&quot;an example string&quot;</TT>という文字列を返す。</P>



<DT><A NAME="strtok"><FONT SIZE=+1>strtok(文字列,トークン)</FONT></A>
<DD>
<P>strtok は文字列をトークン毎に分けるのに使用する。つまり、
<STRONG>&quot;This is an example string&quot;</STRONG>という文字列を持ち、
それらを個々の単語のトークン毎に分けたい場合には、空白文字をトークン
として用いる。
次のようなスクリプトコードを使うことを考える。
<P>
<PRE>	&lt;?
	  $string = &quot;This is an example string&quot;;
	  $tok = strtok($string,&quot; &quot;);
	  while($tok);
		  echo "Word=$tok&lt;br&gt;";
		  $tok = strtok(&quot; &quot;);
	  endwhile;
	&gt;</PRE></P>
一番最初の strtok の呼び出し時にのみ引数 string が使用されることに
注目されたい。
その後の strtok の呼び出しには、現在までの文字列上の軌跡を保持しているため、
トークン毎の区切りのみが必要となるだけである。再度始める場合や
新しい文字列をトークン毎に分けたい場合には、単に strtok に引数 string を
再度付けて呼び出し初期化する。
<i>arg</i> パラメータにおいて複数のトークンを送る可能性が
あることに注意されたい。
引数においてトークンのどれか一つが見出された時に、
文字列はトークン毎に分割される。<P>	

<DT><A NAME="strtolower"><FONT SIZE=+1>strtolower(文字列)</FONT></A>
<DD>
<P>strtolower は引数文字列のすべてを小文字に変換する。</P>


<DT><A NAME="strtoupper"><FONT SIZE=+1>strtoupper(文字列)</FONT></A>
<DD>
<P>strtoupper は引数文字列のすべてを大文字に変換する。</P>


<DT><A NAME="strval"><FONT SIZE=+1>strval(変数)</FONT></A>
<DD>
<P>strval はその変数の文字列としての値を返す。
関数<A HREF="#intval">intval()</A> と <A HREF="#doubleval">doubleval()も参照のこと</A>
</P>


<DT><A NAME="substr"><FONT SIZE=+1>substr(文字列, start, length)</FONT></A>
<DD>
<P>substr は与えられた文字列の一部を返す。スタート位置は引数 start で与える。
文字列の一番先頭は位置 0 である。
そして、引数 length にはスタート位置から何文字を
返すかを指定する。</P>

  
<DT><A NAME="sybsql_checkconnect"><FONT SIZE="+1">sybSQL_CheckConnect()</FONT></A>
<DD><P>この関数は、データベースへの接続が確立されている時に1、そうでない時
に0を返す。
<P>

<DT><A NAME="sybsql_dbuse"><FONT SIZE="+1">sybSQL_DBuse(データベース)</FONT></A>
<DD><P>この関数は、指定したデータベースについて Sybase Transact-SQL の
<b>use</b> コマンドを発生する。
関数の唯一の引数は、使用するデータベース名(database)である。
例えば、: <code>sybsql_dbuse("pubs2");</code>
<P>
この関数は、成功した場合に 1、失敗した場合に 0 を返す。<P>

<DT><A NAME="sybsql_connect"><FONT SIZE="+1">sybSQL_Connect()</FONT></A>
<DD>
<P>この関数は、sybase サーバーに対するネットワーク結合をオープンする。
この関数は、コールする前に呼出す側によりセットされる幾つかの環境変数に
依存する。    
<P>
この環境変数を以下に示す。:
<P>
<b>DSQUERY</b> - sybase インターフェースファイルにおいて定義された
sybase サーバーの別名(エイリアス)。
<br>
<b>DBUSER</b> - このユーザー名で sybase サーバーに接続する。
<br>
<b>DBPW</b> - そのユーザーのパスワード。
<P>
これらの変数は、幾つかの手段でセットすることができる。
php/fi が CGI プログラムとして実行されている場合には、
これらの変数をセットするために shell ラッパーを
用いることができる。    
あるいは、PHP/FI の組み込み関数 <b><a href="#putenv">putenv()</a></b>
を用いて、これらの変数を HTML ページにおいて直接セットすることができる。
<b><a href="#putenv">putenv()</a></b> によりそれらの値を直接使う
代わりに、値をフォーム入力から得ることも可能である。
変数をファイルに定義して、PHP/FI の
<code><a href="#include">include</a></code> 命令で html ファイルに
読み込むことも可能である。    
<p>
この関数は、成功した場合に 1、失敗した場合に 0 を返す。<P>    

<DT><A NAME="sybsql_exit"><FONT SIZE="+1">sybSQL_Exit()</FONT></A>
<DD><P>
この関数は、Sybase 接続を強制的にシャットダウンする。
この関数がコールされない場合には、
PHPページは完全に実行された時に自動的に接続が閉じられる。
よって、この関数の呼び出しはオプションである。<P>

<DT><A NAME="sybsql_fieldname"><FONT SIZE="+1">sybSQL_Fieldname(フィールド番号)</FONT></A>
<DD><P>
この関数は、通常の結果の列のフィールド名を返す。
関数の引数は、フィールド番号である。
例: <code>sybsql_fieldname(0);</code>
注意: フィールド番号は 0 から始まる。
<P>
結果の列は、いかなる名前も持たない場合には、この関数は
空の文字列("")を返す。<P>

<DT><A NAME="sybsql_getfield"><FONT SIZE="+1">sybSQL_GetField(フィールド)</FONT></A>
<DD><P>
この関数は、結果のカレント行において指定した列の値を取り出す。
この関数の引数は、フィールドを指定する文字列のみである。
例: <code>$value=sybsql_getfield("@10");</code> 
<b>注意</b>: この関数をコールする前に <a href="#sybsql_nextrow">sybsql_nextrow()</a> をコールしなければならない。
この関数は行バッファにおいてカレント行のみを読むため、    
行ポインタを増やす必要がある場合には sybsql_nextrow() を呼ぶ必要がある。
<P>
指定した列がある値を有する場合には、この関数はその値を文字列として返す。
そうでない場合は、空の文字列 ("") を返す。<P>
 
<DT><A NAME="sybsql_isrow"><FONT SIZE="+1">sybSQL_IsRow()</FONT></A>
<DD><P>
この関数は、カレント SQL コマンドが行を返したかどうかを示す。
この関数は、SQL コマンドが行を返した場合は 1 を返す。
また、このコマンドがいかなる行を返さなかった場合は、0 を返す。<P>

<DT><A NAME="sybsql_nextrow"><FONT SIZE="+1">sybSQL_NextRow()</FONT></A>
<DD><P>
この関数は、行ポインタを次の結果の行に増やす。<P>
この関数は、読むことが可能な行がある限り 1 を返す。
読むことが可能な行がもうない場合や、関数がエラーとなった場合は
0 を返す。<P>

<DT><A NAME="sybsql_numfields"><FONT SIZE="+1">sybSQL_NumFields()</FONT></A>
<DD><P>
この関数は、カレントの結果行におけるフィールドの数を返す。<P>
関数は、カレントの結果行における行の数を返す。    
フィールドがない場合には、この関数は、0 を返す。<P>

<DT><A NAME="sybsql_numrows"><FONT SIZE="+1">sybSQL_NumRows()</FONT></A>
<DD><P>
この関数は、カレントの結果バッファにおける行の数を返す。    
<b>注意:</b> 
この関数がコールされる際、最初の行を直ちに探索する。
続いて、もうこれ以上行がないところまで dbnextrow() をコール
する。
この際、    
結果バッファにおける行の数を計算するために内部カウンタを増やしていく。
そして、最初の行へポインタは戻る。
そこで、この関数をコールした後、行カウンタは最初の行をいつも
指すことになる。    
これは、汚い仕方だが、現在、他の手段を見出していない。
<p>
結果バッファに行がない場合、この関数は、0 を返す。<P>

<DT><A NAME="sybsql_query"><FONT SIZE="+1">sybSQL_Query(文字列)</FONT></A>
<DD><P>
この関数は、Sybase SQL クエリーのリクエストをサーバーに送る。 
この関数に対する引数はクエリー文字列のみである。
例:
<code>$rc=sybsql_query("select * from authors");</code><P>
この関数は、クエリーの解釈が成功した成功した場合に 1、
リクエストが失敗した場合に 0 を返す。<P>        

<DT><A NAME="sybsql_result"><FONT SIZE="+1">sybSQL_Result(string)</FONT></A>
<DD><P>
この関数は、カレントの結果の行において、指定したフィールドを出力する。
この関数に対する唯一の引数は、出力するフィールドに関する情報を保持する
文字列(string)のみである。    
フィールドは、@ とその後に続く数字で指定される。
例えば、@0 は最初の行を表し、@10 は 11 行目を表す。
フィールド番号は 0 から始まることに注意されたい。
この関数は、おそらく次の完全な例で最もうまく説明できるであろう。:<P>
<pre>&lt;?
    /*
    ** コネクションに必要な全ての変数は既にセットされていると仮定する。 
    ** 注意して欲しいのは、エラーチェックを行っていないことである。
    ** 関数のリターンコードは常にチェックする必要がある。
    */

    /* コネクト */
    $rc=sybsql_connect();

    /* pub2 データベースを使用する。 */
    $rc=sybsql_dbuse(&quot;pubs2&quot;);

    /* SQL リクエストを送信する。 */
    $rc=sybsql_query(&quot;select * from authors&quot;);
    $i=0;

    /* 返された行の数を得る。 */
    $nrows=sybsql_numrows();

    /* テーブルを始める。 */
    echo &quot;&lt;table border&gt;\n&quot;;
    /*
    ** 最初と2番目のフィールドのみを表示
    */
    while($i&lt;$nrows) {
        sybsql_result(&quot;&lt;tr&gt;&lt;td&gt;@0&lt;/td&gt;@1&lt;/td&gt;&lt;/tr&gt;\n&quot;);
        $i++;
    }
    /* テーブルを終る。 */
    echo &quot;&lt;/table&gt;\n&quot;;
&gt;</pre><P>
上の例では、出力をフォーマットするために HTML テーブルを用いている。
もちろん、他のあらゆる有効な HTML タグを使用することが可能である。<P>

<DT><A NAME="sybsql_result_all"><FONT SIZE="+1">sybSQL_Result_All()</FONT></A>
<DD><P>
この関数は、カレントの結果バッファにおいて全ての行を表示する。    
結果は、ハードコードされた HTML テーブルフォーマットで出力される。
この関数をループの内部で呼び出してはならないことに注意されたい。    
この関数は、出力に列のヘッダーがある場合には、列の名前を出力する。<P>

<DT><A NAME="sybsql_seek"><FONT SIZE="+1">sybSQL_Seek(row)</FONT></A>
<DD><P>
この関数は、行バッファにおけるカレント行として指定された行番号(row)を
セットする。この関数の引数は、行番号のみである。例:
<code>$rc=sybsql_seek(10);</code> 行番号は、0 から始まることに
注意されたい。<P>
この関数は、探索に成功した場合は 1 、探索に失敗した場合は 0 を返す。
カレント結果バッファの全ての行を見終った時、行ポインタは最後の行を指す。
後戻りしたり、更にいくつかの行を見る必要がある場合、
この関数はこの目的のために使用することができる。<P>

<DT><A NAME="symlink"><FONT SIZE=+1>Symlink(target,link)</FONT></A>
<DD>
<P>Symlink() はシンボリックリンクを作る。ハードリンクを作るには
<a href="#link">Link()</a>を参照のこと。</P>

<DT><A NAME="syslog"><FONT SIZE="+1">Syslog(level,message)</FONT></A>
<DD>
<P>
Syslog() は、UNIX の syslog(3) 関数を用いてメッセージをシステムに記録する。
更に詳細な情報は、UNIX マニュアルを参照されたい。
<a href="#initsyslog">InitSyslog()</a>、<a href="#openlog">OpenLog()</a>
、<a href="#closelog">CloseLog()</a> も参照のこと。
<P>

<DT><A NAME="system"><FONT SIZE=+1>System(
コマンド文字列 [,返り値])</FONT></A>
<DD>
<P>System は C の<EM>system()</EM>コマンドと同様であり、与えられた unix コマンドを実行し、
その結果を出力する。第二引数として変数が与えられた場合には、
その実行された unix コマンドのリターンステータスが格納される。
但し、ユーザーからの入力をこの System 関数に渡す際には、
<A HREF="#escpapeshellcmd">EscapeShellCmd()</A>関数を使用し、
ユーザーがシステムを欺いて任意のコマンドを実行することを防止する必要がある。
System() コールは、PHP が Apache モジュールとして実行されている場合、
自動的に Apache 出力バッファのフラッシュも行う。
あるコマンドを実行し、なんらかのインターフェース無しにコマンドから
全てのデータを直接受け取る必要がある場合には、
<a href="#passthru">PassThru()</a> を使用すること。
<A HREF="#exec">Exec</A>関数も参照のこと。</P>

<DT><A NAME="tan"><FONT SIZE=+1>Tan(引数)</FONT></A>
<DD>
<P>Tan は引数のタンジェント値をラジアンで返す。
<A HREF="#sin">Sin()</A>と<A HREF="#cos">Cos()</A>も参照のこと。</P>


<DT><A NAME="tempnam"><FONT SIZE=+1>TempNam(パス, プレフィックス)</FONT></A>
<DD>
<P>TempNam は、パスで示されたディレクトリに置かれる、 プレフィックスで始まる
一意なファイル名を返す。これは、Unix C の tempnam() 関数と同一である。</P>


<DT><A NAME="time"><FONT SIZE=+1>Time()</FONT></A>
<DD>
<P>Time は単純に Unix の epoch (00:00:00 Jan. 1 1970)から
ローカルタイムで何秒経過しているかを返す。これは<A HREF="#date">Date(&quot;U&quot;)</A>
と同義である。秒単位よりも正確なものが必要ならば、<A HREF="#microtime">Microtime</A>
関数を使用のこと。</P>

<DT><A NAME="umask"><FONT SIZE="+1">Umask([mask])</FONT></A>
<DD>
<P>Umask(<i>mask</i>) は、PHP の umask を <i>mask</i> &amp; 0777 に
セットし、古い umask を返す。
PHP/FI が Apache モジュールの場合、PHP/FI が終了した際に
Apache の古い umask に戻される。
<i>mask</i> は、<a href="#chmod">ChMod()</a> と同様に
<a href="#octal">8 進表記</a>で指定しなければならない。
引数無しの Umask() は、単に現在の umask を返す。<P>

<DT><A NAME="uniqid"><FONT SIZE="+1">UniqId()</FONT></A>
<DD>
<P>UniqId は、マイクロ秒で表された現在の時刻に基づいて
接頭辞付きのユニークな識別子を返す。
例えば、幾つかのホストで同時に同じマイクロ秒において
識別子を作成する場合には、接頭辞(prefix)は便利である。
接頭辞は、最大 114 文字の長さとすることができる。
<P>

<DT><A NAME="unlink"><FONT SIZE=+1>Unlink(ファイル名)</FONT></A>
<DD>
<P>Unlink はファイル名で与えられたファイルを削除する。Unix C の unlink()関数と同様である。
ディレクトリを削除するには、<a href="#rmdir">RmDir()</a>関数を参照のこと。</P>


<DT><A NAME="unset"><FONT SIZE=+1>UnSet($var)</FONT></A>
<DD>
<P>UnSet 与えられた変数を未定義にする。配列の場合には、配列のすべての要素がクリアされる。
このコマンドで個々の配列要素を未定義にすることも可能である。</P>


<DT><A NAME="urldecode"><FONT SIZE=+1>UrlDecode(引数)</FONT></A>
<DD>
<P>UrlDecode は<A HREF="#urlencode">UrlEncode</A>関数でエンコードされた
文字列をデコードする。典型的な使用においては、URL エンコードされた文字列が
ページ間を移動した場合には自動的にデコードされるため、デコードは必要ない。
しかしながら、完全性のためにこの関数は採り入れられた。</P>


<DT><A NAME="urlencode"><FONT SIZE=+1>UrlEncode(引数)</FONT></A>
<DD>
<P>UrlEncode は引数の &quot;a-zA-Z0-9_-.&quot; に含まれない文字を
ASCIIコードの16進数 xx で表示される %xx に変換してエンコードする。
エンコードされた文字列が戻り値となる。</P>


<DT><A NAME="usleep"><FONT SIZE=+1>USleep(マイクロ秒)</FONT></A>
<DD>
<P>USleep は与えられた数ぶんのマイクロ秒の遅延を行なう。
Unix C の usleep()関数と同様である。<A HREF="#sleep">Sleep()</A>関数も参照のこと</P>

<DT><A NAME="virtual"><FONT SIZE=+1>Virtual(ファイル名)</FONT></A>
<DD>
<P>Virtual は Apache サーバー専用の関数で、mod_include での
&lt;!--#include virtual...--&gt; と同義である。Apache のサブリクエスト
として動作する。これは CGI スクリプトを取り込む時や、.shtml ファイル、または
その他の Apache を介して解釈を行ないたい場合に有用である。
(.phtml ファイルについては、&lt;?Include&gt; を使いたいところであろう。)</P>

</DL>
    
<HR>
<H2><A NAME="addfunc">自作の内部関数を PHP/FI に加える方法</A></H2>

PHP/FI により提供される一連の関数の中に自分が必要とする特定の関数が
含まれていないということは充分ありえることである。
以下に記述される手順を注意深く実践することにより、
自作の関数を PHP/FI に加えることが可能である。<P>

<P>
PHP/FI の内部をハックする前に、最新版の Bison を用意しておく必要がある。
Bison は YACC (Yet Another Compiler Compiler) の GNU 版である。
システムにもともとある YACC でもあるいは充分かもしれないが、
念のため Bison を手にいれておくこと。
Bison は、<A HREF="ftp://prep.ai.mit.edu/pub/gnu">
ftp://prep.ai.mit.edu/pub/gnu</A> で見つけることができる。<P>

<P>
Makefile を見て、デバッグをオンにすること。
これを行なうには、
Makefile 中の <STRONG>DEBUG</STRONG> がある行の
コメントを無効とするだけで良い。
デバッグ情報の出力ファイル は、<EM>php.h</EM> の中の
<STRONG>DEBUG_FILE</STRONG> で指定されている。
デフォルトは、<EM>/tmp/php.err</EM> にセットされている。
必要に応じてこれは変更可能である。<P>

<P>
最後の注意点は、setuid ビットをセットして実行しない限り
php は自分のシステムにおける httpd と同じユーザーID
で実行されるが、この httpd を実行するユーザーは通常様々なディレクトリに
書き込む権限を有さないということである。
このことは、php がコアダンプを生じるようなことを行なった場合に、
コアファイルを得ることができないことを意味する。

簡単な解決策は、test.html を置くディレクトリを
全てに対して書き込み可能とすることである。

PHP は、カレントディレクトリを読み込み中の
.html ファイルのあるディレクトリに変更するので、
可能ならばそこにコアをダンプする。<P>
<P>
関数を加える方法について <EM>Time()</EM> 関数を用いて
以下に順をおって説明を行なう。<P>


<DL><DT><STRONG>手順 1 - 関数の文法を定義する</STRONG>
<DD>
<P>関数の引数が 0 から 6 である場合には、
あらかじめ定義された文法が使用可能である。
この場合には、次の手順を飛ばすことができる。<P>

<P>関数の文法は、<EM>parse.raw</EM> ファイルで定義される。
最初に加えるのは、トークンである。
トークンは大文字のキーワードであり、通常は関数名と同じである。
全てのトークンは、parse.raw ファイルの最初の方で定義される。
順序は問わない。
次に実際の YACC 文法ルールを構築する必要がある。
記述済みのルールを見て自分が加える関数に似たものを見つけること。
最も一般的な関数は引数を表現スタックから読む標準的関数であることを
覚えておくこと。
<EM>parse.raw</EM> ファイルをいじる必要がない場合には、
あなたの関数はたいていこのグループに分類されるであろう。<P>

<DT><STRONG>手順 2 - 関数を字句解析用ハッシュテーブルに加える</STRONG>
<DD>
<P>これを行なうには、<EM>lex.c</EM> を編集し、
ファイルの先頭付近のハッシュテーブルを見つけること。
このテーブルを見つけるには、ハッシュテーブルの始まりを定義する    
<TT>static cmd_table_t cmd_table[22][30] = {</TT> の行を探すこと。
<TT>[22][30]</TT> はハッシュテーブルを保持する2次元配列の大きさを
定義する。
22 は関数名の長さの最大値に1を加えたものである。
30 は各々のハッシュリストにおける関数の最大数を表す。
もし、これらの制限のどちらかを越えたい場合には、
これらの値を増やせば良い。<P>
<P>
このハッシュテーブルは恐らく世界一簡単なハッシュテーブルとして
記録されるだろう。
ハッシュ値はハッシュされる関数名の文字列の長さである。
つまり、<EM>Time()</EM> の例においては、
ハッシュ値 4 のエントリを加える必要がある。
そこで、4 のハッシュリストに次の行を加える。:<P>
<P>
<PRE>      { &quot;time&quot;,INTFUNC0,UnixTime },</PRE><P>
<P>

このエントリは、(クオートで囲われた)文字列を
INTFUNC0 トークンに割り付ける。
INTFUNC0 トークンについての文法は <EM>parse.raw</EM> で見つけることが
できる。これより、INTFUNC0 トークンは
引数が 0 個の内部関数に関する一般的文法であることがわかるだろう。
上でクオートで囲われた文字列は、
.html ファイル中で関数を呼ぶ際に用いる実際の文字列である。

PHP/FI の関数名は大文字と小文字を区別 <STRONG>しない</STRONG> ということ
に注意すること。
そして、リストの最後の要素 <B>UnixTime</B> は、
コールされる実際の関数である。<P>

 
<DT><STRONG>手順 3 - 実際の関数の記述</STRONG>
<DD>
<P>標準的なC関数の呼び出し規約を通じて呼び出し可能であり、
システム上のリンカーが取り扱うことが可能な
オブジェクトファイルかライブラリファイルのどちらかを作成する手段を
有している限り、関数を好きな言語で書くことができる。
一般的な例として、ここでは C 言語で関数を書くと仮定する。
PHP/FI の組み込み関数は全て C 言語で書かれている。
Time() 関数、あるいは PHP において内部的にコールされる
UnixTime() は、<EM>date.c</EM> 中に見つけることができるが、
これは次のようなものである。:<P>
<P>
<PRE>
void UnixTime(void) {
    char temp[32];

    sprintf(temp,"%ld",(long)time(NULL));
    Push(temp,LNUMBER);
}</PRE><P>
    
<P>
この関数は、void 型である。
これは、この関数が戻り値を持たないことを意味する。
この関数は当然時間を返す手段を有していなければならないので、
このことは、混乱を招くかもしれない。
時間は返されるが、関数の戻り値としてではない。
時間は、辞句スタック (expression stack) と呼ばれるものにプッシュされる。
辞句スタックは、単に文字列のスタックであり、連想型である。
PHP/FI は、3 つの基本的な変数型のみを理解する。:
これらは、STRING, LNUMBER と DNUMBER である。
STRING は文字列、LNUMBER は long 整数、DNUMBER は倍精度実数もしくは、
浮動小数点数である。
この Time() の例では、戻り値は Unix フォーマット
(1970 年 1 月 1 日からの秒数)で表現された時間であり、
よって整数である。
式スタックは、文字列のみを受け入れるので、long 整数を sprintf 関数
により文字列に変換し、スタックへとプッシュする。
その際、次のように実際には long 整数であることを示す。
: <TT>Push(temp,LNUMBER);</TT><P>


<DT><STRONG>手順 4 - 関数プロトタイプを php.h へ加える</STRONG>
<DD>
<P><EM>php.h</EM> ファイルの後半部に、php 関数全部のプロトタイプの完全な
リストを見つけることができる。
これらは、存在するファイル毎にグループ化されている。
プロトタイプをこのファイル中の適当な場所に加えるだけである。
Time() の例では、次のような行を加える。:<P>
<P>
<PRE>void UnixTime(void);</PRE><P>

<DT><STRONG>手順 5 - コンパイル</STRONG>
<DD>
<P> <EM>parse.raw</EM> ファイルを変更した場合には、忘れずに
パーサを再構築する必要がある。
これを行なうには、次のように入力する。
<BR>
: <STRONG>make parser</STRONG>
<BR>
PHP パーサを作成するためには、BISON バージョン 1.25 以上が
必要である。    
この後、続いて次のように入力し通常のコンパイルを行なう。
<BR>
:<STRONG>make</STRONG>
<P>    
    
<DT><STRONG>手順 6 - 加えた関数を送って下さい!</STRONG>
<DD>
<P> 自分の関数を PHP/FI の次の版に加えたい時は、私に送って下さい。
送る際の最良の手法は、多分、文脈依存型の差分 (context-sensitive diff)
を作ることであろう。
これを作るには、修正前の配布ファイルが必要である。
変更したファイルについて <STRONG>diff -c</STRONG> を実行し、
元のファイルと変更後のファイルを比較する。
<EM>parse.c</EM> は自動的に作成されるので、
このファイルに関する変更の差分ファイルを私に送らないこと。
代わりに、<EM>parse.raw</EM> からの差分を送ること。<P>    
</DL>

<P>
Time() の例では関数を加える際に必要な手順を説明した。
加えたい関数がこの例よりも多少複雑な場合もあるだろう。
多くの場合、自分の関数に引数を渡し、
なんらかの方法で操作可能であることが望まれるであろう。
異なった手法で関数を呼び出し可能であることも
望まれるであろう。
この概念をPHP/FI の crypt() 関数で説明しよう。
PHP/FI のコードを書く際のより技術的な詳細については、
<A HREF="#hacknotes">コードハックに関する記述</A>という
節も参照のこと。<P>
<P>
<EM>parse.raw</EM>における Crypt() の文法は、:<P>
<P>
<PRE>%token CRYPT
        .
        .
        .
    | CRYPT '(' expr ',' expr ')'
        {
            if(GetCurrentState(NULL) || inCase || inElseIf) Crypt(1);
        }
    | CRYPT '(' expr ')'
        {
            if(GetCurrentState(NULL) || inCase || inElseIf) Crypt(0);
        }
</PRE><P>

<P>
ここには、引数が 1 つか 2 つのどちらかである関数を呼び出すための
文法を定義する仕方が示されている。
これら 2 つのケースを扱うために別の関数を書くことができる。
あるいは、ここで行なわれているように関数が呼び出されたモードを示す
モードパラメーターを単純に送ることもできる。
この場合は、関数が引数の数を変数とすることができるので、
あらかじめ定義された  INTFUNCn 文法のうちの一つを使うと
いうことはできない。<P>
<P>
この例では、実際の関数における引数の表現法についても示されている。
多くの場合、<STRONG>expr</STRONG> 定義子の使用が望まれるであろう。

この定義子は、引数が表現式(expression)であることを意味する。
表現式は、リテラル値、関数コールあるいはいくつかの表現式の組み合わせとする
ことができる。

表現式に用いる yacc 文法定義の詳細は parse.raw を参照のこと。
<P>

<EM>lex.c</EM>におけるハッシュテーブルのエントリは
次のようなものである。:<P>

<P>
<PRE>      { "crypt",CRYPT,NULL },</PRE><P>
<P>
この場合、
関数の呼び出しは直接 <EM>parse.raw</EM> で取り扱われるので、
最後の項は NULL である。
INTFUNCn 文法を使用している場合には、
この NULL のある場所にその関数名を書く。
<EM>crypt.c</EM> における実際の Crypt() 関数を次に示す。:<P>

<P>
<PRE>/*
 * If mode is non-zero, a salt is expected.
 * If mode is zero, a pseudo-random salt will be selected.
 */
void Crypt(int mode) {
#if HAVE_CRYPT
	Stack *s;
	char salt[8];
	char *enc;
	
	salt[0] = '\0';
	if(mode) {
		s = Pop();
		if(!s) {
			Error("Stack error in crypt");
			return;
		}
		if(s->strval) strncpy(salt,s->strval,2);
	}
	s = Pop();
	if(!s) {
		Error("Stack error in crypt");
		return;
	}
	if(!salt[0]) {
		salt[0] = 'A' + (time(NULL) % 26);
		salt[1] = 'a' + (time(NULL) % 26);
		salt[2] = '\0';
	}
	enc = (char *)crypt(s->strval,salt);
#if DEBUG
	Debug("Crypt returned [%s]\n",enc);
#endif
	Push(enc,STRING);	

#else
	Error("No crypt support compiled into this version");
#endif
}
</PRE><P>

<P>
この関数の最も重要な部分は、<STRONG>s = Pop()</STRONG>
を呼び出しているところである。
関数に対する引数は、式スタックから一つずつポップすることにより
取得しなければならない。
複数の引数をとるような関数を書く際には、
式スタックは、後入先出(LAST-IN,FIRST-OUT)であるということを
覚えておかねばならない。
このことは、引数を式スタックから逆順で除くことを意味する。
最後の引数は最初に除かれる。
上記の例では、2 個の引数を有するモードかどうかをチェックしている。
もし、そうであるならば、式スタックから引数を取り除き保存する。
つづいて次の引数を式スタックから取り除く。
Pop() は、スタック構造体へのポインタを返す。
スタック構造体は、次のような形式である。
(<EM>php.h</EM>による):<P>
<P>
<PRE>/* Expression Stack */
typedef struct Stack {
    short type;
    unsigned char *strval;
    long intval;
    double douval;
    VarTree *var;
    struct Stack *next;
} Stack;
</PRE><P>

<EM>型</EM> は、通常 STRING, LNUMBER もしくは DNUMBER のどれかである。
<EM>strval</EM>、<EM>intval</EM>、<EM>douval</EM> 部
は、値をそれぞれ文字列、整数、倍精度実数で表現したものである。
表現式が実際に定義された変数であるならば、<EM>var</EM> 部は
この変数を定義する変数構造体へのポインタを保持している。<P>
<P>
Crypt() 関数においては引数の文字列として値のみに注目し、
<EM>s->strval</EM> を用いる。
多くの PHP/FI 関数においては、
<EM>s->type</EM> をチェックし、<EM>s->strval</EM>、<EM>s->intval</EM>
または、<EM>s->douval</EM> を適当に用いることにより、
変数の型に応じて異なった処理を行なうことが可能である。<P>

<P>
<STRONG>実際の</STRONG> crypt() 関数を呼び出し、
暗号化された文字列を得た後に、
Crypt() 関数は <EM>Push(enc,STRING);</EM>を呼び出し、
戻り値を式スタックへプッシュする。
式スタックは PHP/FI の各行の実行後クリアされる。
このため、このスタックに式をプッシュし、どこでもポップしなかったとしても
問題は生じない。<P>
<P>
Crypt() の例における <EM>Debug()</EM> 関数の呼び出しは
関数にデバッグ用出力を付加する仕方を示している。
Debug() は printf と同じく varags (可変引数リスト)関数
である。<P>



<H2><A NAME="hacknotes">ソースコード改造について</A></H2>

<P>PHP/FI 内部のメモリー管理は、厳格に行なわれる。
PHP/FI は、サーバーモジュールとして実行可能であるため、
メモリーリソースに関して、細心の注意を払う必要がある。
再入可能(リエントラント)である必要があるばかりでなく、
モジュールの処理から抜ける時は常に時間切れ(timeout)シグナルを
受けることが可能であるように処理が行なわれる必要がある。
この際には、警告はなく、確保したメモリーを解放する間もない。
このメモリーは解放されなければならない。
さもなくば、モジュールを結合した httpd プロセスのデータ領域は
無限に増えていくであろう。
PHP を CGI モードで実行する際にも、
FastCGI 永続プロセスとして実行するように設定することが可能なので、
同様の注意が必要である。
<P>
<P>解決策は、メモリーのサブプールを用いることである。
このプールは、セッション終了時に Apache により自動的にクリアされる。
ただし、FastCGI 永続プロセスの場合には、
FactCGI ラッパーのループが実行される度に
<EM>main.c</EM> の中の処理によりクリアされる。

3つのこのようなプールが同時に使用される。
これらには、0,1,2 の番号がふられている。
このサブプール番号は、関数 <EM>emalloc</EM> および <EM>estrdup</EM> に対する
最初の引数である。<P>

<DL>
<DT><STRONG>プール 0 - セッションの寿命</STRONG></DT>
<DD>
このプールから割り当てられたメモリーの寿命は、
セッション全体の長さとなる。
このプールの使用は可能な限り抑えることが望ましい。
例えば、while ループを 1000 回反復し、この while ループの中で
プール 0 からメモリーを割り当てるコールを行なう
関数を作成した場合には、メモリーは 1000 回割り当てられることになる。
この方法によると、割り当てられたデータ領域を簡単に全て使い切ってしまう。
</DD>

<DT><STRONG>プール 1 - 一時記憶 (最短の寿命)</STRONG></DT>
<DD>
関数の内部で一時的に機能するバッファが必要である場合には、
このプールからメモリーを割り当てなければならない。
このプールは、yylex() をコールする度にクリアーされる。
すなわち、メモリーは関数の処理が終わると同時に失われる。</DD>
<DT><STRONG>プール 2 - 式領域 (中間の長さの寿命)</STRONG></DT>
<DD>このプールは、式の保持のために存在する。
ここでの式とは、PHP/FI の完全なコマンド行である。
このプールは関数の内部ではクリアされない。
なぜなら、関数をコールしたより高レベルの式に関する処理が
関数が返るまで完全に終わっていないからである。
このプールをクリアしても安全な時に
yylex() 関数の ClearIt フラグを真とする。
</DD>
</DL>
<P>サブプールの使用により、コードのどこかで
明示的にメモリーを解放する必要が全くなくなる。
ただし、
PHP にリンクされた様々なライブラリからの要求を受けた場合は、
例外的に標準の malloc コールを用いてメモリーを割り当てる。
gdbm ライブラリは、この例である。<P>


</BODY>
</HTML>


